<?xml version="1.0"?>
<Ontology xmlns="http://www.w3.org/2002/07/owl#"
     xml:base="http://www.semanticweb.org/ontologies/2018/Software_Engineering"
     xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
     xmlns:xml="http://www.w3.org/XML/1998/namespace"
     xmlns:xsd="http://www.w3.org/2001/XMLSchema#"
     xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
     ontologyIRI="http://www.semanticweb.org/ontologies/2018/Software_Engineering">
    <Prefix name="" IRI="http://www.semanticweb.org/ontologies/2018/Software_Engineering"/>
    <Prefix name="dc" IRI="http://purl.org/dc/elements/1.1/"/>
    <Prefix name="es" IRI="http://www.semanticweb.org/ontologies/2018/engenhaira_de_software/"/>
    <Prefix name="owl" IRI="http://www.w3.org/2002/07/owl#"/>
    <Prefix name="rdf" IRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#"/>
    <Prefix name="xml" IRI="http://www.w3.org/XML/1998/namespace"/>
    <Prefix name="xsd" IRI="http://www.w3.org/2001/XMLSchema#"/>
    <Prefix name="bibo" IRI="http://purl.org/ontology/bibo/"/>
    <Prefix name="foaf" IRI="http://xmlns.com/foaf/spec/"/>
    <Prefix name="rdfs" IRI="http://www.w3.org/2000/01/rdf-schema#"/>
    <Prefix name="skos" IRI="http://www.w3.org/2004/02/skos/core#"/>
    <Prefix name="dcterms" IRI="http://purl.org/dc/terms/"/>
    <Prefix name="engenharia_de_software" IRI="http://www.semanticweb.org/ontologies/2018/engenharia_de_software/"/>
    <Annotation>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Engineering Course</Literal>
    </Annotation>
    <Annotation>
        <AnnotationProperty abbreviatedIRI="owl:versionInfo"/>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">1.5</Literal>
    </Annotation>
    <Annotation>
        <AnnotationProperty abbreviatedIRI="dc:creator"/>
        <Literal datatypeIRI="http://www.w3.org/2001/XMLSchema#string">Victor Hugo Arnaud Deon
Weiller Fernandes Pereira</Literal>
    </Annotation>
    <Annotation>
        <AnnotationProperty abbreviatedIRI="dc:source"/>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">PPC (Pedagogical Course Project) approved in 2011 based on the guidelines of the National Education Council (CNE); In the curriculum guidelines for the Software Engineering courses of the major US engineering and computing associations, such as IEEE-CS and ACM, in the Reference Curricula of Computer Courses of the Brazilian Computer Society SBC and in the book Guide to the Software Engineering Body of Knowledge (SWEEBOK) version 3.0.</Literal>
    </Annotation>
    <Annotation>
        <AnnotationProperty IRI="/habilitation"/>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Graduate</Literal>
    </Annotation>
    <Annotation>
        <AnnotationProperty abbreviatedIRI="rdfs:label"/>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Engineering</Literal>
    </Annotation>
    <Annotation>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Ontology of courses of the software engineering course

Software Engineering is an area of ​​computing focused on the specification, development, maintenance and creation of software systems, applying technologies and practices of project management and other disciplines, aiming at organization, productivity and quality. Currently, these technologies and practices encompass programming languages, database, tools, platforms, libraries, standards, processes and the quality of software issue.

Mission of the bachelor&apos;s degree course in Software Engineering: Promote the teaching, research and extension in Software Engineering to train citizens with professional skills that meet the aspirations of society in relation to software products. In short, these citizens will have the ability to build software applying the principles of engineering, that is, with a systematic, disciplined and quantifiable approach to defining, developing and maintaining software.</Literal>
    </Annotation>
    <Annotation>
        <AnnotationProperty IRI="/goals"/>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The overall objective of the course is to train software engineers who can apply the principles of engineering to build software by applying a systematic, disciplined and quantifiable approach to software development and maintenance.

Among the specific objectives of the Bachelor&apos;s degree in Software Engineering are the following:

a) To train professionals with high scientific and technological qualifications, ethical and socially responsible, who are able to contribute to the development of Brazilian society, committed to the solution of social and environmental problems;

b) To stimulate the questioning and the innovative ideas, to make the future engineer aware of the responsibility with the society when exercising the profession and to guide him in the permanent necessity of professional improvement;

c) To implement pedagogical practices on the part of the teaching staff that stimulate the autonomy, the creativity, the critical spirit, the entrepreneurship and the ethical conduct in the formation of the undergraduate students, in order to form entrepreneurs;

d) To stimulate proactive student attitudes in the pursuit of knowledge, developing autonomy and self-learning capacity;

e) To enable the student to identify the problem to be solved, to seek the solution, to test it, to evaluate it and to develop it, through a versatile professional formation and through interdisciplinary and extracurricular experiences;

f) Promote university extension with community participation as a way of disseminating the scientific and technological research developed throughout the course;

g) Provide a healthy, cooperative and constructive environment where teachers and students are committed to the quality of the course;

h) Ensure a general scientific profile with a background in the subjects of the basic cycle (mathematics, physics and computation), solid training in the professional disciplines (specific to the production of software), with humanistic, social and
environmental;

i) Encourage and promote the search for research and scientific research;

j) To enable the student to participate in the construction of his / her training profile;

k) To guarantee the offer of optional subjects according to a previous planning and of complementary complementary activities in the areas of specific interest of the student and, thus, to allow that this participates in the construction of its profile of formation;

l) To efficiently implement evaluation processes and self-assessment of the course, the teaching-learning process and the desired professional profile;

m) Encourage the interaction of teachers and students with government, industry and other teaching and research institutions.</Literal>
    </Annotation>
    <Annotation>
        <AnnotationProperty IRI="/performance"/>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The graduate of the Software Engineering course must have the potential to act in the design and development of software, as well as in the management of projects, processes and products, working in both private companies and the public sector and academia.

The insertion of the Software Engineering professional can take place with the following professional segments: In industry and in companies where the production of software is an end activity or medium activity, especially companies / industries involving embedded software. In organs or entities of the direct, indirect public administration or with autonomous social entities. In the research and development of software engineering solutions with universities and scientific and technological research entities.</Literal>
    </Annotation>
    <Annotation>
        <AnnotationProperty IRI="/professional_profile"/>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The trained Software Engineer must be able to apply a systematic, disciplined and quantifiable approach to software development and maintenance. This Software Engineer must have the skills to team design, build, and manage the development of software products in a context of technological developments.</Literal>
    </Annotation>
    <Declaration>
        <Class IRI="/Graphs"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Measurement"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Design_a_Solution_Search_Strategy"/>
    </Declaration>
    <Declaration>
        <AnnotationProperty abbreviatedIRI="dc:contributor"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Modeling_Principles"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Divisibility"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Configuration_Management_Tools"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Categories_of_Software_Processes"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Practical_Considerations_Process"/>
    </Declaration>
    <Declaration>
        <Class IRI="/High_Level_Programming_Languages"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Management_of_the_SCM_Process"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Structural_Descriptions_Static_View"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Security_Guidelines"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Proposals"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Reviewing_and_Evaluating_Performance"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Engineering_Process"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Time_Value_of_Money"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Operations_on_Data_Structures"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Design_Patterns"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Analysis_of_Models"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Data_Management"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Models_and_Quality_Characteristics"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Project"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Deviations_and_Waivers"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Practical_Considerations_Quality"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Need_for_Maintenance"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Codes_of_Ethics_and_Professional_Conduct"/>
    </Declaration>
    <Declaration>
        <Class IRI="/User_Interface_Design_Issues"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Prototyping_Engineering"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Engineering_Culture_and_Ethics"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Minimum_Acceptable_Rate_of_Return"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Maintenance_Fundamentals"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Implementation_of_Measurement_Process"/>
    </Declaration>
    <Declaration>
        <Class IRI="/System_Definition_Document"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Change_Management"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Algorithmic_Design_Strategies"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Continuous_and_Staged_Software_Process_Ratings"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Attributes_of_Algorithms"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Formulating_the_Real_Problem"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Professionalism"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Emergent_Properties"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Maintenance"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Life_Cycle_Economics"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Requirements_Specification"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Offshoring_and_Outsourcing"/>
    </Declaration>
    <Declaration>
        <Class IRI="/The_Compilation_Process"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Engineering_Economics"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Architectural_Structures_and_Viewpoints"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Requirements_Tools"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Evaluate_Measurement"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Direct_and_Derived_Measures"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Types_of_Data_Structure"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Decisions_under_Uncertainty"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Steps_Involved_in_Engineering_Design"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Configuration_Management"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Code_Based_Techniques"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Analyzing_for_Consistency"/>
    </Declaration>
    <Declaration>
        <Class IRI="/GUI_Builders"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Information_Models"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Business_Case"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Preconditions_Postconditions_and_Invariants"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Component_Based_Design"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Process_Assessment_and_Improvement"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Process_Support_and_Management"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Optimization_Analysis"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Process_Quality_and_Improvement"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Construction_Languages"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Structure"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Presentation_Skills"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Maintenance_Cost_Estimation"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Localization_and_Internationalization"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Analyze_the_Problem"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Monitor_Process"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Conceptual_Modeling"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Investment_Decisions"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Digital_Logic"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Memory_System_Organization"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Engineering_Economics_Fundamentals"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Goals_Estimates_and_Plans"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Levels_of_Abstraction"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Valuation"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Computing_Foundations"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Selecting_and_Combining_Techniques"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Maintenance_Activities"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Construction_with_Reuse"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Metaphors_and_Conceptual_Models"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Iterative_Nature_of_the_Requirements_Process"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Interpretation_and_Compilation"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Implementing_Software_Changes"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Modeling"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Life_Cycles"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Anticipating_Change"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Empirical_Methods_and_Experimental_Techniques"/>
    </Declaration>
    <Declaration>
        <ObjectProperty IRI="/hasKnowledgeArea"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Techniques_Based_on_the_Nature_of_the_Application"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Effectiveness"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Planning_for_SCM"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Definition_of_a_Software_Requirement"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Engineering_Management_Tools"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Engineering_Management"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Construction_Design"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Data_Structure_Centered_Design"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Quality_Fundamentals"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Mathematical_Foundations"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Functional_and_Nonfunctional_Requirements"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Definition_of_Problem_Solving"/>
    </Declaration>
    <Declaration>
        <AnnotationProperty abbreviatedIRI="dc:creator"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Types_of_Models"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Process_Assessment_Methods"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Construction_Fundamentals"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Requirements"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Overview_of_a_Computer_System"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Practical_Considerations"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Abstraction"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Evaluation_of_the_Program_Under_Test"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Organizational_Context_for_SCM"/>
    </Declaration>
    <Declaration>
        <AnnotationProperty abbreviatedIRI="dc:date"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Finance"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Maintenance_Tools"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Control_Process"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Types_of_Errors"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Quality_Analysis_and_Evaluation_Techniques"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Quality_Attributes"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Compiler_Basics"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Assertions_Design_by_Contract_and_Defensive_Programming"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Team_and_Group_Communication"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Virtual_Private_Network"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Engineering_Foundations"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Initiation_and_Scope_Definition"/>
    </Declaration>
    <Declaration>
        <AnnotationProperty abbreviatedIRI="dc:rights"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Programming_Language_Overview"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Resource_Allocation"/>
    </Declaration>
    <Declaration>
        <Class IRI="/General_Strategies"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Engineering_Design"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Algorithms_and_Complexity"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Individual_Cognition"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Practical_Considerations_Construction"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Reading_Understanding_and_Summarizing"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Process_and_Product_Measurement"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Proof_Techniques"/>
    </Declaration>
    <Declaration>
        <Class IRI="/General_Design_Concepts"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Main_Issues_in_Distributed_Computing"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Feasibility_Analysis"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Root_Cause_Analysis"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Accounting"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Basic_Concept_of_a_System"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Interacting_with_Stakeholders"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Closure_Activities"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Testing_Related_Terminology"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Identifying_Items_to_Be_Controlled"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Structure_Modeling"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Practical_Considerations_Testing"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Quality_Measurement"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Graphs_and_Trees"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Multiple_Attribute_Evaluation"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Design"/>
    </Declaration>
    <Declaration>
        <AnnotationProperty abbreviatedIRI="dc:subject"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Pedagogical_Project"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Quality_Requirements"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Price_and_Pricing"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Requirements_Security"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Supervised_internship"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Communication_Skills"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Basic_User_Human_Factors"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Configuration_Status_Accounting"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Inflation"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Data_Structure_and_Representation"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Determining_Closure"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Design_Process"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Integration"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Relationship_of_Testing_to_Other_Activities"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Finite_State_Machines"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Propositional_Logic"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Addressing_Uncertainty"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Curriculum"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Tasks_of_an_Operating_System"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Compiler_or_Interpreter_Overview"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Categories_of_Maintenance"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Construction_Testing"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Requirements_Negotiation"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Quality_Tools"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Grammars"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Distribution_of_Components"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Requirements_Fundamentals"/>
    </Declaration>
    <Declaration>
        <Class IRI="/The_Internet"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Majority_of_Maintenance_Costs"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Engineering_Process_Tools"/>
    </Declaration>
    <Declaration>
        <AnnotationProperty IRI="/habilitation"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Design_Tools"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Prioritization"/>
    </Declaration>
    <Declaration>
        <AnnotationProperty abbreviatedIRI="dc:relation"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Techniques_for_Conducting_Root_Cause_Analysis"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Formal_Analysis"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Statistical_Analysis"/>
    </Declaration>
    <Declaration>
        <Class IRI="/The_Central_Processing_Unit"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Plan_Management"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Portfolio"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Formal_Methods"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Dealing_with_Multicultural_Environments"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Quality_Management"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Key_Issues"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Defect_Characterization"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Safety"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Product_Life_Cycle"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Management_Issues"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Traceability"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Determination_and_Negotiation_of_Requirements"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Input_Domain_Based_Techniques"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Accreditation_Certification_and_Licensing"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Quality_Improvement"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Types_of_Network"/>
    </Declaration>
    <Declaration>
        <AnnotationProperty IRI="/professional_profile"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Debugging_Techniques"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Process_for_the_Review_and_Revision_of_Requirements"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Core_Professional_Content"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Parameterization_and_Generics"/>
    </Declaration>
    <Declaration>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Verification_e_Validation"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Language_Recognition"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Minimizing_Complexity"/>
    </Declaration>
    <Declaration>
        <Class IRI="/User_Interface_Design_Process"/>
    </Declaration>
    <Declaration>
        <Class IRI="/The_Good_Enough_Principle"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Input_and_Output"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Families_of_Programs_and_Frameworks"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Risk_and_Uncertainty"/>
    </Declaration>
    <Declaration>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Set_Relations_Functions"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Building"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Constructing_for_Verification"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Cost_Benefit_Analysis"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Testing_Fundamentals"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Life_Cycle_Models"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Trees"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Usage_Based_Techniques"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Operating_Systems_Overview"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Profiling_Performance_Analysis_and_Slicing_Tools"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Technical_Issues"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Relation_and_Function"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Testing_Tool_Support"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Executable_Models"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Core_Specific_Content"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Elicitation_Techniques"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Teaching_Activities"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Testing"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Maintenance_Processes"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Data_Persistence"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Standards"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Construction_for_Reuse"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Activities_of_student_representations"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Construction_Measurement"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Dealing_with_Problem_Complexity"/>
    </Declaration>
    <Declaration>
        <Class IRI="/System_Requirements_and_Software_Requirements"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Computer_Organization_Overview"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Effort_Schedule_and_Cost_Estimation"/>
    </Declaration>
    <Declaration>
        <AnnotationProperty abbreviatedIRI="dcterms:license"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Nature_and_Role_of_Professional_Societies"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Design_Notations"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Prototyping_Methods"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Quality_Management_Techniques"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Database_Basics_and_Data_Management"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Overview_of_Algorithms"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Alternate_Abstractions"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Behavioral_Descriptions_Dynamic_View"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Cost_and_Costing"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Testing_Security"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Basic_Developer_Human_Factors"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Construction"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Constraints_and_Guidance_for_the_SCM_Process"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Requirements_Sources"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Reporting"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Model_Validation"/>
    </Declaration>
    <Declaration>
        <Class IRI="/User_Input_and_Output"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Algorithmic_Analysis"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Operating_Systems_Basics"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Perform_the_Measurement_Process"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Migration"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Constructing_Heterogeneous_Systems"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Decision_Making_Process"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Cash_Flow"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Performance_Measurement"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Network_Communication_Basics"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Group"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Core_Basic_Content"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Agile_Methods"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Acquisition_and_Supplier_Contract_Management"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Maintenance_Process"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Hierarchy"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Product_and_Process_Requirements"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Requirements_Process"/>
    </Declaration>
    <Declaration>
        <Class IRI="/For_Profit_Decision_Analysis"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Measuring_Requirements"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Controlling"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Program"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Maintenance_Measurement"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Construction_Tools"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Requesting_Evaluating_and_Approving_Software_Changes"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Context_of_Software_Design"/>
    </Declaration>
    <Declaration>
        <Class IRI="/System_Requirements_Specification"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Functional_Configuration_Audit"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Entity_and_Schema"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Definitions_and_Terminology"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Nature_of_Maintenance"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Mobility_and_Exchange_Activities"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Performance_Analysis_and_Tuning"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Key_Issues_in_Software_Design"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Quality_Assurance"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Emergent_System_Properties"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Process_Management"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Analyzing_for_Correctness"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Construction_Planning"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Assessing_Reliability"/>
    </Declaration>
    <Declaration>
        <Class IRI="/State_Based_and_Table_Driven_Construction_Techniques"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Test_Levels"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Construction_Methods_for_Distributed_Software"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Architecture_Design_Decisions"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Free_Module_and_Complementary_and_Extension_Activities"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Group_Dynamics_and_Psychology"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Ecosystems"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Return_on_Investment"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Engineering_Professional_Practice"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Grammar_Based_Input_Processing"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Data_Mining"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Unit_Testing_Tools"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Process_Measurement_Techniques"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Process_Assessment_Models"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Concurrency"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Test_First_Programming"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Parallel_and_Distributed_Computing"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Engineering_Methods"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Determining_Satisfaction_of_Requirements"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Design_Principles"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Engineering_Design_in_Engineering_Education"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Surveillance_of_Software_Configuration_Management"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Requirements_Attributes"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Based_on_the_Software_Engineers_Intuition_and_Experience"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Test_Techniques"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Objectives_of_Testing"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Construction_Security"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Difference_between_Parallel_and_Distributed_Computing"/>
    </Declaration>
    <Declaration>
        <Class IRI="/The_Design_of_Information_Presentation"/>
    </Declaration>
    <Declaration>
        <AnnotationProperty abbreviatedIRI="dc:identifier"/>
    </Declaration>
    <Declaration>
        <ObjectProperty IRI="/isKnowledgeAreaOf"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Process_Actors"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Acceptance_Tests"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Reliability_and_Validity"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Construction_Quality"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Process_Planning"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Implementation_of_Plans"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Managing_Construction"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Numerical_Precision_Accuracy_and_Errors"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Program_Comprehension"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Process_Infrastructure"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Database_Management_Systems"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Economic_Analysis_Methods"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Process_Adaptation"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Syntax_and_Semantics_of_Programming_Languages"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Engineering_Models_and_Methods"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Properties_of_Set"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Basics_of_Counting"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Tasks_of_DBMS_Packages"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Review_and_Evaluation"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Writing"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Decisions_under_Risk"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Operating_Systems_Classification"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Product"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Coding"/>
    </Declaration>
    <Declaration>
        <AnnotationProperty abbreviatedIRI="dc:publisher"/>
    </Declaration>
    <Declaration>
        <Class IRI="/The_Programming_Process"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Configuration_Status_Information"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Unit_of_Analysis_Population_and_Sample"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Requirements_Reviews"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Engineering"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Design_as_a_Problem_Solving_Activity"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Operating_System_Abstractions"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Categories_of_Tools"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Retirement"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Systems_Engineering"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Extension_Activities"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Productivity"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Syntax_Semantics_and_Pragmatics"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Quality_of_Measurement_Results"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Physical_Configuration_Audit"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Error_Handling_Exception_Handling_and_Fault_Tolerance"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Multidisciplinary"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Programming_Paradigms"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Fault_Based_Techniques"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Internet_of_Things"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Return_on_Capital_Employed"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Basic_Logic"/>
    </Declaration>
    <Declaration>
        <Class IRI="/In_Process_Audits_of_a_Software_Baseline"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Termination_Decisions"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Evolution_of_Software"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Process_Improvement_Models"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Construction_in_Life_Cycle_Models"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Comments"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Course_Completion_Work"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Practical_Considerations_Requirements"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Project_Life_Cycle"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Release_Management_and_Delivery"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Earned_Value_Management"/>
    </Declaration>
    <Declaration>
        <Class IRI="/API_Design_and_Use"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Parallel_and_Distributed_Computing_Models"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Programming_Language_Basics"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Quality"/>
    </Declaration>
    <Declaration>
        <Class IRI="/User_Interface_Design"/>
    </Declaration>
    <Declaration>
        <AnnotationProperty abbreviatedIRI="dc:type"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Platform_Standards"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Configuration_Status_Reporting"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Heuristic_Methods"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Reverse_Engineering"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Parallel_and_Distributed_Computing_Overview"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Estimation_Techniques"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Build_Security_into_Software_Engineering_Process"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Analyzing_for_Completeness"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Predicate_Logic"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Architectural_Styles"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Engineering_Measurement"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Standards_in_Construction"/>
    </Declaration>
    <Declaration>
        <Class IRI="/The_Target_of_the_Test"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Test_Related_Measures"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Prototyping"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Set_Operations"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Encapsulation"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Test_Activities"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Information_Modeling"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Configuration_Identification"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Configuration_Auditing"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Value_and_Costs_of_Quality"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Tradeoff_Analysis"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Project_Enactment"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Requirements_Classification"/>
    </Declaration>
    <Declaration>
        <AnnotationProperty abbreviatedIRI="dcterms:provenance"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Activities_of_Social_Action_Citizenship_and_Environment"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Construction_Technologies"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Retrospective_Study"/>
    </Declaration>
    <Declaration>
        <Class IRI="/SCM_Plan"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Error_Messages"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Reengineering"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Properties_and_Expression_of_Models"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Number_Theory"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Interaction_Analysis"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Requirements_Analysis"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Professional_Practice_Activities"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Legal_Issues"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Requirements_Elicitation"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Release_Management"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Algebraic_Structures"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Design_Strategies_and_Methods"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Measurement"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Research_Activities"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Design_Security"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Interaction_and_Presentation"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Dynamics_of_Working_in_Teams_Groups"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Behavioral_Modeling"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Requirements_Tracing"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Middleware"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Closure"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Secure_Software_Development_and_Maintenance"/>
    </Declaration>
    <Declaration>
        <AnnotationProperty abbreviatedIRI="dc:language"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Break_Even_Analysis"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Knowledge_Area"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Design_Quality_Analysis_and_Evaluation"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Requirements_Specification"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Computer_Expression_of_Data"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Configuration_Control"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Determine_Deliverables"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Problem_Solving_Using_Programs"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Control_and_Handling_of_Events"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Networking_Protocols_and_Standards"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Quantifiable_Requirements"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Database_Query_Language"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Reviews_and_Audits"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Declarative_vs_Imperative_Programming_Languages"/>
    </Declaration>
    <Declaration>
        <AnnotationProperty IRI="/goals"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Taxation"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Concepts_of_Correlation_and_Regression"/>
    </Declaration>
    <Declaration>
        <AnnotationProperty IRI="/performance"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Integrator_Project"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Measures"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Design_Fundamentals"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Risk_Management"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Key_Issues_in_Software_Maintenance"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Computer_Organization"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Robustness"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Low_Level_Programming_Languages"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Process_Models"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Requirements_Validation"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Friction_Free_Economy"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Planning_Horizon"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Economic_Impact_of_Software"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Algorithmic_Analysis_Strategies"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Basic_Network_Components"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Employment_Contracts"/>
    </Declaration>
    <Declaration>
        <AnnotationProperty abbreviatedIRI="dcterms:alternative"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Rings"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Replacement_and_Retirement_Decisions"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Model_Based_Testing_Techniques"/>
    </Declaration>
    <Declaration>
        <AnnotationProperty abbreviatedIRI="dcterms:available"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Architectural_Design_and_Requirements_Allocation"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Object_Oriented_Runtime_Issues"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Documentation"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Nature_and_Role_of_Software_Engineering_Standards"/>
    </Declaration>
    <Declaration>
        <Class IRI="/The_Design_of_User_Interaction_Modalities"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Efficiency"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Problem_Solving_Techniques"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Error_and_Exception_Handling_and_Fault_Tolerance"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Function_Oriented_Structured_Design"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Techniques_for_Maintenance"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Methods_of_Proving_Theorems"/>
    </Declaration>
    <Declaration>
        <Class IRI="/General_User_Interface_Design_Principles"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Levels_of_Measurement"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Plan_the_Measurement_Process"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Object_Oriented_Design"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Security"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Modeling_Simulation_and_Prototyping"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Data_Structure_Overview"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Reuse"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Debugging_Tools"/>
    </Declaration>
    <Declaration>
        <AnnotationProperty abbreviatedIRI="dc:source"/>
    </Declaration>
    <Declaration>
        <AnnotationProperty abbreviatedIRI="dc:format"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Process_Definition"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Establish_and_Sustain_Measurement_Commitment"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Cost_Effectiveness_Analysis"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Designed_Experiment"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Prime_Number_GCD"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Dealing_with_Uncertainty_and_Ambiguity"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Simulation_Engineering"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Debugging_Tools_and_Techniques"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Discrete_Probability"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Programming_Fundamentals"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Test_Process"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Runtime_Configuration_and_Internationalization"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Evaluation_of_the_Tests_Performed"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Structure_and_Architecture"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Digital_Systems"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Observational_Study"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Testing_Tools"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Library"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Modeling_Engineering"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Project_Planning"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Concurrency_Primitives"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Software_Quality_Management_Processes"/>
    </Declaration>
    <Declaration>
        <Class IRI="/Development_Environments"/>
    </Declaration>
    <SubClassOf>
        <Class IRI="/API_Design_and_Use"/>
        <Class IRI="/Construction_Technologies"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Abstraction"/>
        <Class IRI="/Computing_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Acceptance_Tests"/>
        <Class IRI="/Requirements_Validation"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Accounting"/>
        <Class IRI="/Software_Engineering_Economics_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Accreditation_Certification_and_Licensing"/>
        <Class IRI="/Professionalism"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Activities_of_Social_Action_Citizenship_and_Environment"/>
        <Class IRI="/Free_Module_and_Complementary_and_Extension_Activities"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Activities_of_student_representations"/>
        <Class IRI="/Free_Module_and_Complementary_and_Extension_Activities"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Addressing_Uncertainty"/>
        <Class IRI="/Risk_and_Uncertainty"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Agile_Methods"/>
        <Class IRI="/Software_Engineering_Methods"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Algebraic_Structures"/>
        <Class IRI="/Mathematical_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Algorithmic_Analysis"/>
        <Class IRI="/Algorithms_and_Complexity"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Algorithmic_Analysis_Strategies"/>
        <Class IRI="/Algorithms_and_Complexity"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Algorithmic_Design_Strategies"/>
        <Class IRI="/Algorithms_and_Complexity"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Algorithms_and_Complexity"/>
        <Class IRI="/Computing_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Alternate_Abstractions"/>
        <Class IRI="/Abstraction"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Analysis_of_Models"/>
        <Class IRI="/Software_Engineering_Models_and_Methods"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Analyze_the_Problem"/>
        <Class IRI="/Problem_Solving_Techniques"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Analyzing_for_Completeness"/>
        <Class IRI="/Analysis_of_Models"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Analyzing_for_Consistency"/>
        <Class IRI="/Analysis_of_Models"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Analyzing_for_Correctness"/>
        <Class IRI="/Analysis_of_Models"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Anticipating_Change"/>
        <Class IRI="/Software_Construction_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Architectural_Design_and_Requirements_Allocation"/>
        <Class IRI="/Requirements_Analysis"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Architectural_Structures_and_Viewpoints"/>
        <Class IRI="/Software_Structure_and_Architecture"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Architectural_Styles"/>
        <Class IRI="/Software_Structure_and_Architecture"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Architecture_Design_Decisions"/>
        <Class IRI="/Software_Structure_and_Architecture"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Assertions_Design_by_Contract_and_Defensive_Programming"/>
        <Class IRI="/Construction_Technologies"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Assessing_Reliability"/>
        <Class IRI="/Measurement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Attributes_of_Algorithms"/>
        <Class IRI="/Algorithms_and_Complexity"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Based_on_the_Software_Engineers_Intuition_and_Experience"/>
        <Class IRI="/Test_Techniques"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Basic_Concept_of_a_System"/>
        <Class IRI="/Computing_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Basic_Developer_Human_Factors"/>
        <Class IRI="/Computing_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Basic_Logic"/>
        <Class IRI="/Mathematical_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Basic_Network_Components"/>
        <Class IRI="/Network_Communication_Basics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Basic_User_Human_Factors"/>
        <Class IRI="/Computing_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Basics_of_Counting"/>
        <Class IRI="/Mathematical_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Behavioral_Descriptions_Dynamic_View"/>
        <Class IRI="/Software_Design_Notations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Behavioral_Modeling"/>
        <Class IRI="/Types_of_Models"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Break_Even_Analysis"/>
        <Class IRI="/Economic_Analysis_Methods"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Build_Security_into_Software_Engineering_Process"/>
        <Class IRI="/Secure_Software_Development_and_Maintenance"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Business_Case"/>
        <Class IRI="/Economic_Analysis_Methods"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Cash_Flow"/>
        <Class IRI="/Software_Engineering_Economics_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Categories_of_Maintenance"/>
        <Class IRI="/Software_Maintenance_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Categories_of_Software_Processes"/>
        <Class IRI="/Software_Life_Cycles"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Categories_of_Tools"/>
        <Class IRI="/Software_Testing_Tools"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Change_Management"/>
        <Class IRI="/Practical_Considerations_Requirements"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Closure"/>
        <Class IRI="/Software_Engineering_Management"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Closure_Activities"/>
        <Class IRI="/Closure"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Code_Based_Techniques"/>
        <Class IRI="/Test_Techniques"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Codes_of_Ethics_and_Professional_Conduct"/>
        <Class IRI="/Professionalism"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Coding"/>
        <Class IRI="/Practical_Considerations_Construction"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Comments"/>
        <Class IRI="/Basic_Developer_Human_Factors"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Communication_Skills"/>
        <Class IRI="/Software_Engineering_Professional_Practice"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Compiler_Basics"/>
        <Class IRI="/Computing_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Compiler_or_Interpreter_Overview"/>
        <Class IRI="/Compiler_Basics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Component_Based_Design"/>
        <Class IRI="/Software_Design_Strategies_and_Methods"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Computer_Expression_of_Data"/>
        <Class IRI="/Computer_Organization"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Computer_Organization"/>
        <Class IRI="/Computing_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Computer_Organization_Overview"/>
        <Class IRI="/Computer_Organization"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Computing_Foundations"/>
        <Class IRI="/Knowledge_Area"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Computing_Foundations"/>
        <ObjectSomeValuesFrom>
            <ObjectProperty IRI="/isKnowledgeAreaOf"/>
            <Class IRI="/Core_Professional_Content"/>
        </ObjectSomeValuesFrom>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Concepts_of_Correlation_and_Regression"/>
        <Class IRI="/Statistical_Analysis"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Conceptual_Modeling"/>
        <Class IRI="/Requirements_Analysis"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Concurrency"/>
        <Class IRI="/Key_Issues_in_Software_Design"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Concurrency_Primitives"/>
        <Class IRI="/Construction_Technologies"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Constraints_and_Guidance_for_the_SCM_Process"/>
        <Class IRI="/Management_of_the_SCM_Process"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Constructing_Heterogeneous_Systems"/>
        <Class IRI="/Construction_Technologies"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Constructing_for_Verification"/>
        <Class IRI="/Software_Construction_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Construction_Design"/>
        <Class IRI="/Practical_Considerations_Construction"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Construction_Languages"/>
        <Class IRI="/Practical_Considerations_Construction"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Construction_Measurement"/>
        <Class IRI="/Managing_Construction"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Construction_Methods_for_Distributed_Software"/>
        <Class IRI="/Construction_Technologies"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Construction_Planning"/>
        <Class IRI="/Managing_Construction"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Construction_Quality"/>
        <Class IRI="/Practical_Considerations_Construction"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Construction_Technologies"/>
        <Class IRI="/Software_Construction"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Construction_Testing"/>
        <Class IRI="/Practical_Considerations_Construction"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Construction_for_Reuse"/>
        <Class IRI="/Practical_Considerations_Construction"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Construction_in_Life_Cycle_Models"/>
        <Class IRI="/Managing_Construction"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Construction_with_Reuse"/>
        <Class IRI="/Practical_Considerations_Construction"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Context_of_Software_Design"/>
        <Class IRI="/Software_Design_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Continuous_and_Staged_Software_Process_Ratings"/>
        <Class IRI="/Software_Process_Assessment_and_Improvement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Control_Process"/>
        <Class IRI="/Software_Project_Enactment"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Control_and_Handling_of_Events"/>
        <Class IRI="/Key_Issues_in_Software_Design"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Controlling"/>
        <Class IRI="/Software_Engineering_Economics_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Core_Basic_Content"/>
        <Class IRI="/Curriculum"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Core_Basic_Content"/>
        <ObjectSomeValuesFrom>
            <ObjectProperty IRI="/hasKnowledgeArea"/>
            <Class IRI="/Engineering_Foundations"/>
        </ObjectSomeValuesFrom>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Core_Basic_Content"/>
        <ObjectSomeValuesFrom>
            <ObjectProperty IRI="/hasKnowledgeArea"/>
            <Class IRI="/Mathematical_Foundations"/>
        </ObjectSomeValuesFrom>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Core_Basic_Content"/>
        <ObjectSomeValuesFrom>
            <ObjectProperty IRI="/hasKnowledgeArea"/>
            <Class IRI="/Software_Engineering_Economics"/>
        </ObjectSomeValuesFrom>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Core_Basic_Content"/>
        <ObjectSomeValuesFrom>
            <ObjectProperty IRI="/hasKnowledgeArea"/>
            <Class IRI="/Software_Engineering_Professional_Practice"/>
        </ObjectSomeValuesFrom>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Core_Professional_Content"/>
        <Class IRI="/Curriculum"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Core_Professional_Content"/>
        <ObjectSomeValuesFrom>
            <ObjectProperty IRI="/hasKnowledgeArea"/>
            <Class IRI="/Computing_Foundations"/>
        </ObjectSomeValuesFrom>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Core_Professional_Content"/>
        <ObjectSomeValuesFrom>
            <ObjectProperty IRI="/hasKnowledgeArea"/>
            <Class IRI="/Software_Construction"/>
        </ObjectSomeValuesFrom>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Core_Professional_Content"/>
        <ObjectSomeValuesFrom>
            <ObjectProperty IRI="/hasKnowledgeArea"/>
            <Class IRI="/Software_Maintenance"/>
        </ObjectSomeValuesFrom>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Core_Professional_Content"/>
        <ObjectSomeValuesFrom>
            <ObjectProperty IRI="/hasKnowledgeArea"/>
            <Class IRI="/Software_Testing"/>
        </ObjectSomeValuesFrom>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Core_Specific_Content"/>
        <Class IRI="/Curriculum"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Core_Specific_Content"/>
        <ObjectSomeValuesFrom>
            <ObjectProperty IRI="/hasKnowledgeArea"/>
            <Class IRI="/Software_Configuration_Management"/>
        </ObjectSomeValuesFrom>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Core_Specific_Content"/>
        <ObjectSomeValuesFrom>
            <ObjectProperty IRI="/hasKnowledgeArea"/>
            <Class IRI="/Software_Design"/>
        </ObjectSomeValuesFrom>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Core_Specific_Content"/>
        <ObjectSomeValuesFrom>
            <ObjectProperty IRI="/hasKnowledgeArea"/>
            <Class IRI="/Software_Engineering_Management"/>
        </ObjectSomeValuesFrom>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Core_Specific_Content"/>
        <ObjectSomeValuesFrom>
            <ObjectProperty IRI="/hasKnowledgeArea"/>
            <Class IRI="/Software_Engineering_Models_and_Methods"/>
        </ObjectSomeValuesFrom>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Core_Specific_Content"/>
        <ObjectSomeValuesFrom>
            <ObjectProperty IRI="/hasKnowledgeArea"/>
            <Class IRI="/Software_Engineering_Process"/>
        </ObjectSomeValuesFrom>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Core_Specific_Content"/>
        <ObjectSomeValuesFrom>
            <ObjectProperty IRI="/hasKnowledgeArea"/>
            <Class IRI="/Software_Quality"/>
        </ObjectSomeValuesFrom>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Core_Specific_Content"/>
        <ObjectSomeValuesFrom>
            <ObjectProperty IRI="/hasKnowledgeArea"/>
            <Class IRI="/Software_Requirements"/>
        </ObjectSomeValuesFrom>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Cost_Benefit_Analysis"/>
        <Class IRI="/Economic_Analysis_Methods"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Cost_Effectiveness_Analysis"/>
        <Class IRI="/Economic_Analysis_Methods"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Cost_and_Costing"/>
        <Class IRI="/Life_Cycle_Economics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Course_Completion_Work"/>
        <Class IRI="/Multidisciplinary"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Curriculum"/>
        <Class IRI="/Pedagogical_Project"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Data_Management"/>
        <Class IRI="/Database_Basics_and_Data_Management"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Data_Mining"/>
        <Class IRI="/Database_Basics_and_Data_Management"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Data_Persistence"/>
        <Class IRI="/Key_Issues_in_Software_Design"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Data_Structure_Centered_Design"/>
        <Class IRI="/Software_Design_Strategies_and_Methods"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Data_Structure_Overview"/>
        <Class IRI="/Data_Structure_and_Representation"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Data_Structure_and_Representation"/>
        <Class IRI="/Computing_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Database_Basics_and_Data_Management"/>
        <Class IRI="/Computing_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Database_Management_Systems"/>
        <Class IRI="/Database_Basics_and_Data_Management"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Database_Query_Language"/>
        <Class IRI="/Database_Basics_and_Data_Management"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Dealing_with_Multicultural_Environments"/>
        <Class IRI="/Group_Dynamics_and_Psychology"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Dealing_with_Problem_Complexity"/>
        <Class IRI="/Group_Dynamics_and_Psychology"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Dealing_with_Uncertainty_and_Ambiguity"/>
        <Class IRI="/Group_Dynamics_and_Psychology"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Debugging_Techniques"/>
        <Class IRI="/Debugging_Tools_and_Techniques"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Debugging_Tools"/>
        <Class IRI="/Debugging_Tools_and_Techniques"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Debugging_Tools_and_Techniques"/>
        <Class IRI="/Computing_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Decision_Making_Process"/>
        <Class IRI="/Software_Engineering_Economics_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Decisions_under_Risk"/>
        <Class IRI="/Risk_and_Uncertainty"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Decisions_under_Uncertainty"/>
        <Class IRI="/Risk_and_Uncertainty"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Declarative_vs_Imperative_Programming_Languages"/>
        <Class IRI="/Programming_Language_Basics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Defect_Characterization"/>
        <Class IRI="/Practical_Considerations_Quality"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Definition_of_Problem_Solving"/>
        <Class IRI="/Problem_Solving_Techniques"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Definition_of_a_Software_Requirement"/>
        <Class IRI="/Software_Requirements_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Definitions_and_Terminology"/>
        <Class IRI="/Software_Maintenance_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Design_Patterns"/>
        <Class IRI="/Software_Structure_and_Architecture"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Design_a_Solution_Search_Strategy"/>
        <Class IRI="/Problem_Solving_Techniques"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Design_as_a_Problem_Solving_Activity"/>
        <Class IRI="/Engineering_Design"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Designed_Experiment"/>
        <Class IRI="/Empirical_Methods_and_Experimental_Techniques"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Determination_and_Negotiation_of_Requirements"/>
        <Class IRI="/Initiation_and_Scope_Definition"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Determine_Deliverables"/>
        <Class IRI="/Software_Project_Planning"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Determining_Closure"/>
        <Class IRI="/Closure"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Determining_Satisfaction_of_Requirements"/>
        <Class IRI="/Review_and_Evaluation"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Development_Environments"/>
        <Class IRI="/Software_Construction_Tools"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Deviations_and_Waivers"/>
        <Class IRI="/Software_Configuration_Control"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Difference_between_Parallel_and_Distributed_Computing"/>
        <Class IRI="/Parallel_and_Distributed_Computing"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Digital_Logic"/>
        <Class IRI="/Computer_Organization"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Digital_Systems"/>
        <Class IRI="/Computer_Organization"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Direct_and_Derived_Measures"/>
        <Class IRI="/Measurement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Discrete_Probability"/>
        <Class IRI="/Mathematical_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Distribution_of_Components"/>
        <Class IRI="/Key_Issues_in_Software_Design"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Divisibility"/>
        <Class IRI="/Number_Theory"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Documentation"/>
        <Class IRI="/Professionalism"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Dynamics_of_Working_in_Teams_Groups"/>
        <Class IRI="/Group_Dynamics_and_Psychology"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Earned_Value_Management"/>
        <Class IRI="/Life_Cycle_Economics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Economic_Analysis_Methods"/>
        <Class IRI="/Software_Engineering_Economics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Economic_Impact_of_Software"/>
        <Class IRI="/Professionalism"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Ecosystems"/>
        <Class IRI="/Practical_Considerations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Effectiveness"/>
        <Class IRI="/Software_Engineering_Economics_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Efficiency"/>
        <Class IRI="/Software_Engineering_Economics_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Effort_Schedule_and_Cost_Estimation"/>
        <Class IRI="/Software_Project_Planning"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Elicitation_Techniques"/>
        <Class IRI="/Requirements_Elicitation"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Emergent_Properties"/>
        <Class IRI="/Software_Requirements_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Emergent_System_Properties"/>
        <Class IRI="/Basic_Concept_of_a_System"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Empirical_Methods_and_Experimental_Techniques"/>
        <Class IRI="/Engineering_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Employment_Contracts"/>
        <Class IRI="/Professionalism"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Encapsulation"/>
        <Class IRI="/Abstraction"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Engineering_Design"/>
        <Class IRI="/Engineering_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Engineering_Design_in_Engineering_Education"/>
        <Class IRI="/Engineering_Design"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Engineering_Foundations"/>
        <Class IRI="/Knowledge_Area"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Engineering_Foundations"/>
        <ObjectSomeValuesFrom>
            <ObjectProperty IRI="/isKnowledgeAreaOf"/>
            <Class IRI="/Core_Basic_Content"/>
        </ObjectSomeValuesFrom>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Entity_and_Schema"/>
        <Class IRI="/Database_Basics_and_Data_Management"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Error_Handling_Exception_Handling_and_Fault_Tolerance"/>
        <Class IRI="/Construction_Technologies"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Error_Messages"/>
        <Class IRI="/Basic_User_Human_Factors"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Error_and_Exception_Handling_and_Fault_Tolerance"/>
        <Class IRI="/Key_Issues_in_Software_Design"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Establish_and_Sustain_Measurement_Commitment"/>
        <Class IRI="/Software_Engineering_Measurement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Estimation_Techniques"/>
        <Class IRI="/Risk_and_Uncertainty"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Evaluate_Measurement"/>
        <Class IRI="/Software_Engineering_Measurement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Evaluation_of_the_Program_Under_Test"/>
        <Class IRI="/Test_Related_Measures"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Evaluation_of_the_Tests_Performed"/>
        <Class IRI="/Test_Related_Measures"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Evolution_of_Software"/>
        <Class IRI="/Software_Maintenance_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Executable_Models"/>
        <Class IRI="/Construction_Technologies"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Extension_Activities"/>
        <Class IRI="/Free_Module_and_Complementary_and_Extension_Activities"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Families_of_Programs_and_Frameworks"/>
        <Class IRI="/Software_Structure_and_Architecture"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Fault_Based_Techniques"/>
        <Class IRI="/Test_Techniques"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Feasibility_Analysis"/>
        <Class IRI="/Initiation_and_Scope_Definition"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Finance"/>
        <Class IRI="/Software_Engineering_Economics_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Finite_State_Machines"/>
        <Class IRI="/Mathematical_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/For_Profit_Decision_Analysis"/>
        <Class IRI="/Economic_Analysis_Methods"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Formal_Analysis"/>
        <Class IRI="/Requirements_Analysis"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Formal_Methods"/>
        <Class IRI="/Software_Engineering_Methods"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Formulating_the_Real_Problem"/>
        <Class IRI="/Problem_Solving_Techniques"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Free_Module_and_Complementary_and_Extension_Activities"/>
        <Class IRI="/Curriculum"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Friction_Free_Economy"/>
        <Class IRI="/Practical_Considerations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Function_Oriented_Structured_Design"/>
        <Class IRI="/Software_Design_Strategies_and_Methods"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Functional_and_Nonfunctional_Requirements"/>
        <Class IRI="/Software_Requirements_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/GUI_Builders"/>
        <Class IRI="/Software_Construction_Tools"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/General_Design_Concepts"/>
        <Class IRI="/Software_Design_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/General_Strategies"/>
        <Class IRI="/Software_Design_Strategies_and_Methods"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/General_User_Interface_Design_Principles"/>
        <Class IRI="/User_Interface_Design"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Goals_Estimates_and_Plans"/>
        <Class IRI="/Risk_and_Uncertainty"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Grammar_Based_Input_Processing"/>
        <Class IRI="/Construction_Technologies"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Grammars"/>
        <Class IRI="/Mathematical_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Graphs"/>
        <Class IRI="/Graphs_and_Trees"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Graphs_and_Trees"/>
        <Class IRI="/Mathematical_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Group"/>
        <Class IRI="/Algebraic_Structures"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Group_Dynamics_and_Psychology"/>
        <Class IRI="/Software_Engineering_Professional_Practice"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Heuristic_Methods"/>
        <Class IRI="/Software_Engineering_Methods"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Hierarchy"/>
        <Class IRI="/Abstraction"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/High_Level_Programming_Languages"/>
        <Class IRI="/Programming_Language_Basics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Identifying_Items_to_Be_Controlled"/>
        <Class IRI="/Software_Configuration_Identification"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Implementation_of_Measurement_Process"/>
        <Class IRI="/Software_Project_Enactment"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Implementation_of_Plans"/>
        <Class IRI="/Software_Project_Enactment"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Implementing_Software_Changes"/>
        <Class IRI="/Software_Configuration_Control"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/In_Process_Audits_of_a_Software_Baseline"/>
        <Class IRI="/Software_Configuration_Auditing"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Individual_Cognition"/>
        <Class IRI="/Group_Dynamics_and_Psychology"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Inflation"/>
        <Class IRI="/Software_Engineering_Economics_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Information_Modeling"/>
        <Class IRI="/Types_of_Models"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Initiation_and_Scope_Definition"/>
        <Class IRI="/Software_Engineering_Management"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Input_Domain_Based_Techniques"/>
        <Class IRI="/Test_Techniques"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Input_and_Output"/>
        <Class IRI="/Computer_Organization"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Integration"/>
        <Class IRI="/Practical_Considerations_Construction"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Integrator_Project"/>
        <Class IRI="/Multidisciplinary"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Interacting_with_Stakeholders"/>
        <Class IRI="/Group_Dynamics_and_Psychology"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Interaction_Analysis"/>
        <Class IRI="/Analysis_of_Models"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Interaction_and_Presentation"/>
        <Class IRI="/Key_Issues_in_Software_Design"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Internet_of_Things"/>
        <Class IRI="/Network_Communication_Basics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Interpretation_and_Compilation"/>
        <Class IRI="/Compiler_Basics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Investment_Decisions"/>
        <Class IRI="/Life_Cycle_Economics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Iterative_Nature_of_the_Requirements_Process"/>
        <Class IRI="/Practical_Considerations_Requirements"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Key_Issues"/>
        <Class IRI="/Software_Testing_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Key_Issues_in_Software_Design"/>
        <Class IRI="/Software_Design"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Key_Issues_in_Software_Maintenance"/>
        <Class IRI="/Software_Maintenance"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Knowledge_Area"/>
        <Class IRI="/Software_Engineering"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Language_Recognition"/>
        <Class IRI="/Grammars"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Legal_Issues"/>
        <Class IRI="/Professionalism"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Levels_of_Abstraction"/>
        <Class IRI="/Abstraction"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Levels_of_Measurement"/>
        <Class IRI="/Measurement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Life_Cycle_Economics"/>
        <Class IRI="/Software_Engineering_Economics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Localization_and_Internationalization"/>
        <Class IRI="/User_Interface_Design"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Low_Level_Programming_Languages"/>
        <Class IRI="/Programming_Language_Basics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Main_Issues_in_Distributed_Computing"/>
        <Class IRI="/Parallel_and_Distributed_Computing"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Maintenance_Activities"/>
        <Class IRI="/Maintenance_Process"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Maintenance_Cost_Estimation"/>
        <Class IRI="/Key_Issues_in_Software_Maintenance"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Maintenance_Process"/>
        <Class IRI="/Software_Maintenance"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Maintenance_Processes"/>
        <Class IRI="/Maintenance_Process"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Majority_of_Maintenance_Costs"/>
        <Class IRI="/Software_Maintenance_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Management_Issues"/>
        <Class IRI="/Key_Issues_in_Software_Maintenance"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Management_of_the_SCM_Process"/>
        <Class IRI="/Software_Configuration_Management"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Managing_Construction"/>
        <Class IRI="/Software_Construction"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Mathematical_Foundations"/>
        <Class IRI="/Knowledge_Area"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Mathematical_Foundations"/>
        <ObjectSomeValuesFrom>
            <ObjectProperty IRI="/isKnowledgeAreaOf"/>
            <Class IRI="/Core_Basic_Content"/>
        </ObjectSomeValuesFrom>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Measurement"/>
        <Class IRI="/Engineering_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Measures"/>
        <Class IRI="/Software_Design_Quality_Analysis_and_Evaluation"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Measuring_Requirements"/>
        <Class IRI="/Practical_Considerations_Requirements"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Memory_System_Organization"/>
        <Class IRI="/Computer_Organization"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Metaphors_and_Conceptual_Models"/>
        <Class IRI="/User_Interface_Design"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Methods_of_Proving_Theorems"/>
        <Class IRI="/Proof_Techniques"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Middleware"/>
        <Class IRI="/Construction_Technologies"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Migration"/>
        <Class IRI="/Techniques_for_Maintenance"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Minimizing_Complexity"/>
        <Class IRI="/Software_Construction_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Minimum_Acceptable_Rate_of_Return"/>
        <Class IRI="/Economic_Analysis_Methods"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Mobility_and_Exchange_Activities"/>
        <Class IRI="/Free_Module_and_Complementary_and_Extension_Activities"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Model_Based_Testing_Techniques"/>
        <Class IRI="/Test_Techniques"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Model_Validation"/>
        <Class IRI="/Requirements_Validation"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Modeling"/>
        <Class IRI="/Software_Engineering_Models_and_Methods"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Modeling_Engineering"/>
        <Class IRI="/Modeling_Simulation_and_Prototyping"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Modeling_Principles"/>
        <Class IRI="/Modeling"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Modeling_Simulation_and_Prototyping"/>
        <Class IRI="/Engineering_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Models_and_Quality_Characteristics"/>
        <Class IRI="/Software_Quality_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Monitor_Process"/>
        <Class IRI="/Software_Project_Enactment"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Multidisciplinary"/>
        <Class IRI="/Curriculum"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Multiple_Attribute_Evaluation"/>
        <Class IRI="/Economic_Analysis_Methods"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Nature_and_Role_of_Professional_Societies"/>
        <Class IRI="/Professionalism"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Nature_and_Role_of_Software_Engineering_Standards"/>
        <Class IRI="/Professionalism"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Nature_of_Maintenance"/>
        <Class IRI="/Software_Maintenance_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Need_for_Maintenance"/>
        <Class IRI="/Software_Maintenance_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Network_Communication_Basics"/>
        <Class IRI="/Computing_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Networking_Protocols_and_Standards"/>
        <Class IRI="/Network_Communication_Basics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Number_Theory"/>
        <Class IRI="/Mathematical_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Numerical_Precision_Accuracy_and_Errors"/>
        <Class IRI="/Mathematical_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Object_Oriented_Design"/>
        <Class IRI="/Software_Design_Strategies_and_Methods"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Object_Oriented_Runtime_Issues"/>
        <Class IRI="/Construction_Technologies"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Objectives_of_Testing"/>
        <Class IRI="/Test_Levels"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Observational_Study"/>
        <Class IRI="/Empirical_Methods_and_Experimental_Techniques"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Offshoring_and_Outsourcing"/>
        <Class IRI="/Practical_Considerations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Operating_System_Abstractions"/>
        <Class IRI="/Operating_Systems_Basics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Operating_Systems_Basics"/>
        <Class IRI="/Computing_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Operating_Systems_Classification"/>
        <Class IRI="/Operating_Systems_Basics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Operating_Systems_Overview"/>
        <Class IRI="/Operating_Systems_Basics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Operations_on_Data_Structures"/>
        <Class IRI="/Data_Structure_and_Representation"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Optimization_Analysis"/>
        <Class IRI="/Economic_Analysis_Methods"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Organizational_Context_for_SCM"/>
        <Class IRI="/Management_of_the_SCM_Process"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Overview_of_Algorithms"/>
        <Class IRI="/Algorithms_and_Complexity"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Overview_of_a_Computer_System"/>
        <Class IRI="/Basic_Concept_of_a_System"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Parallel_and_Distributed_Computing"/>
        <Class IRI="/Computing_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Parallel_and_Distributed_Computing_Models"/>
        <Class IRI="/Parallel_and_Distributed_Computing"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Parallel_and_Distributed_Computing_Overview"/>
        <Class IRI="/Parallel_and_Distributed_Computing"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Parameterization_and_Generics"/>
        <Class IRI="/Construction_Technologies"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Pedagogical_Project"/>
        <Class abbreviatedIRI="owl:Thing"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Perform_the_Measurement_Process"/>
        <Class IRI="/Software_Engineering_Measurement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Performance_Analysis_and_Tuning"/>
        <Class IRI="/Construction_Technologies"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Performance_Measurement"/>
        <Class IRI="/Life_Cycle_Economics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Plan_Management"/>
        <Class IRI="/Software_Project_Planning"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Plan_the_Measurement_Process"/>
        <Class IRI="/Software_Engineering_Measurement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Planning_Horizon"/>
        <Class IRI="/Life_Cycle_Economics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Planning_for_SCM"/>
        <Class IRI="/Management_of_the_SCM_Process"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Platform_Standards"/>
        <Class IRI="/Construction_Technologies"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Portfolio"/>
        <Class IRI="/Life_Cycle_Economics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Practical_Considerations"/>
        <Class IRI="/Software_Engineering_Economics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Practical_Considerations_Construction"/>
        <Class IRI="/Software_Construction"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Practical_Considerations_Process"/>
        <Class IRI="/Software_Life_Cycles"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Practical_Considerations_Quality"/>
        <Class IRI="/Software_Quality"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Practical_Considerations_Requirements"/>
        <Class IRI="/Software_Requirements"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Practical_Considerations_Testing"/>
        <Class IRI="/Test_Process"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Preconditions_Postconditions_and_Invariants"/>
        <Class IRI="/Modeling"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Predicate_Logic"/>
        <Class IRI="/Basic_Logic"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Presentation_Skills"/>
        <Class IRI="/Communication_Skills"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Price_and_Pricing"/>
        <Class IRI="/Life_Cycle_Economics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Prime_Number_GCD"/>
        <Class IRI="/Number_Theory"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Prioritization"/>
        <Class IRI="/Risk_and_Uncertainty"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Problem_Solving_Techniques"/>
        <Class IRI="/Computing_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Problem_Solving_Using_Programs"/>
        <Class IRI="/Problem_Solving_Techniques"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Process_Actors"/>
        <Class IRI="/Requirements_Process"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Process_Models"/>
        <Class IRI="/Requirements_Process"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Process_Planning"/>
        <Class IRI="/Software_Project_Planning"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Process_Quality_and_Improvement"/>
        <Class IRI="/Requirements_Process"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Process_Support_and_Management"/>
        <Class IRI="/Requirements_Process"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Process_for_the_Review_and_Revision_of_Requirements"/>
        <Class IRI="/Initiation_and_Scope_Definition"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Product"/>
        <Class IRI="/Life_Cycle_Economics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Product_Life_Cycle"/>
        <Class IRI="/Life_Cycle_Economics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Product_and_Process_Requirements"/>
        <Class IRI="/Software_Requirements_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Productivity"/>
        <Class IRI="/Software_Engineering_Economics_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Professional_Practice_Activities"/>
        <Class IRI="/Free_Module_and_Complementary_and_Extension_Activities"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Professionalism"/>
        <Class IRI="/Software_Engineering_Professional_Practice"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Profiling_Performance_Analysis_and_Slicing_Tools"/>
        <Class IRI="/Software_Construction_Tools"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Program"/>
        <Class IRI="/Life_Cycle_Economics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Program_Comprehension"/>
        <Class IRI="/Techniques_for_Maintenance"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Programming_Fundamentals"/>
        <Class IRI="/Computing_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Programming_Language_Basics"/>
        <Class IRI="/Computing_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Programming_Language_Overview"/>
        <Class IRI="/Programming_Language_Basics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Programming_Paradigms"/>
        <Class IRI="/Programming_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Project"/>
        <Class IRI="/Life_Cycle_Economics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Project_Life_Cycle"/>
        <Class IRI="/Life_Cycle_Economics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Proof_Techniques"/>
        <Class IRI="/Mathematical_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Properties_and_Expression_of_Models"/>
        <Class IRI="/Modeling"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Properties_of_Set"/>
        <Class IRI="/Set_Relations_Functions"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Proposals"/>
        <Class IRI="/Life_Cycle_Economics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Propositional_Logic"/>
        <Class IRI="/Basic_Logic"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Prototyping"/>
        <Class IRI="/Requirements_Validation"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Prototyping_Engineering"/>
        <Class IRI="/Modeling_Simulation_and_Prototyping"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Prototyping_Methods"/>
        <Class IRI="/Software_Engineering_Methods"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Quality_Analysis_and_Evaluation_Techniques"/>
        <Class IRI="/Software_Design_Quality_Analysis_and_Evaluation"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Quality_Attributes"/>
        <Class IRI="/Software_Design_Quality_Analysis_and_Evaluation"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Quality_Management"/>
        <Class IRI="/Software_Project_Planning"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Quality_of_Measurement_Results"/>
        <Class IRI="/Software_Measurement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Quantifiable_Requirements"/>
        <Class IRI="/Software_Requirements_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Reading_Understanding_and_Summarizing"/>
        <Class IRI="/Communication_Skills"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Reengineering"/>
        <Class IRI="/Techniques_for_Maintenance"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Relation_and_Function"/>
        <Class IRI="/Set_Relations_Functions"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Relationship_of_Testing_to_Other_Activities"/>
        <Class IRI="/Software_Testing_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Reliability_and_Validity"/>
        <Class IRI="/Measurement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Replacement_and_Retirement_Decisions"/>
        <Class IRI="/Life_Cycle_Economics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Reporting"/>
        <Class IRI="/Software_Project_Enactment"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Requesting_Evaluating_and_Approving_Software_Changes"/>
        <Class IRI="/Software_Configuration_Control"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Requirements_Analysis"/>
        <Class IRI="/Software_Requirements"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Requirements_Attributes"/>
        <Class IRI="/Practical_Considerations_Requirements"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Requirements_Classification"/>
        <Class IRI="/Requirements_Analysis"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Requirements_Elicitation"/>
        <Class IRI="/Software_Requirements"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Requirements_Negotiation"/>
        <Class IRI="/Requirements_Analysis"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Requirements_Process"/>
        <Class IRI="/Software_Requirements"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Requirements_Reviews"/>
        <Class IRI="/Requirements_Validation"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Requirements_Sources"/>
        <Class IRI="/Requirements_Elicitation"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Requirements_Specification"/>
        <Class IRI="/Software_Requirements"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Requirements_Tracing"/>
        <Class IRI="/Practical_Considerations_Requirements"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Requirements_Validation"/>
        <Class IRI="/Software_Requirements"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Research_Activities"/>
        <Class IRI="/Free_Module_and_Complementary_and_Extension_Activities"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Resource_Allocation"/>
        <Class IRI="/Software_Project_Planning"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Retirement"/>
        <Class IRI="/Techniques_for_Maintenance"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Retrospective_Study"/>
        <Class IRI="/Empirical_Methods_and_Experimental_Techniques"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Return_on_Capital_Employed"/>
        <Class IRI="/Economic_Analysis_Methods"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Return_on_Investment"/>
        <Class IRI="/Economic_Analysis_Methods"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Reuse"/>
        <Class IRI="/Software_Construction_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Reverse_Engineering"/>
        <Class IRI="/Techniques_for_Maintenance"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Review_and_Evaluation"/>
        <Class IRI="/Software_Engineering_Management"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Reviewing_and_Evaluating_Performance"/>
        <Class IRI="/Review_and_Evaluation"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Reviews_and_Audits"/>
        <Class IRI="/Software_Quality_Management_Processes"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Rings"/>
        <Class IRI="/Algebraic_Structures"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Risk_Management"/>
        <Class IRI="/Software_Project_Planning"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Risk_and_Uncertainty"/>
        <Class IRI="/Software_Engineering_Economics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Root_Cause_Analysis"/>
        <Class IRI="/Engineering_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Runtime_Configuration_and_Internationalization"/>
        <Class IRI="/Construction_Technologies"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/SCM_Plan"/>
        <Class IRI="/Management_of_the_SCM_Process"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Secure_Software_Development_and_Maintenance"/>
        <Class IRI="/Computing_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Security"/>
        <Class IRI="/Key_Issues_in_Software_Design"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Selecting_and_Combining_Techniques"/>
        <Class IRI="/Test_Techniques"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Set_Operations"/>
        <Class IRI="/Set_Relations_Functions"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Set_Relations_Functions"/>
        <Class IRI="/Mathematical_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Simulation_Engineering"/>
        <Class IRI="/Modeling_Simulation_and_Prototyping"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Acquisition_and_Supplier_Contract_Management"/>
        <Class IRI="/Software_Project_Enactment"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Building"/>
        <Class IRI="/Software_Release_Management_and_Delivery"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Configuration_Auditing"/>
        <Class IRI="/Software_Configuration_Management"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Configuration_Control"/>
        <Class IRI="/Software_Configuration_Management"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Configuration_Identification"/>
        <Class IRI="/Software_Configuration_Management"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Configuration_Management"/>
        <Class IRI="/Knowledge_Area"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Configuration_Management"/>
        <ObjectSomeValuesFrom>
            <ObjectProperty IRI="/isKnowledgeAreaOf"/>
            <Class IRI="/Core_Specific_Content"/>
        </ObjectSomeValuesFrom>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Configuration_Management_Tools"/>
        <Class IRI="/Software_Configuration_Management"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Configuration_Status_Accounting"/>
        <Class IRI="/Software_Configuration_Management"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Configuration_Status_Information"/>
        <Class IRI="/Software_Configuration_Status_Accounting"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Configuration_Status_Reporting"/>
        <Class IRI="/Software_Configuration_Status_Accounting"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Construction"/>
        <Class IRI="/Knowledge_Area"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Construction"/>
        <ObjectSomeValuesFrom>
            <ObjectProperty IRI="/isKnowledgeAreaOf"/>
            <Class IRI="/Core_Professional_Content"/>
        </ObjectSomeValuesFrom>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Construction_Fundamentals"/>
        <Class IRI="/Software_Construction"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Construction_Security"/>
        <Class IRI="/Secure_Software_Development_and_Maintenance"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Construction_Tools"/>
        <Class IRI="/Software_Construction"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Design"/>
        <Class IRI="/Knowledge_Area"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Design"/>
        <ObjectSomeValuesFrom>
            <ObjectProperty IRI="/isKnowledgeAreaOf"/>
            <Class IRI="/Core_Specific_Content"/>
        </ObjectSomeValuesFrom>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Design_Fundamentals"/>
        <Class IRI="/Software_Design"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Design_Notations"/>
        <Class IRI="/Software_Design"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Design_Principles"/>
        <Class IRI="/Software_Design_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Design_Process"/>
        <Class IRI="/Software_Design_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Design_Quality_Analysis_and_Evaluation"/>
        <Class IRI="/Software_Design"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Design_Security"/>
        <Class IRI="/Secure_Software_Development_and_Maintenance"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Design_Strategies_and_Methods"/>
        <Class IRI="/Software_Design"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Design_Tools"/>
        <Class IRI="/Software_Design"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Engineering"/>
        <Class abbreviatedIRI="owl:Thing"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Engineering_Culture_and_Ethics"/>
        <Class IRI="/Software_Quality_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Engineering_Economics"/>
        <Class IRI="/Knowledge_Area"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Engineering_Economics"/>
        <ObjectSomeValuesFrom>
            <ObjectProperty IRI="/isKnowledgeAreaOf"/>
            <Class IRI="/Core_Basic_Content"/>
        </ObjectSomeValuesFrom>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Engineering_Economics_Fundamentals"/>
        <Class IRI="/Software_Engineering_Economics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Engineering_Management"/>
        <Class IRI="/Knowledge_Area"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Engineering_Management"/>
        <ObjectSomeValuesFrom>
            <ObjectProperty IRI="/isKnowledgeAreaOf"/>
            <Class IRI="/Core_Specific_Content"/>
        </ObjectSomeValuesFrom>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Engineering_Management_Tools"/>
        <Class IRI="/Software_Engineering_Management"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Engineering_Measurement"/>
        <Class IRI="/Software_Engineering_Management"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Engineering_Methods"/>
        <Class IRI="/Software_Engineering_Models_and_Methods"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Engineering_Models_and_Methods"/>
        <Class IRI="/Knowledge_Area"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Engineering_Models_and_Methods"/>
        <ObjectSomeValuesFrom>
            <ObjectProperty IRI="/isKnowledgeAreaOf"/>
            <Class IRI="/Core_Specific_Content"/>
        </ObjectSomeValuesFrom>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Engineering_Process"/>
        <Class IRI="/Knowledge_Area"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Engineering_Process"/>
        <ObjectSomeValuesFrom>
            <ObjectProperty IRI="/isKnowledgeAreaOf"/>
            <Class IRI="/Core_Specific_Content"/>
        </ObjectSomeValuesFrom>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Engineering_Process_Tools"/>
        <Class IRI="/Software_Engineering_Process"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Engineering_Professional_Practice"/>
        <Class IRI="/Knowledge_Area"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Engineering_Professional_Practice"/>
        <ObjectSomeValuesFrom>
            <ObjectProperty IRI="/isKnowledgeAreaOf"/>
            <Class IRI="/Core_Basic_Content"/>
        </ObjectSomeValuesFrom>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Functional_Configuration_Audit"/>
        <Class IRI="/Software_Configuration_Auditing"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Information_Models"/>
        <Class IRI="/Software_Measurement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Library"/>
        <Class IRI="/Software_Configuration_Identification"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Life_Cycle_Models"/>
        <Class IRI="/Software_Life_Cycles"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Life_Cycles"/>
        <Class IRI="/Software_Engineering_Process"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Maintenance"/>
        <Class IRI="/Knowledge_Area"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Maintenance"/>
        <ObjectSomeValuesFrom>
            <ObjectProperty IRI="/isKnowledgeAreaOf"/>
            <Class IRI="/Core_Professional_Content"/>
        </ObjectSomeValuesFrom>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Maintenance_Fundamentals"/>
        <Class IRI="/Software_Maintenance"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Maintenance_Measurement"/>
        <Class IRI="/Key_Issues_in_Software_Maintenance"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Maintenance_Tools"/>
        <Class IRI="/Software_Maintenance"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Measurement"/>
        <Class IRI="/Software_Engineering_Process"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Physical_Configuration_Audit"/>
        <Class IRI="/Software_Configuration_Auditing"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Process_Adaptation"/>
        <Class IRI="/Software_Life_Cycles"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Process_Assessment_Methods"/>
        <Class IRI="/Software_Process_Assessment_and_Improvement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Process_Assessment_Models"/>
        <Class IRI="/Software_Process_Assessment_and_Improvement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Process_Assessment_and_Improvement"/>
        <Class IRI="/Software_Engineering_Process"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Process_Definition"/>
        <Class IRI="/Software_Engineering_Process"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Process_Improvement_Models"/>
        <Class IRI="/Software_Process_Assessment_and_Improvement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Process_Infrastructure"/>
        <Class IRI="/Software_Process_Definition"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Process_Management"/>
        <Class IRI="/Software_Process_Definition"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Process_Measurement_Techniques"/>
        <Class IRI="/Software_Measurement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Process_and_Product_Measurement"/>
        <Class IRI="/Software_Measurement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Project_Enactment"/>
        <Class IRI="/Software_Engineering_Management"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Project_Planning"/>
        <Class IRI="/Software_Engineering_Management"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Quality"/>
        <Class IRI="/Knowledge_Area"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Quality"/>
        <ObjectSomeValuesFrom>
            <ObjectProperty IRI="/isKnowledgeAreaOf"/>
            <Class IRI="/Core_Specific_Content"/>
        </ObjectSomeValuesFrom>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Quality_Assurance"/>
        <Class IRI="/Software_Quality_Management_Processes"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Quality_Fundamentals"/>
        <Class IRI="/Software_Quality"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Quality_Improvement"/>
        <Class IRI="/Software_Quality_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Quality_Management_Processes"/>
        <Class IRI="/Software_Quality"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Quality_Management_Techniques"/>
        <Class IRI="/Practical_Considerations_Quality"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Quality_Measurement"/>
        <Class IRI="/Practical_Considerations_Quality"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Quality_Requirements"/>
        <Class IRI="/Practical_Considerations_Quality"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Quality_Tools"/>
        <Class IRI="/Software_Quality"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Release_Management"/>
        <Class IRI="/Software_Release_Management_and_Delivery"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Release_Management_and_Delivery"/>
        <Class IRI="/Software_Configuration_Management"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Requirements"/>
        <Class IRI="/Knowledge_Area"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Requirements"/>
        <ObjectSomeValuesFrom>
            <ObjectProperty IRI="/isKnowledgeAreaOf"/>
            <Class IRI="/Core_Specific_Content"/>
        </ObjectSomeValuesFrom>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Requirements_Fundamentals"/>
        <Class IRI="/Software_Requirements"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Requirements_Security"/>
        <Class IRI="/Secure_Software_Development_and_Maintenance"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Requirements_Specification"/>
        <Class IRI="/Requirements_Specification"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Requirements_Tools"/>
        <Class IRI="/Software_Requirements"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Robustness"/>
        <Class IRI="/Basic_User_Human_Factors"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Safety"/>
        <Class IRI="/Software_Quality_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Security_Guidelines"/>
        <Class IRI="/Secure_Software_Development_and_Maintenance"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Structure_and_Architecture"/>
        <Class IRI="/Software_Design"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Testing"/>
        <Class IRI="/Knowledge_Area"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Testing"/>
        <ObjectSomeValuesFrom>
            <ObjectProperty IRI="/isKnowledgeAreaOf"/>
            <Class IRI="/Core_Professional_Content"/>
        </ObjectSomeValuesFrom>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Testing_Fundamentals"/>
        <Class IRI="/Software_Testing"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Testing_Security"/>
        <Class IRI="/Secure_Software_Development_and_Maintenance"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Software_Testing_Tools"/>
        <Class IRI="/Software_Testing"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Standards"/>
        <Class IRI="/Engineering_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Standards_in_Construction"/>
        <Class IRI="/Software_Construction_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/State_Based_and_Table_Driven_Construction_Techniques"/>
        <Class IRI="/Construction_Technologies"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Statistical_Analysis"/>
        <Class IRI="/Engineering_Foundations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Steps_Involved_in_Engineering_Design"/>
        <Class IRI="/Engineering_Design"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Structural_Descriptions_Static_View"/>
        <Class IRI="/Software_Design_Notations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Structure"/>
        <Class IRI="/Basic_Developer_Human_Factors"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Structure_Modeling"/>
        <Class IRI="/Types_of_Models"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Supervised_internship"/>
        <Class IRI="/Multidisciplinary"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Surveillance_of_Software_Configuration_Management"/>
        <Class IRI="/Management_of_the_SCM_Process"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Syntax_Semantics_and_Pragmatics"/>
        <Class IRI="/Modeling"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Syntax_and_Semantics_of_Programming_Languages"/>
        <Class IRI="/Programming_Language_Basics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/System_Definition_Document"/>
        <Class IRI="/Requirements_Specification"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/System_Requirements_Specification"/>
        <Class IRI="/Requirements_Specification"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/System_Requirements_and_Software_Requirements"/>
        <Class IRI="/Software_Requirements_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Systems_Engineering"/>
        <Class IRI="/Basic_Concept_of_a_System"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Tasks_of_DBMS_Packages"/>
        <Class IRI="/Database_Basics_and_Data_Management"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Tasks_of_an_Operating_System"/>
        <Class IRI="/Operating_Systems_Basics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Taxation"/>
        <Class IRI="/Software_Engineering_Economics_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Teaching_Activities"/>
        <Class IRI="/Free_Module_and_Complementary_and_Extension_Activities"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Team_and_Group_Communication"/>
        <Class IRI="/Communication_Skills"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Technical_Issues"/>
        <Class IRI="/Key_Issues_in_Software_Maintenance"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Techniques_Based_on_the_Nature_of_the_Application"/>
        <Class IRI="/Test_Techniques"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Techniques_for_Conducting_Root_Cause_Analysis"/>
        <Class IRI="/Root_Cause_Analysis"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Techniques_for_Maintenance"/>
        <Class IRI="/Software_Maintenance"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Termination_Decisions"/>
        <Class IRI="/Life_Cycle_Economics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Test_Activities"/>
        <Class IRI="/Test_Process"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Test_First_Programming"/>
        <Class IRI="/Construction_Technologies"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Test_Levels"/>
        <Class IRI="/Software_Testing"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Test_Process"/>
        <Class IRI="/Software_Testing"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Test_Related_Measures"/>
        <Class IRI="/Software_Testing"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Test_Techniques"/>
        <Class IRI="/Software_Testing"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Testing_Related_Terminology"/>
        <Class IRI="/Software_Testing_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Testing_Tool_Support"/>
        <Class IRI="/Software_Testing_Tools"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/The_Central_Processing_Unit"/>
        <Class IRI="/Computer_Organization"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/The_Compilation_Process"/>
        <Class IRI="/Compiler_Basics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/The_Design_of_Information_Presentation"/>
        <Class IRI="/User_Interface_Design"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/The_Design_of_User_Interaction_Modalities"/>
        <Class IRI="/User_Interface_Design"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/The_Good_Enough_Principle"/>
        <Class IRI="/Practical_Considerations"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/The_Internet"/>
        <Class IRI="/Network_Communication_Basics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/The_Programming_Process"/>
        <Class IRI="/Programming_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/The_Target_of_the_Test"/>
        <Class IRI="/Test_Levels"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Time_Value_of_Money"/>
        <Class IRI="/Software_Engineering_Economics_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Traceability"/>
        <Class IRI="/Analysis_of_Models"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Tradeoff_Analysis"/>
        <Class IRI="/Professionalism"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Trees"/>
        <Class IRI="/Graphs_and_Trees"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Types_of_Data_Structure"/>
        <Class IRI="/Data_Structure_and_Representation"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Types_of_Errors"/>
        <Class IRI="/Debugging_Tools_and_Techniques"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Types_of_Models"/>
        <Class IRI="/Software_Engineering_Models_and_Methods"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Types_of_Network"/>
        <Class IRI="/Network_Communication_Basics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Unit_Testing_Tools"/>
        <Class IRI="/Software_Construction_Tools"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Unit_of_Analysis_Population_and_Sample"/>
        <Class IRI="/Statistical_Analysis"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Usage_Based_Techniques"/>
        <Class IRI="/Test_Techniques"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/User_Input_and_Output"/>
        <Class IRI="/Basic_User_Human_Factors"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/User_Interface_Design"/>
        <Class IRI="/Software_Design"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/User_Interface_Design_Issues"/>
        <Class IRI="/User_Interface_Design"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/User_Interface_Design_Process"/>
        <Class IRI="/User_Interface_Design"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Valuation"/>
        <Class IRI="/Software_Engineering_Economics_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Value_and_Costs_of_Quality"/>
        <Class IRI="/Software_Quality_Fundamentals"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Verification_e_Validation"/>
        <Class IRI="/Software_Quality_Management_Processes"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Virtual_Private_Network"/>
        <Class IRI="/Network_Communication_Basics"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="/Writing"/>
        <Class IRI="/Communication_Skills"/>
    </SubClassOf>
    <DisjointClasses>
        <Class IRI="/API_Design_and_Use"/>
        <Class IRI="/Assertions_Design_by_Contract_and_Defensive_Programming"/>
        <Class IRI="/Concurrency_Primitives"/>
        <Class IRI="/Constructing_Heterogeneous_Systems"/>
        <Class IRI="/Construction_Methods_for_Distributed_Software"/>
        <Class IRI="/Error_Handling_Exception_Handling_and_Fault_Tolerance"/>
        <Class IRI="/Executable_Models"/>
        <Class IRI="/Grammar_Based_Input_Processing"/>
        <Class IRI="/Middleware"/>
        <Class IRI="/Object_Oriented_Runtime_Issues"/>
        <Class IRI="/Parameterization_and_Generics"/>
        <Class IRI="/Performance_Analysis_and_Tuning"/>
        <Class IRI="/Platform_Standards"/>
        <Class IRI="/Runtime_Configuration_and_Internationalization"/>
        <Class IRI="/State_Based_and_Table_Driven_Construction_Techniques"/>
        <Class IRI="/Test_First_Programming"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Abstraction"/>
        <Class IRI="/Algorithms_and_Complexity"/>
        <Class IRI="/Basic_Concept_of_a_System"/>
        <Class IRI="/Basic_Developer_Human_Factors"/>
        <Class IRI="/Basic_User_Human_Factors"/>
        <Class IRI="/Compiler_Basics"/>
        <Class IRI="/Computer_Organization"/>
        <Class IRI="/Data_Structure_and_Representation"/>
        <Class IRI="/Database_Basics_and_Data_Management"/>
        <Class IRI="/Debugging_Tools_and_Techniques"/>
        <Class IRI="/Network_Communication_Basics"/>
        <Class IRI="/Operating_Systems_Basics"/>
        <Class IRI="/Parallel_and_Distributed_Computing"/>
        <Class IRI="/Problem_Solving_Techniques"/>
        <Class IRI="/Programming_Fundamentals"/>
        <Class IRI="/Programming_Language_Basics"/>
        <Class IRI="/Secure_Software_Development_and_Maintenance"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Acceptance_Tests"/>
        <Class IRI="/Model_Validation"/>
        <Class IRI="/Prototyping"/>
        <Class IRI="/Requirements_Reviews"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Accounting"/>
        <Class IRI="/Cash_Flow"/>
        <Class IRI="/Controlling"/>
        <Class IRI="/Decision_Making_Process"/>
        <Class IRI="/Effectiveness"/>
        <Class IRI="/Efficiency"/>
        <Class IRI="/Finance"/>
        <Class IRI="/Inflation"/>
        <Class IRI="/Productivity"/>
        <Class IRI="/Taxation"/>
        <Class IRI="/Time_Value_of_Money"/>
        <Class IRI="/Valuation"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Accreditation_Certification_and_Licensing"/>
        <Class IRI="/Codes_of_Ethics_and_Professional_Conduct"/>
        <Class IRI="/Documentation"/>
        <Class IRI="/Economic_Impact_of_Software"/>
        <Class IRI="/Employment_Contracts"/>
        <Class IRI="/Legal_Issues"/>
        <Class IRI="/Nature_and_Role_of_Professional_Societies"/>
        <Class IRI="/Nature_and_Role_of_Software_Engineering_Standards"/>
        <Class IRI="/Tradeoff_Analysis"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Addressing_Uncertainty"/>
        <Class IRI="/Decisions_under_Risk"/>
        <Class IRI="/Decisions_under_Uncertainty"/>
        <Class IRI="/Estimation_Techniques"/>
        <Class IRI="/Goals_Estimates_and_Plans"/>
        <Class IRI="/Prioritization"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Agile_Methods"/>
        <Class IRI="/Formal_Methods"/>
        <Class IRI="/Heuristic_Methods"/>
        <Class IRI="/Prototyping_Methods"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Algebraic_Structures"/>
        <Class IRI="/Basic_Logic"/>
        <Class IRI="/Basics_of_Counting"/>
        <Class IRI="/Discrete_Probability"/>
        <Class IRI="/Finite_State_Machines"/>
        <Class IRI="/Grammars"/>
        <Class IRI="/Graphs_and_Trees"/>
        <Class IRI="/Number_Theory"/>
        <Class IRI="/Numerical_Precision_Accuracy_and_Errors"/>
        <Class IRI="/Proof_Techniques"/>
        <Class IRI="/Set_Relations_Functions"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Algorithmic_Analysis"/>
        <Class IRI="/Algorithmic_Analysis_Strategies"/>
        <Class IRI="/Algorithmic_Design_Strategies"/>
        <Class IRI="/Attributes_of_Algorithms"/>
        <Class IRI="/Overview_of_Algorithms"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Alternate_Abstractions"/>
        <Class IRI="/Encapsulation"/>
        <Class IRI="/Hierarchy"/>
        <Class IRI="/Levels_of_Abstraction"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Analysis_of_Models"/>
        <Class IRI="/Modeling"/>
        <Class IRI="/Software_Engineering_Methods"/>
        <Class IRI="/Types_of_Models"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Analyze_the_Problem"/>
        <Class IRI="/Definition_of_Problem_Solving"/>
        <Class IRI="/Design_a_Solution_Search_Strategy"/>
        <Class IRI="/Formulating_the_Real_Problem"/>
        <Class IRI="/Problem_Solving_Using_Programs"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Analyzing_for_Completeness"/>
        <Class IRI="/Analyzing_for_Consistency"/>
        <Class IRI="/Analyzing_for_Correctness"/>
        <Class IRI="/Interaction_Analysis"/>
        <Class IRI="/Traceability"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Anticipating_Change"/>
        <Class IRI="/Constructing_for_Verification"/>
        <Class IRI="/Minimizing_Complexity"/>
        <Class IRI="/Reuse"/>
        <Class IRI="/Standards_in_Construction"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Architectural_Design_and_Requirements_Allocation"/>
        <Class IRI="/Conceptual_Modeling"/>
        <Class IRI="/Formal_Analysis"/>
        <Class IRI="/Requirements_Classification"/>
        <Class IRI="/Requirements_Negotiation"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Architectural_Structures_and_Viewpoints"/>
        <Class IRI="/Architectural_Styles"/>
        <Class IRI="/Architecture_Design_Decisions"/>
        <Class IRI="/Design_Patterns"/>
        <Class IRI="/Families_of_Programs_and_Frameworks"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Assessing_Reliability"/>
        <Class IRI="/Direct_and_Derived_Measures"/>
        <Class IRI="/Levels_of_Measurement"/>
        <Class IRI="/Reliability_and_Validity"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Based_on_the_Software_Engineers_Intuition_and_Experience"/>
        <Class IRI="/Code_Based_Techniques"/>
        <Class IRI="/Fault_Based_Techniques"/>
        <Class IRI="/Input_Domain_Based_Techniques"/>
        <Class IRI="/Model_Based_Testing_Techniques"/>
        <Class IRI="/Selecting_and_Combining_Techniques"/>
        <Class IRI="/Techniques_Based_on_the_Nature_of_the_Application"/>
        <Class IRI="/Usage_Based_Techniques"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Basic_Network_Components"/>
        <Class IRI="/Internet_of_Things"/>
        <Class IRI="/Networking_Protocols_and_Standards"/>
        <Class IRI="/The_Internet"/>
        <Class IRI="/Types_of_Network"/>
        <Class IRI="/Virtual_Private_Network"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Behavioral_Descriptions_Dynamic_View"/>
        <Class IRI="/Structural_Descriptions_Static_View"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Behavioral_Modeling"/>
        <Class IRI="/Information_Modeling"/>
        <Class IRI="/Structure_Modeling"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Break_Even_Analysis"/>
        <Class IRI="/Business_Case"/>
        <Class IRI="/Cost_Benefit_Analysis"/>
        <Class IRI="/Cost_Effectiveness_Analysis"/>
        <Class IRI="/For_Profit_Decision_Analysis"/>
        <Class IRI="/Minimum_Acceptable_Rate_of_Return"/>
        <Class IRI="/Multiple_Attribute_Evaluation"/>
        <Class IRI="/Optimization_Analysis"/>
        <Class IRI="/Return_on_Capital_Employed"/>
        <Class IRI="/Return_on_Investment"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Build_Security_into_Software_Engineering_Process"/>
        <Class IRI="/Software_Construction_Security"/>
        <Class IRI="/Software_Design_Security"/>
        <Class IRI="/Software_Requirements_Security"/>
        <Class IRI="/Software_Security_Guidelines"/>
        <Class IRI="/Software_Testing_Security"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Categories_of_Maintenance"/>
        <Class IRI="/Definitions_and_Terminology"/>
        <Class IRI="/Evolution_of_Software"/>
        <Class IRI="/Majority_of_Maintenance_Costs"/>
        <Class IRI="/Nature_of_Maintenance"/>
        <Class IRI="/Need_for_Maintenance"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Categories_of_Software_Processes"/>
        <Class IRI="/Practical_Considerations_Process"/>
        <Class IRI="/Software_Life_Cycle_Models"/>
        <Class IRI="/Software_Process_Adaptation"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Categories_of_Tools"/>
        <Class IRI="/Testing_Tool_Support"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Change_Management"/>
        <Class IRI="/Iterative_Nature_of_the_Requirements_Process"/>
        <Class IRI="/Measuring_Requirements"/>
        <Class IRI="/Requirements_Attributes"/>
        <Class IRI="/Requirements_Tracing"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Closure"/>
        <Class IRI="/Initiation_and_Scope_Definition"/>
        <Class IRI="/Review_and_Evaluation"/>
        <Class IRI="/Software_Engineering_Management_Tools"/>
        <Class IRI="/Software_Engineering_Measurement"/>
        <Class IRI="/Software_Project_Enactment"/>
        <Class IRI="/Software_Project_Planning"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Closure_Activities"/>
        <Class IRI="/Determining_Closure"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Coding"/>
        <Class IRI="/Construction_Design"/>
        <Class IRI="/Construction_Languages"/>
        <Class IRI="/Construction_Quality"/>
        <Class IRI="/Construction_Testing"/>
        <Class IRI="/Construction_for_Reuse"/>
        <Class IRI="/Construction_with_Reuse"/>
        <Class IRI="/Integration"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Comments"/>
        <Class IRI="/Structure"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Communication_Skills"/>
        <Class IRI="/Group_Dynamics_and_Psychology"/>
        <Class IRI="/Professionalism"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Compiler_or_Interpreter_Overview"/>
        <Class IRI="/Interpretation_and_Compilation"/>
        <Class IRI="/The_Compilation_Process"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Component_Based_Design"/>
        <Class IRI="/Data_Structure_Centered_Design"/>
        <Class IRI="/Function_Oriented_Structured_Design"/>
        <Class IRI="/General_Strategies"/>
        <Class IRI="/Object_Oriented_Design"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Computer_Expression_of_Data"/>
        <Class IRI="/Computer_Organization_Overview"/>
        <Class IRI="/Digital_Logic"/>
        <Class IRI="/Digital_Systems"/>
        <Class IRI="/Input_and_Output"/>
        <Class IRI="/Memory_System_Organization"/>
        <Class IRI="/The_Central_Processing_Unit"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Computing_Foundations"/>
        <Class IRI="/Engineering_Foundations"/>
        <Class IRI="/Mathematical_Foundations"/>
        <Class IRI="/Software_Configuration_Management"/>
        <Class IRI="/Software_Construction"/>
        <Class IRI="/Software_Design"/>
        <Class IRI="/Software_Engineering_Economics"/>
        <Class IRI="/Software_Engineering_Management"/>
        <Class IRI="/Software_Engineering_Models_and_Methods"/>
        <Class IRI="/Software_Engineering_Process"/>
        <Class IRI="/Software_Engineering_Professional_Practice"/>
        <Class IRI="/Software_Maintenance"/>
        <Class IRI="/Software_Quality"/>
        <Class IRI="/Software_Requirements"/>
        <Class IRI="/Software_Testing"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Concepts_of_Correlation_and_Regression"/>
        <Class IRI="/Unit_of_Analysis_Population_and_Sample"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Concurrency"/>
        <Class IRI="/Control_and_Handling_of_Events"/>
        <Class IRI="/Data_Persistence"/>
        <Class IRI="/Distribution_of_Components"/>
        <Class IRI="/Error_and_Exception_Handling_and_Fault_Tolerance"/>
        <Class IRI="/Interaction_and_Presentation"/>
        <Class IRI="/Security"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Constraints_and_Guidance_for_the_SCM_Process"/>
        <Class IRI="/Organizational_Context_for_SCM"/>
        <Class IRI="/Planning_for_SCM"/>
        <Class IRI="/SCM_Plan"/>
        <Class IRI="/Surveillance_of_Software_Configuration_Management"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Construction_Measurement"/>
        <Class IRI="/Construction_Planning"/>
        <Class IRI="/Construction_in_Life_Cycle_Models"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Construction_Technologies"/>
        <Class IRI="/Managing_Construction"/>
        <Class IRI="/Practical_Considerations_Construction"/>
        <Class IRI="/Software_Construction_Fundamentals"/>
        <Class IRI="/Software_Construction_Tools"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Context_of_Software_Design"/>
        <Class IRI="/General_Design_Concepts"/>
        <Class IRI="/Software_Design_Principles"/>
        <Class IRI="/Software_Design_Process"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Continuous_and_Staged_Software_Process_Ratings"/>
        <Class IRI="/Software_Process_Assessment_Methods"/>
        <Class IRI="/Software_Process_Assessment_Models"/>
        <Class IRI="/Software_Process_Improvement_Models"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Control_Process"/>
        <Class IRI="/Implementation_of_Measurement_Process"/>
        <Class IRI="/Implementation_of_Plans"/>
        <Class IRI="/Monitor_Process"/>
        <Class IRI="/Reporting"/>
        <Class IRI="/Software_Acquisition_and_Supplier_Contract_Management"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Cost_and_Costing"/>
        <Class IRI="/Earned_Value_Management"/>
        <Class IRI="/Investment_Decisions"/>
        <Class IRI="/Performance_Measurement"/>
        <Class IRI="/Planning_Horizon"/>
        <Class IRI="/Portfolio"/>
        <Class IRI="/Price_and_Pricing"/>
        <Class IRI="/Product"/>
        <Class IRI="/Product_Life_Cycle"/>
        <Class IRI="/Program"/>
        <Class IRI="/Project"/>
        <Class IRI="/Project_Life_Cycle"/>
        <Class IRI="/Proposals"/>
        <Class IRI="/Replacement_and_Retirement_Decisions"/>
        <Class IRI="/Termination_Decisions"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Data_Management"/>
        <Class IRI="/Data_Mining"/>
        <Class IRI="/Database_Management_Systems"/>
        <Class IRI="/Database_Query_Language"/>
        <Class IRI="/Entity_and_Schema"/>
        <Class IRI="/Tasks_of_DBMS_Packages"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Data_Structure_Overview"/>
        <Class IRI="/Operations_on_Data_Structures"/>
        <Class IRI="/Types_of_Data_Structure"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Dealing_with_Multicultural_Environments"/>
        <Class IRI="/Dealing_with_Problem_Complexity"/>
        <Class IRI="/Dealing_with_Uncertainty_and_Ambiguity"/>
        <Class IRI="/Dynamics_of_Working_in_Teams_Groups"/>
        <Class IRI="/Individual_Cognition"/>
        <Class IRI="/Interacting_with_Stakeholders"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Debugging_Techniques"/>
        <Class IRI="/Debugging_Tools"/>
        <Class IRI="/Types_of_Errors"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Declarative_vs_Imperative_Programming_Languages"/>
        <Class IRI="/High_Level_Programming_Languages"/>
        <Class IRI="/Low_Level_Programming_Languages"/>
        <Class IRI="/Programming_Language_Overview"/>
        <Class IRI="/Syntax_and_Semantics_of_Programming_Languages"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Defect_Characterization"/>
        <Class IRI="/Software_Quality_Management_Techniques"/>
        <Class IRI="/Software_Quality_Measurement"/>
        <Class IRI="/Software_Quality_Requirements"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Definition_of_a_Software_Requirement"/>
        <Class IRI="/Emergent_Properties"/>
        <Class IRI="/Functional_and_Nonfunctional_Requirements"/>
        <Class IRI="/Product_and_Process_Requirements"/>
        <Class IRI="/Quantifiable_Requirements"/>
        <Class IRI="/System_Requirements_and_Software_Requirements"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Design_as_a_Problem_Solving_Activity"/>
        <Class IRI="/Engineering_Design_in_Engineering_Education"/>
        <Class IRI="/Steps_Involved_in_Engineering_Design"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Designed_Experiment"/>
        <Class IRI="/Observational_Study"/>
        <Class IRI="/Retrospective_Study"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Determination_and_Negotiation_of_Requirements"/>
        <Class IRI="/Feasibility_Analysis"/>
        <Class IRI="/Process_for_the_Review_and_Revision_of_Requirements"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Determine_Deliverables"/>
        <Class IRI="/Effort_Schedule_and_Cost_Estimation"/>
        <Class IRI="/Plan_Management"/>
        <Class IRI="/Process_Planning"/>
        <Class IRI="/Quality_Management"/>
        <Class IRI="/Resource_Allocation"/>
        <Class IRI="/Risk_Management"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Determining_Satisfaction_of_Requirements"/>
        <Class IRI="/Reviewing_and_Evaluating_Performance"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Development_Environments"/>
        <Class IRI="/GUI_Builders"/>
        <Class IRI="/Profiling_Performance_Analysis_and_Slicing_Tools"/>
        <Class IRI="/Unit_Testing_Tools"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Deviations_and_Waivers"/>
        <Class IRI="/Implementing_Software_Changes"/>
        <Class IRI="/Requesting_Evaluating_and_Approving_Software_Changes"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Difference_between_Parallel_and_Distributed_Computing"/>
        <Class IRI="/Main_Issues_in_Distributed_Computing"/>
        <Class IRI="/Parallel_and_Distributed_Computing_Models"/>
        <Class IRI="/Parallel_and_Distributed_Computing_Overview"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Divisibility"/>
        <Class IRI="/Prime_Number_GCD"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Economic_Analysis_Methods"/>
        <Class IRI="/Life_Cycle_Economics"/>
        <Class IRI="/Practical_Considerations"/>
        <Class IRI="/Risk_and_Uncertainty"/>
        <Class IRI="/Software_Engineering_Economics_Fundamentals"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Ecosystems"/>
        <Class IRI="/Friction_Free_Economy"/>
        <Class IRI="/Offshoring_and_Outsourcing"/>
        <Class IRI="/The_Good_Enough_Principle"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Elicitation_Techniques"/>
        <Class IRI="/Requirements_Sources"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Emergent_System_Properties"/>
        <Class IRI="/Overview_of_a_Computer_System"/>
        <Class IRI="/Systems_Engineering"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Empirical_Methods_and_Experimental_Techniques"/>
        <Class IRI="/Engineering_Design"/>
        <Class IRI="/Measurement"/>
        <Class IRI="/Modeling_Simulation_and_Prototyping"/>
        <Class IRI="/Root_Cause_Analysis"/>
        <Class IRI="/Standards"/>
        <Class IRI="/Statistical_Analysis"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Error_Messages"/>
        <Class IRI="/Software_Robustness"/>
        <Class IRI="/User_Input_and_Output"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Establish_and_Sustain_Measurement_Commitment"/>
        <Class IRI="/Evaluate_Measurement"/>
        <Class IRI="/Perform_the_Measurement_Process"/>
        <Class IRI="/Plan_the_Measurement_Process"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Evaluation_of_the_Program_Under_Test"/>
        <Class IRI="/Evaluation_of_the_Tests_Performed"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/General_User_Interface_Design_Principles"/>
        <Class IRI="/Localization_and_Internationalization"/>
        <Class IRI="/Metaphors_and_Conceptual_Models"/>
        <Class IRI="/The_Design_of_Information_Presentation"/>
        <Class IRI="/The_Design_of_User_Interaction_Modalities"/>
        <Class IRI="/User_Interface_Design_Issues"/>
        <Class IRI="/User_Interface_Design_Process"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Graphs"/>
        <Class IRI="/Trees"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Group"/>
        <Class IRI="/Rings"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Identifying_Items_to_Be_Controlled"/>
        <Class IRI="/Software_Library"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/In_Process_Audits_of_a_Software_Baseline"/>
        <Class IRI="/Software_Functional_Configuration_Audit"/>
        <Class IRI="/Software_Physical_Configuration_Audit"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Key_Issues"/>
        <Class IRI="/Relationship_of_Testing_to_Other_Activities"/>
        <Class IRI="/Testing_Related_Terminology"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Key_Issues_in_Software_Design"/>
        <Class IRI="/Software_Design_Fundamentals"/>
        <Class IRI="/Software_Design_Notations"/>
        <Class IRI="/Software_Design_Quality_Analysis_and_Evaluation"/>
        <Class IRI="/Software_Design_Strategies_and_Methods"/>
        <Class IRI="/Software_Design_Tools"/>
        <Class IRI="/Software_Structure_and_Architecture"/>
        <Class IRI="/User_Interface_Design"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Key_Issues_in_Software_Maintenance"/>
        <Class IRI="/Maintenance_Process"/>
        <Class IRI="/Software_Maintenance_Fundamentals"/>
        <Class IRI="/Software_Maintenance_Tools"/>
        <Class IRI="/Techniques_for_Maintenance"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Maintenance_Activities"/>
        <Class IRI="/Maintenance_Processes"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Maintenance_Cost_Estimation"/>
        <Class IRI="/Management_Issues"/>
        <Class IRI="/Software_Maintenance_Measurement"/>
        <Class IRI="/Technical_Issues"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Management_of_the_SCM_Process"/>
        <Class IRI="/Software_Configuration_Auditing"/>
        <Class IRI="/Software_Configuration_Control"/>
        <Class IRI="/Software_Configuration_Identification"/>
        <Class IRI="/Software_Configuration_Management_Tools"/>
        <Class IRI="/Software_Configuration_Status_Accounting"/>
        <Class IRI="/Software_Release_Management_and_Delivery"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Measures"/>
        <Class IRI="/Quality_Analysis_and_Evaluation_Techniques"/>
        <Class IRI="/Quality_Attributes"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Migration"/>
        <Class IRI="/Program_Comprehension"/>
        <Class IRI="/Reengineering"/>
        <Class IRI="/Retirement"/>
        <Class IRI="/Reverse_Engineering"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Modeling_Engineering"/>
        <Class IRI="/Prototyping_Engineering"/>
        <Class IRI="/Simulation_Engineering"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Modeling_Principles"/>
        <Class IRI="/Preconditions_Postconditions_and_Invariants"/>
        <Class IRI="/Properties_and_Expression_of_Models"/>
        <Class IRI="/Syntax_Semantics_and_Pragmatics"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Models_and_Quality_Characteristics"/>
        <Class IRI="/Software_Engineering_Culture_and_Ethics"/>
        <Class IRI="/Software_Quality_Improvement"/>
        <Class IRI="/Software_Safety"/>
        <Class IRI="/Value_and_Costs_of_Quality"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Objectives_of_Testing"/>
        <Class IRI="/The_Target_of_the_Test"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Operating_System_Abstractions"/>
        <Class IRI="/Operating_Systems_Classification"/>
        <Class IRI="/Operating_Systems_Overview"/>
        <Class IRI="/Tasks_of_an_Operating_System"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Pedagogical_Project"/>
        <Class IRI="/Software_Engineering"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Practical_Considerations_Quality"/>
        <Class IRI="/Software_Quality_Fundamentals"/>
        <Class IRI="/Software_Quality_Management_Processes"/>
        <Class IRI="/Software_Quality_Tools"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Practical_Considerations_Requirements"/>
        <Class IRI="/Requirements_Analysis"/>
        <Class IRI="/Requirements_Elicitation"/>
        <Class IRI="/Requirements_Process"/>
        <Class IRI="/Requirements_Specification"/>
        <Class IRI="/Requirements_Validation"/>
        <Class IRI="/Software_Requirements_Fundamentals"/>
        <Class IRI="/Software_Requirements_Tools"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Practical_Considerations_Testing"/>
        <Class IRI="/Test_Activities"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Predicate_Logic"/>
        <Class IRI="/Propositional_Logic"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Presentation_Skills"/>
        <Class IRI="/Reading_Understanding_and_Summarizing"/>
        <Class IRI="/Team_and_Group_Communication"/>
        <Class IRI="/Writing"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Process_Actors"/>
        <Class IRI="/Process_Models"/>
        <Class IRI="/Process_Quality_and_Improvement"/>
        <Class IRI="/Process_Support_and_Management"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Programming_Paradigms"/>
        <Class IRI="/The_Programming_Process"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Properties_of_Set"/>
        <Class IRI="/Relation_and_Function"/>
        <Class IRI="/Set_Operations"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Quality_of_Measurement_Results"/>
        <Class IRI="/Software_Information_Models"/>
        <Class IRI="/Software_Process_Measurement_Techniques"/>
        <Class IRI="/Software_Process_and_Product_Measurement"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Reviews_and_Audits"/>
        <Class IRI="/Software_Quality_Assurance"/>
        <Class IRI="/Verification_e_Validation"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Software_Building"/>
        <Class IRI="/Software_Release_Management"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Software_Configuration_Status_Information"/>
        <Class IRI="/Software_Configuration_Status_Reporting"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Software_Engineering_Process_Tools"/>
        <Class IRI="/Software_Life_Cycles"/>
        <Class IRI="/Software_Measurement"/>
        <Class IRI="/Software_Process_Assessment_and_Improvement"/>
        <Class IRI="/Software_Process_Definition"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Software_Process_Infrastructure"/>
        <Class IRI="/Software_Process_Management"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Software_Requirements_Specification"/>
        <Class IRI="/System_Definition_Document"/>
        <Class IRI="/System_Requirements_Specification"/>
    </DisjointClasses>
    <DisjointClasses>
        <Class IRI="/Software_Testing_Fundamentals"/>
        <Class IRI="/Software_Testing_Tools"/>
        <Class IRI="/Test_Levels"/>
        <Class IRI="/Test_Process"/>
        <Class IRI="/Test_Related_Measures"/>
        <Class IRI="/Test_Techniques"/>
    </DisjointClasses>
    <InverseObjectProperties>
        <ObjectProperty IRI="/hasKnowledgeArea"/>
        <ObjectProperty IRI="/isKnowledgeAreaOf"/>
    </InverseObjectProperties>
    <DisjointObjectProperties>
        <ObjectProperty IRI="/hasKnowledgeArea"/>
        <ObjectProperty IRI="/isKnowledgeAreaOf"/>
    </DisjointObjectProperties>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <AbbreviatedIRI>dc:contributor</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Uma entidade responsável por fazer contribuições para o recurso

Exemplos de um Colaborador incluem uma pessoa, uma organização ou um serviço. Normalmente, o nome de um Colaborador deve ser usado para indicar a entidade.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:isDefinedBy"/>
        <AbbreviatedIRI>dc:contributor</AbbreviatedIRI>
        <AbbreviatedIRI>dc:</AbbreviatedIRI>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:label"/>
        <AbbreviatedIRI>dc:contributor</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Contribuidor</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <AbbreviatedIRI>dc:creator</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Uma entidade principalmente responsável por fazer o recurso.

Exemplos de um Criador incluem uma pessoa, uma organização ou um serviço. Normalmente, o nome de um criador deve ser usado para indicar a entidade.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:isDefinedBy"/>
        <AbbreviatedIRI>dc:creator</AbbreviatedIRI>
        <AbbreviatedIRI>dc:</AbbreviatedIRI>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:label"/>
        <AbbreviatedIRI>dc:creator</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Criador</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <AbbreviatedIRI>dc:date</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Um ponto ou período de tempo associado a um evento no ciclo de vida do recurso.

A data pode ser usada para expressar informações temporais em qualquer nível de granularidade. A melhor prática recomendada é usar um esquema de codificação, como o perfil W3CDTF da ISO 8601 [W3CDTF].</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:isDefinedBy"/>
        <AbbreviatedIRI>dc:date</AbbreviatedIRI>
        <AbbreviatedIRI>dc:</AbbreviatedIRI>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:label"/>
        <AbbreviatedIRI>dc:date</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Data</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <AbbreviatedIRI>dc:description</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Uma descrição do recurso.

A descrição pode incluir, mas não está limitada a: um resumo, um sumário, uma representação gráfica ou um texto livre do recurso.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:isDefinedBy"/>
        <AbbreviatedIRI>dc:description</AbbreviatedIRI>
        <AbbreviatedIRI>dc:</AbbreviatedIRI>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:label"/>
        <AbbreviatedIRI>dc:description</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Descrição</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <AbbreviatedIRI>dc:format</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">O formato de arquivo, meio físico ou dimensões do recurso.

Exemplos de dimensões incluem tamanho e duração. A melhor prática recomendada é usar um vocabulário controlado, como a lista de tipos de mídia da Internet [MIME].</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:isDefinedBy"/>
        <AbbreviatedIRI>dc:format</AbbreviatedIRI>
        <AbbreviatedIRI>dc:</AbbreviatedIRI>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:label"/>
        <AbbreviatedIRI>dc:format</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Formato</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <AbbreviatedIRI>dc:identifier</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Uma referência inequívoca ao recurso dentro de um determinado contexto.

A melhor prática recomendada é identificar o recurso por meio de uma string em conformidade com um sistema de identificação formal.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:isDefinedBy"/>
        <AbbreviatedIRI>dc:identifier</AbbreviatedIRI>
        <AbbreviatedIRI>dc:</AbbreviatedIRI>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:label"/>
        <AbbreviatedIRI>dc:identifier</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Identificador</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <AbbreviatedIRI>dc:language</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Uma linguagem do recurso.

A melhor prática recomendada é usar um vocabulário controlado como o RFC 4646 [RFC4646].</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:isDefinedBy"/>
        <AbbreviatedIRI>dc:language</AbbreviatedIRI>
        <AbbreviatedIRI>dc:</AbbreviatedIRI>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:label"/>
        <AbbreviatedIRI>dc:language</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Linguagem</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <AbbreviatedIRI>dc:publisher</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Uma entidade responsável por disponibilizar o recurso.

Exemplos de um Publicador incluem uma pessoa, uma organização ou um serviço. Normalmente, o nome de um editor deve ser usado para indicar a entidade.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:isDefinedBy"/>
        <AbbreviatedIRI>dc:publisher</AbbreviatedIRI>
        <AbbreviatedIRI>dc:</AbbreviatedIRI>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:label"/>
        <AbbreviatedIRI>dc:publisher</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Publicador</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <AbbreviatedIRI>dc:relation</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Um recurso relacionado.

A melhor prática recomendada é identificar o recurso relacionado por meio de uma string em conformidade com um sistema de identificação formal.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:isDefinedBy"/>
        <AbbreviatedIRI>dc:relation</AbbreviatedIRI>
        <AbbreviatedIRI>dc:</AbbreviatedIRI>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:label"/>
        <AbbreviatedIRI>dc:relation</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Relação</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <AbbreviatedIRI>dc:rights</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Informações sobre direitos mantidos e sobre o recurso.

Normalmente, as informações sobre direitos incluem uma declaração sobre vários direitos de propriedade associados ao recurso, incluindo direitos de propriedade intelectual.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:isDefinedBy"/>
        <AbbreviatedIRI>dc:rights</AbbreviatedIRI>
        <AbbreviatedIRI>dc:</AbbreviatedIRI>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:label"/>
        <AbbreviatedIRI>dc:rights</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Direitos</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <AbbreviatedIRI>dc:source</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Um recurso relacionado do qual o recurso descrito é derivado.

O recurso descrito pode ser derivado do recurso relacionado no todo ou em parte. A melhor prática recomendada é identificar o recurso relacionado por meio de uma string em conformidade com um sistema de identificação formal.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:isDefinedBy"/>
        <AbbreviatedIRI>dc:source</AbbreviatedIRI>
        <AbbreviatedIRI>dc:</AbbreviatedIRI>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:label"/>
        <AbbreviatedIRI>dc:source</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Recurso</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <AbbreviatedIRI>dc:subject</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">O tópico do recurso.

Normalmente, o assunto será representado usando palavras-chave, frases-chave ou códigos de classificação. A melhor prática recomendada é usar um vocabulário controlado.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:isDefinedBy"/>
        <AbbreviatedIRI>dc:subject</AbbreviatedIRI>
        <AbbreviatedIRI>dc:</AbbreviatedIRI>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:label"/>
        <AbbreviatedIRI>dc:subject</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Assunto</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <AbbreviatedIRI>dc:title</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Um nome dado ao recurso.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:isDefinedBy"/>
        <AbbreviatedIRI>dc:title</AbbreviatedIRI>
        <AbbreviatedIRI>dc:</AbbreviatedIRI>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:label"/>
        <AbbreviatedIRI>dc:title</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Título</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <AbbreviatedIRI>dc:type</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A natureza ou o gênero do recurso.

A melhor prática recomendada é usar um vocabulário controlado, como o Vocabulário de Tipo DCMI [DCMITYPE]. Para descrever o formato de arquivo, o meio físico ou as dimensões do recurso, use o formato (dc:format)</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:isDefinedBy"/>
        <AbbreviatedIRI>dc:type</AbbreviatedIRI>
        <AbbreviatedIRI>dc:</AbbreviatedIRI>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:label"/>
        <AbbreviatedIRI>dc:type</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Tipo</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <AbbreviatedIRI>dcterms:alternative</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Um nome alternativo para o recurso.

A distinção entre títulos e títulos alternativos é específica do aplicativo.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:isDefinedBy"/>
        <AbbreviatedIRI>dcterms:alternative</AbbreviatedIRI>
        <AbbreviatedIRI>dcterms:</AbbreviatedIRI>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:label"/>
        <AbbreviatedIRI>dcterms:alternative</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Alternativo</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <AbbreviatedIRI>dcterms:available</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Data em que o recurso ficará disponível

Data (geralmente um intervalo) em que o recurso se tornou ou ficará disponível.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:isDefinedBy"/>
        <AbbreviatedIRI>dcterms:available</AbbreviatedIRI>
        <AbbreviatedIRI>dcterms:</AbbreviatedIRI>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:label"/>
        <AbbreviatedIRI>dcterms:available</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Disponível</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <AbbreviatedIRI>dcterms:license</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Um documento legal que dá permissão oficial para fazer algo com o recurso.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:isDefinedBy"/>
        <AbbreviatedIRI>dcterms:license</AbbreviatedIRI>
        <AbbreviatedIRI>dcterms:</AbbreviatedIRI>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:label"/>
        <AbbreviatedIRI>dcterms:license</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Licença</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <AbbreviatedIRI>dcterms:provenance</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Uma declaração de quaisquer alterações na propriedade e custódia do recurso desde a sua criação que sejam significativas por sua autenticidade, integridade e interpretação.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:isDefinedBy"/>
        <AbbreviatedIRI>dcterms:provenance</AbbreviatedIRI>
        <AbbreviatedIRI>dcterms:</AbbreviatedIRI>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:label"/>
        <AbbreviatedIRI>dcterms:provenance</AbbreviatedIRI>
        <Literal xml:lang="pt" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Versionamento</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/API_Design_and_Use</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">An application programming interface (API) is the set of signatures that are exported and available to the users of a library or a framework to write their applications. Besides signatures, an API should always include statements about the program’s effects and/or behaviors (i.e., its semantics). API design should try to make the API easy to learn and memorize, lead to readable code, be hard to misuse, be easy to extend, be complete, and maintain backward compatibility. As the APIs usually outlast their implementations for a widely used library or framework, it is desired that the API be straightforward and kept stable to facilitate the development and maintenance of the client applications. API use involves the processes of selecting, learning, testing, integrating, and possibly extending APIs provided by a library or framework.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/API_Design_and_Use</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">API Design and Use</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Abstraction</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Abstraction is an indispensible technique associated with problem solving. It refers to both the process and result of generalization by reducing the information of a concept, a problem, or an observable phenomenon so that one can focus on the “big picture.” One of the most important skills in any engineering undertaking is framing the levels of abstraction appropriately. “Through abstraction,” according to Voland, “we view the problem and its possible solution paths from a higher level of conceptual understanding. As a result, we may become better prepared to recognize possible relationships between different aspects of the problem and thereby generate more creative design solutions”. This is particularly true in computer science in general (such as hardware vs. software) and in software
engineering in particular (data structure vs. data flow, and so forth).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Abstraction</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Abstraction</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Acceptance_Tests</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">An essential property of a software requirement is that it should be possible to validate that the finished product satisfies it. Requirements that cannot be validated are really just “wishes.” An important task is therefore planning how to verify each requirement. In most cases, designing acceptance tests does this for how end-users typically conduct business using the system. Identifying and designing acceptance tests may be difficult for nonfunctional requirements. To be validated, they must first be analyzed and decomposed to the point where they can be expressed quantitatively. Additional information can be found in Acceptance/Qualification/Conformance Testing in the Software Testing KA.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Acceptance_Tests</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Acceptance Tests</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Accounting</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Accounting is part of finance. It allows people whose money is being used to run an organization to know the results of their investment: did they get the profit they were expecting? In “for-profit” organizations, this relates to the tangible ROI, while in “not-for-profit” and governmental organizations as well as “for-profit” organizations, it translates into sustainably staying in business. The primary role of accounting is to measure the organization’s actual financial performance and to communicate financial information about a business entity to stakeholders, such as shareholders, financial auditors, and investors. Communication is generally in the form of financial statements that show in money terms the economic resources to be controlled. It is important to select the right information that is both relevant and reliable to the user. Information and its timing are partially governed by risk management and governance policies. Accounting systems are also a rich source of historical data for estimating.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Accounting</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Accounting</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Accreditation_Certification_and_Licensing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Accreditation is a process to certify the competency, authority, or credibility of an organization. Accredited schools or programs are assured to adhere to particular standards and maintain certain qualities. In many countries, the basic means by which engineers acquire knowledge is through completion of an accredited course of study. Often, engineering accreditation is performed by a government organization, such as the ministry of education. Certification:Certification refers to the confirmation of a person’s particular characteristics. A common type of certification is professional certification, where a person is certified as being able to complete an activity in a certain discipline at a stated level of competency. Professional certification also can also verify the holder’s ability to meet professional standards and to apply professional judgment in solving or addressing problems. “Licensing” is the action of giving a person the authorization to perform certain kinds of activities and take responsibility for resultant engineering products. The noun “license” refers to both that authorization and the document recording
that authorization. Governmental authorities or statutory bodies usually issue licenses. Obtaining a license to practice requires not only that an individual meets a certain standard, but also that they do so with a certain ability to practice or operate.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Accreditation_Certification_and_Licensing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Accreditation, Certification, and Licensing</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Activities_of_Social_Action_Citizenship_and_Environment</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Participation in programs or NGOs related to social action, exercise of citizenship and defense of the environment.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Activities_of_Social_Action_Citizenship_and_Environment</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Activities of social action, citizenship and environment</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Activities_of_student_representations</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Effective participation in the Academic Center and Engineering Academic Directory, student representation in collegiate bodies.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Activities_of_student_representations</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Activities of student representations</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Addressing_Uncertainty</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Because of the many unknown factors during project initiation and planning, estimates are inherently uncertain; that uncertainty should be addressed in business decisions. Techniques for addressing uncertainty include consider ranges of estimates, analyze sensitivity to changes of assumptions, delay final decisions.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Addressing_Uncertainty</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Addressing Uncertainty</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Agile_Methods</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Agile methods were born in the 1990s from the need to reduce the apparent large overhead associated with heavyweight, plan-based methods used in large-scale software-development projects. Many agile methods are available in the literature; some of the more popular approaches, which are discussed here in brief, include Rapid Application Development (RAD), eXtreme Programming (XP), Scrum, and Feature-Driven Development (FDD). RAD: Rapid software development methods are used primarily in data-intensive, businesssystems application development. XP: This approach uses stories or scenarios for requirements, develops tests first, has direct customer involvement on the team (typically defining acceptance tests), uses pair programming, and provides for continuous code refactoring and integration. Scrum: This agile approach is more project management-friendly than the others. The scrum master manages the activities within the project increment; each increment is called a sprint and lasts no more than 30 days. FDD: This is a model-driven, short, iterative software development approach using a five-phase process: develop a product model to scope the breadth of the domain, create the list of needs or features, build the feature development plan, develop designs for iteration-specific features, and code, test, and then integrate the features. There are many more variations of agile methods in the literature and in practice. Note that
there will always be a place for heavyweight, plan-based software engineering methods as well as places where agile methods shine.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Agile_Methods</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Agile Methods</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Algebraic_Structures</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">This section introduces a few representations used in higher algebra. An algebraic structure consists of one or two sets closed under some operations and satisfying a number of axioms, including none. For example, group, monoid, ring, and lattice are examples of algebraic structures.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Algebraic_Structures</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Algebraic Structures</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Algorithmic_Analysis</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Analysis of algorithms is the theoretical study of computer-program performance and resource usage; to some extent it determines the goodness of an algorithm. Such analysis usually abstracts away the particular details of a specific computer and focuses on the asymptotic, machine-independent analysis. There are three basic types of analysis. In worst-case analysis, one determines the maximum time or resources required by the algorithm on any input of size n. In average-case analysis, one determines the expected time or resources required by the algorithm over all inputs of size n; in performing average-case analysis, one often needs to make assumptions on the statistical distribution of inputs. The third type of analysis is the best-case analysis, in which one determines the minimum time or resources required by the algorithm on any input of size n. Among the three types of analysis, average-case analysis is the most relevant but also the most difficult to perform.
Besides the basic analysis methods, there are also the amortized analysis, in which one determines the maximum time required by an algorithm over a sequence of operations; and the competitive analysis, in which one determines the relative performance merit of an algorithm against the optimal algorithm (which may not
be known) in the same category (for the same operations).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Algorithmic_Analysis</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Algorithmic Analysis</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Algorithmic_Analysis_Strategies</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The analysis strategies of algorithms include basic counting analysis, in which one actually counts the number of steps an algorithm takes to complete its task; asymptotic analysis, in which one only considers the order of magnitude of the number of steps an algorithm takes to complete its task; probabilistic analysis, in which one makes use of probabilities in analyzing the average performance of an algorithm; amortized analysis, in which one uses the methods of aggregation, potential, and accounting to analyze the worst performance of an algorithm on a sequence of operations; and competitive analysis, in which one uses methods such as potential and accounting to analyze the relative performance of an algorithm to the optimal algorithm. For complex problems and algorithms, one may need to use a combination of the aforementioned analysis strategies.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Algorithmic_Analysis_Strategies</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Algorithmic Analysis Strategies</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Algorithmic_Design_Strategies</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The design of algorithms generally follows one of the following strategies: brute force, divide and conquer, dynamic programming, and greedy selection. The brute force strategy is actually a no-strategy. It exhaustively tries every possible
way to tackle a problem. If a problem has a solution, this strategy is guaranteed to find it; however, the time expense may be too high. The divide and conquer strategy improves on the brute force strategy by dividing a big problem into smaller, homogeneous problems. It solves the big problem by recursively solving the smaller problems and combing the solutions to the smaller problems to form the solution to the big problem. The underlying assumption for divide and conquer is that smaller problems are easier to solve. The dynamic programming strategy improves on the divide and conquer strategy by recognizing that some of the sub-problems produced by division may be the same and thus avoids solving the same problems again and again. This elimination of redundant subproblems can dramatically improve efficiency. The greedy selection strategy further improves
on dynamic programming by recognizing that not all of the sub-problems contribute to the solution of the big problem. By eliminating all but one sub-problem, the greedy selection strategy achieves the highest efficiency among all algorithm design strategies. Sometimes the use of randomization can improve on the greedy selection strategy by eliminating the complexity in determining the greedy choice through coin flipping or randomization.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Algorithmic_Design_Strategies</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Algorithmic Design Strategies</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Algorithms_and_Complexity</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Programs are not random pieces of code: they are meticulously written to perform user-expected actions. The guide one uses to compose programs are algorithms, which organize various functions into a series of steps and take into consideration
the application domain, the solution strategy, and the data structures being used. An algorithm can be very simple or very complex.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Algorithms_and_Complexity</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Algorithms and Complexity</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Alternate_Abstractions</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Sometimes it is useful to have multiple alternate abstractions for the same problem so that one can keep different perspectives in mind. For example, we can have a class diagram, a state chart, and a sequence diagram for the same software at the same level of abstraction. These alternate abstractions do not form a hierarchy but rather complement each other in helping understanding the problem and its solution. Though beneficial, it is as times difficult to keep alternate abstractions
in sync.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Alternate_Abstractions</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Alternate Abstractions</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Analysis_of_Models</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The development of models affords the software engineer an opportunity to study, reason about, and understand the structure, function, operational usage, and assembly considerations associated with software. Analysis of constructed models is needed to ensure that these models are complete, consistent, and correct enough to serve their intended purpose for the stakeholders. The sections that follow briefly describe the analysis techniques generally used with software models to ensure that the software engineer and other relevant stakeholders gain appropriate value from the development and use of models.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Analysis_of_Models</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Analysis of Models</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Analyze_the_Problem</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Once the problem statement is available, the next step is to analyze the problem statement or situation to help structure our search for a solution. Four types of analysis include situation analysis, in which the most urgent or critical aspects of a
situation are identified first; problem analysis, in which the cause of the problem must be determined; decision analysis, in which the action(s) needed to correct the problem or eliminate its cause must be determined; and potential problem analysis, in which the action(s) needed to prevent any reoccurrences of the problem or the development of new problems must be determined.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Analyze_the_Problem</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Analyze the Problem</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Analyzing_for_Completeness</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">In order to have software that fully meets the needs of the stakeholders, completeness is critical from the requirements elicitation process to code implementation. Completeness is the degree to which all of the specified requirements have been implemented and verified. Models may be checked for completeness by a modeling tool that uses techniques such as structural analysis and state-space reachability analysis (which ensure that all paths in the state models are reached by some set of correct inputs); models may also be checked for completeness manually by using inspections or other review techniques. Errors and warnings generated by these analysis tools and found by inspection or review indicate probable needed corrective actions to ensure completeness of the models.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Analyzing_for_Completeness</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Analyzing for Completeness</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Analyzing_for_Consistency</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Consistency is the degree to which models contain no conflicting requirements, assertions, constraints, functions, or component descriptions. Typically, consistency checking is accomplished with the modeling tool using an automated analysis function; models may also be checked for consistency manually using inspections or other review techniques. As with completeness, errors and warnings generated by these analysis tools and found by inspection or review indicate the need for corrective action.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Analyzing_for_Consistency</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Analyzing for Consistency</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Analyzing_for_Correctness</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Correctness is the degree to which a model satisfies its software requirements and software design specifications, is free of defects, and ultimately meets the stakeholders’ needs. Analyzing for correctness includes verifying syntactic correctness of the model (that is, correct use of the modeling language grammar and constructs) and verifying semantic correctness of the model (that is, use of the modeling language constructs to correctly represent the meaning of that which is
being modeled). To analyze a model for syntactic and semantic correctness, one analyzes it either automatically (for example, using the modeling tool to check for model syntactic correctness) or manually (using inspections or other review
techniques) searching for possible defects and then removing or repairing the confirmed defects before the software is released for use.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Analyzing_for_Correctness</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Analyzing for Correctness</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Anticipating_Change</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Most software will change over time, and the anticipation of change drives many aspects of software construction; changes in the environments in which software operates also affect software in diverse ways. Anticipating change helps software engineers build extensible software, which means they can enhance a software product without disrupting the underlying structure. Anticipating change is supported by many specific techniques.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Anticipating_Change</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Anticipating Change</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Architectural_Design_and_Requirements_Allocation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">At some point, the solution architecture must be derived. Architectural design is the point at which the requirements process overlaps with software or systems design and illustrates how impossible it is to cleanly decouple the two tasks. This topic is closely related to Software Structure and Architecture in the Software Design KA. In many cases, the software engineer acts as software architect because the process of analyzing and elaborating the requirements demands that the architecture/design components that will be responsible for satisfying the requirements be identified. This is requirements allocation–the assignment to architecture components responsible for satisfying the requirements. Allocation is important to permit detailed analysis of requirements. Hence, for example, once a set of requirements has been allocated to a component, the individual requirements can be further analyzed to discover further requirements on how the component needs to interact with other components in order to satisfy the allocated requirements. In large projects, allocation stimulates a new round of analysis for each subsystem. As an example, requirements for a particular braking performance for a car (braking distance, safety in poor driving conditions, smoothness of application, pedal pressure required, and so on) may be allocated to the braking hardware (mechanical and hydraulic assemblies) and an antilock braking system (ABS). Only when a requirement for an antilock braking system has been identified, and the requirements allocated to it, can the capabilities of the ABS, the braking hardware, and emergent properties (such as car weight) be used to identify the detailed ABS software requirements. Architectural design is closely identified with conceptual modeling.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Architectural_Design_and_Requirements_Allocation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Architectural Design and Requirements Allocation</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Architectural_Structures_and_Viewpoints</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Different high-level facets of a software design can be described and documented. These facets are often called views: “A view represents a partial aspect of a software architecture that shows specific properties of a software system”. Views pertain to distinct issues associated with software design for example, the logical view (satisfying the functional requirements) vs. the process view (concurrency issues) vs. the physical view (distribution issues) vs. the development view (how the
design is broken down into implementation units with explicit representation of the dependencies among the units). Various authors use different terminologies like behavioral vs. functional vs. structural vs. data modeling views. In summary, a
software design is a multifaceted artifact produced by the design process and generally composed of relatively independent and orthogonal views.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Architectural_Structures_and_Viewpoints</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Architectural Structures and Viewpoints</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Architectural_Styles</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">An architectural style is “a specialization of element and relation types, together with a set of constraints on how they can be used”. An architectural style can thus be seen as providing the software’s high-level organization. Various authors have identified a number of major architectural styles: General structures (for example, layers, pipes and filters, blackboard); Distributed systems (for example, clientserver, three-tiers, broker); Interactive systems (for example, Model-ViewController, Presentation-Abstraction-Control); Adaptable systems (for example, microkernel,
reflection); Others (for example, batch, interpreters, process
control, rule-based).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Architectural_Styles</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Architectural Styles</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Architecture_Design_Decisions</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Architectural design is a creative process. During the design process, software designers have to make a number of fundamental decisions that profoundly affect the software and the development process. It is useful to think of the architectural design process from a decision-making perspective rather than from an activity perspective. Often, the impact on quality attributes and tradeoffs among competing quality attributes are the basis for design decisions.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Architecture_Design_Decisions</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Architecture Design Decisions</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Assertions_Design_by_Contract_and_Defensive_Programming</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">An assertion is an executable predicate that’s placed in a program usually a routine or macro that allows runtime checks of the program. Assertions are especially useful in high-reliability programs. They enable programmers to more quickly flush out mismatched interface assumptions, errors that creep in when code is modified, and so on. Assertions are normally compiled into the code at development time and are later compiled out of the code so that they don’t degrade the performance. Design by contract is a development approach in which preconditions and postconditions are included for each routine. When preconditions and postconditions are used, each routine or class is said to form a contract with the rest of the program. Furthermore, a contract provides a precise specification of the semantics of a routine, and thus helps the understanding of its behavior. Design by contract is thought to improve the quality of software construction. Defensive programming means to protect a routine from being broken by invalid inputs.
Common ways to handle invalid inputs include checking the values of all the input parameters and deciding how to handle bad inputs. Assertions are often used in defensive programming to check input values.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Assertions_Design_by_Contract_and_Defensive_Programming</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Assertions, Design by Contract, and Defensive Programming</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Assessing_Reliability</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">There are several methods for assessing reliability; these include the test-retest method, the alternative form method, the split-halves method, and the internal consistency method. The easiest of these is the test-retest method. In the testretest
method, we simply apply the measurement method to the same subjects twice. The correlation coefficient between the first and second set of measurement results gives the reliability of the measurement method.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Assessing_Reliability</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Assessing Reliability</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Attributes_of_Algorithms</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The attributes of algorithms are many and often include modularity, correctness, maintainability, functionality, robustness, user-friendliness (i.e. easy to be understood by people), programmer time, simplicity, and extensibility. A commonly emphasized attribute is “performance” or “efficiency” by which we mean both time and resource-usage efficiency while generally emphasizing the time axis. To some degree, efficiency determines if an algorithm is feasible or impractical. For example, an algorithm that takes one hundred years to terminate is virtually useless and is even considered incorrect.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Attributes_of_Algorithms</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Attributes of Algorithms</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Based_on_the_Software_Engineers_Intuition_and_Experience</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Perhaps the most widely practiced technique is ad hoc testing: tests are derived relying on the software engineer’s skill, intuition, and experience with similar programs. Ad hoc testing can be useful for identifying tests cases that not easily
generated by more formalized techniques. Exploratory testing is defined as simultaneous learning, test design, and test execution; that is, the tests are not defined in advance in an established test plan, but are dynamically designed, executed, and modified. The effectiveness of exploratory testing relies on the software engineer’s knowledge, which can be derived from various sources: observed product behavior during testing, familiarity with the application, the platform, the failure process, the type of possible faults and failures, the risk associated with a particular product, and so on.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Based_on_the_Software_Engineers_Intuition_and_Experience</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Based on the Software Engineer’s Intuition and Experience</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Basic_Concept_of_a_System</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Ian Sommerville writes, “a system is a purposeful collection of interrelated components that work together to achieve some objective”. A system can be very simple and include only a few components, like an ink pen, or rather complex,
like an aircraft. Depending on whether humans are part of the system, systems can be divided into technical computer-based systems and sociotechnical systems. A technical computer-based system functions without human involvement, such as televisions, mobile phones, thermostat, and some software; a sociotechnical system will not function without human involvement. Examples of such system include manned space vehicles, chips embedded inside a human, and so forth.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Basic_Concept_of_a_System</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Basic Concept of a System</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Basic_Developer_Human_Factors</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Developer human factors refer to the considerations of human factors taken when developing software. Software is developed by humans, read by humans, and maintained by humans. If anything is wrong, humans are responsible for correcting those wrongs. Thus, it is essential to write software in a way that is easily understandable by humans or, at the very least, by other software developers. A program that is easy to read and understand exhibits readability. The means to ensure that software meet this objective are numerous and range from proper
architecture at the macro level to the particular coding style and variable usage at the micro level. But the two prominent factors are structure (or program layouts) and comments(documentation).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Basic_Developer_Human_Factors</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Basic Developer Human Factors</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Basic_Logic</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Basic Logic</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Basic_Network_Components</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">All networks are made up of the same basic hardware components, including computers, network interface cards (NICs), bridges, hubs, switches, and routers. All these components are called nodes in the jargon of networking. Each component performs a distinctive function that is essential for the packaging, connection, transmission, amplification, controlling, unpacking, and interpretation of the data. For example, a repeater amplifies the signals, a switch performs many-to-many connections, a hub performs one-to-many connections, an interface card is attached to the computer and performs data packing and transmission, a bridge
connects one network with another, and a router is a computer itself and performs data analysis and flow control to regulate the data from the network. The functions performed by various network components correspond to the functions specified
by one or more levels of the seven-layer Open Systems Interconnect (OSI) networking model, which is discussed below.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Basic_Network_Components</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Basic Network Components</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Basic_User_Human_Factors</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software is developed to meet human desires or needs. Thus, all software design and development must take into consideration human-user factors such as how people use software, how people view software, and what humans expect from software. There are numerous factors in the human-machine interaction, and ISO 9241 document series define all the detailed standards of such interactions.[10] But the basic human-user factors considered here include input/output, the handling of error messages, and the robustness of the software in general.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Basic_User_Human_Factors</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Basic User Human Factors</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Basics_of_Counting</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The sum rule states that if a task t1 can be done in n1 ways and a second task t2 can be done in n2 ways, and if these tasks cannot be done at the same time, then there are n1 + n2 ways to do either task. Recursion is the general term for the practice of defining an object in terms of itself. There are recursive algorithms, recursively defined functions, relations, sets, etc.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Basics_of_Counting</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Basics of Counting</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Behavioral_Descriptions_Dynamic_View</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The following notations and languages, some graphical and some textual, are used to describe the dynamic behavior of software systems and components. Many of these notations are useful mostly, but not exclusively, during detailed
design. Moreover, behavioral descriptions can include a rationale for design decision such as how a design will meet security requirements: Activity diagrams: used to show control flow from activity to activity. Can be used to represent concurrent activities; Communication diagrams: used to show the interactions that occur among a group of objects; emphasis is on the objects, their links, and the messages they exchange on those links; Data flow diagrams (DFDs): used to show data flow among elements. A data flow diagram provides “a description based on modeling the flow of information around a network
of operational elements, with each element making use of or modifying the information flowing into that element”. Data flows can be used for security analysis, as they offer identification of possible paths for attack and disclosure
of confidential information; Decision tables and diagrams: used to represent
complex combinations of conditions and actions; Flowcharts: used to represent the flow of control and the associated actions to be performed; Sequence diagrams: used to show the interactions among a group of objects, with emphasis on the time ordering of messages passed between objects; State transition and state chart diagrams: used to show the control flow from state to state and how the behavior of a component changes based on its current state in a state machine; Formal specification languages: textual languages that use basic notions from mathematics to rigorously and abstractly define software component interfaces and behavior, often in terms of pre- and postconditions; Pseudo code and program design languages (PDLs): structured programming-like languages used to describe, generally at the detailed design stage, the behavior of a procedure or method.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Behavioral_Descriptions_Dynamic_View</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Behavioral Descriptions (Dynamic View)</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Behavioral_Modeling</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Behavioral models identify and define the functions of the software being modeled. Behavioral models generally take three basic forms: state machines, control-flow models, and dataflow models. State machines provide a model of the software as a collection of defined states, events, and transitions. The software transitions from one state to the next by way of a guarded or unguarded triggering event that occurs in the modeled environment. Control-flow models depict how a sequence of events causes processes to be activated or deactivated. Data-flow behavior is typified as a sequence of steps where data moves through processes toward data stores or data sinks.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Behavioral_Modeling</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Behavioral Modeling</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Break_Even_Analysis</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Break-even analysis identifies the point where the costs of developing a product and the revenue to be generated are equal. Such an analysis can be used to choose between different proposals at different estimated costs and revenue. Given estimated costs and revenue of two or more proposals, break-even analysis helps in choosing amont them.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Break_Even_Analysis</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Break-Even Analysis</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Build_Security_into_Software_Engineering_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software is only as secure as its development process goes. To ensure the security of software, security must be built into the software engineering process. One trend that emerges in this regard is the Secure Development Lifecycle (SDL) concept, which is a classical spiral model that takes a holistic view of security from the perspective of software lifecycle and ensures that security is inherent in software design and development, not an afterthought later in production. The SDL process
is claimed to reduce software maintenance costs and increase reliability of software concerning software security related faults.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Build_Security_into_Software_Engineering_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Build Security into Software Engineering Process</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Business_Case</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The business case is the consolidated information summarizing and explaining a business proposal from different perspectives for a decision maker (cost, benefit, risk, and so on). It is often used to assess the potential value of a product, which can be used as a basis in the investment decisionmaking process. As opposed to a mere profitloss calculation, the business case is a “case” of plans and analyses that is owned by the product manager and used in support of achieving the business objectives.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Business_Case</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Business Case</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Cash_Flow</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Cash flow is the movement of money into or out of a business, project, or financial product over a given period. The concepts of cash flow instances and cash flow streams are used to describe the business perspective of a proposal. To make a meaningful business decision about any specific proposal, that proposal will need to be evaluated from a business perspective. In a proposal to develop and launch product X, the payment for new software licenses is an example of an outgoing cash flow instance. Money would need to be spent to carry out that proposal. The sales income from product X in the 11th month after market launch is an example of an incoming cash flow instance. Money would be coming in because of carrying out the proposal. The term cash flow stream refers to the set of cash flow instances over time that are caused by carrying out some given proposal. The cash flow stream is, in effect, the complete financial picture of that proposal. How much money goes out? When does it go out? How much money comes in? When does it come in? Simply, if the cash flow stream for Proposal A is more desirable than the cash flow stream for Proposal B, then all other things being equal the organization is better off carrying out Proposal A than Proposal B. Thus, the cash flow stream is an important input for investment decision-making. A cash flow instance is a specific amount of money flowing into or out of the organization at a specific time
as a direct result of some activity.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Cash_Flow</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Cash Flow</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Categories_of_Maintenance</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Three categories (types) of maintenance have been defined: corrective, adaptive, and perfective. IEEE 14764 includes a fourth category–preventative: Corrective maintenance: reactive modification (or repairs) of a software product performed after delivery to correct discovered problems. Included in this category is emergency maintenance, which is an unscheduled modification performed to temporarily keep a software product operational pending corrective maintenance; Adaptive maintenance: modification of a software product performed after delivery to keep a software product usable in a changed or changing environment. For example, the operating system might be upgraded and some changes to the software may be necessary; Perfective maintenance: modification of a software product after delivery to provide enhancements for users, improvement of
program documentation, and recoding to improve software performance, maintainability, or other software attributes; Preventive maintenance: modification of a software product after delivery to detect and correct latent faults in the software product before they become operational faults. IEEE 14764 classifies adaptive and perfective maintenance as maintenance enhancements. It also groups together the corrective and preventive maintenance categories into a correction category.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Categories_of_Maintenance</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Categories of Maintenance</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Categories_of_Software_Processes</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Many distinct software processes have been defined for use in the various parts of the software development and software maintenance life cycles. These processes can be categorized as follows: Primary processes include software processes for development, operation, and maintenance of software. Supporting processes are applied intermittently or continuously throughout a software product life cycle to support primary processes. Organizational processes provide support for software engineering. Cross-project processes, such as reuse, software product line, and domain engineering; they involve more than a single software project in an organization. Software processes in addition to those listed above include the following. Project management processes include processes for planning and estimating, resource management, measuring and controlling, leading, managing risk, managing stakeholders, and coordinating the primary, supporting, organizational, and cross-project processes of software development and maintenance projects. Software processes are also developed for particular needs, such as process activities that address software quality characteristics. For example, security concerns during software development may necessitate one or more software processes to protect the security of the development environment
and reduce the risk of malicious acts.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Categories_of_Software_Processes</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Categories of Software Processes</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Categories_of_Tools</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">We categorize the available tools according to their functionality: Test harnesses (drivers, stubs) provide a controlled environment in which tests can be launched and the test outputs can be logged. In order to execute parts of a program, drivers and stubs are provided to simulate calling and called modules, respectively; Test generators provide assistance in the generation test cases. The generation can be random, path-based, modelbased, or a mix thereof; Capture/replay tools automatically reexecute, or replay, previously executed tests which have recorded inputs and outputs (e.g., screens); Oracle/file comparators/assertion checking
tools assist in deciding whether a test outcome is successful or not; Coverage analyzers and instrumenters work together. Coverage analyzers assess which and how many entities of the program flow graph have been exercised amongst all
those required by the selected test coverage criterion. The analysis can be done thanks to program instrumenters that insert recording probes into the code; Tracers record the history of a program’s execution paths; Regression testing tools  support
the reexecution of a test suite after a section of software has been modified. They can also help to select a test subset according to the change made; Reliability evaluation tools support test results analysis and graphical visualization in order to assess reliability-related measures according to selected models.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Categories_of_Tools</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Categories of Tools</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Change_Management</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Change management is central to the management of requirements. This topic describes the role of change management, the procedures that need to be in place, and the analysis that should be applied to proposed changes. It has strong links to the Software Configuration Management KA.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Change_Management</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Change Management</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Closure</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">An entire project, a major phase of a project, or an iterative development cycle reaches closure when all the plans and processes have been enacted and completed. The criteria for project, phase, or iteration success should be evaluated.
Once closure is established, archival, retrospective, and process improvement activities can be performed.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Closure</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Closure</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Closure_Activities</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">After closure has been confirmed, archiving of project materials should be accomplished in accordance with stakeholder agreed-upon methods, location, and duration possibly including destruction of sensitive information, software, and the medium on which copies are resident. The organization’s measurement database should be updated with relevant project data. A project, phase, or iteration retrospective analysis should be undertaken so that issues, problems, risks, and opportunities encountered can be analyzed. Lessons learned should be drawn from the project and fed into organizational learning and improvement endeavors.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Closure_Activities</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Closure Activities</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Code_Based_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Control flow-based coverage criteria are aimed at covering all the statements, blocks of statements, or specified combinations of statements in a program. The strongest of the control flowbased criteria is path testing, which aims to
execute all entry-to-exit control flow paths in a program’s control flow graph. Since exhaustive path testing is generally not feasible because of loops, other less stringent criteria focus on coverage of paths that limit loop iterations such as statement coverage, branch coverage, and condition/decision testing. The adequacy of such tests is measured in percentages; for example, when all branches have been executed at least once by the tests, 100% branch coverage has been achieved. In data flow-based testing, the control flow graph is annotated with information about how the program variables are defined, used, and killed (undefined). The strongest criterion, all definition-use paths, requires that, for each variable, every control flow path segment from a definition of that variable to a use of that definition is executed. In order to reduce the number of paths required, weaker strategies such as all-definitions and all-uses are employed. Although not a technique in itself, the control structure of a program can be graphically represented using a flow graph to visualize codebased testing techniques. A flow graph is a directed graph, the nodes and arcs of which correspond to program elements. For instance, nodes may represent statements or uninterrupted sequences of statements, and arcs may represent the transfer of control between
nodes.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Code_Based_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Code-Based Techniques</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Codes_of_Ethics_and_Professional_Conduct</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Codes of ethics and professional conduct comprise the values and behavior that an engineer’s professional practice and decisions should embody. The professional community establishes codes of ethics and professional conduct. They exist in the context of, and are adjusted to agree with, societal norms and local laws. Therefore, codes of ethics and professional conduct present guidance in the face of conflicting imperatives. Once established, codes of ethics and professional
conduct are enforced by the profession, as represented by professional societies or by a statutory body. Violations may be acts of commission, such as concealing inadequate work, disclosing confidential information, falsifying information, or
misrepresenting one’s abilities. They may also occur through omission, including failure to disclose risks or to provide important information, failure to give proper credit or to acknowledge references, and failure to represent client interests. Violations of codes of ethics and professional conduct may result in penalties and possible expulsion from professional status. A code of ethics and professional conduct for software engineering was approved by the ACM Council and the IEEE CS Board of Governors in 1999.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Codes_of_Ethics_and_Professional_Conduct</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Codes of Ethics and Professional Conduct</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Coding</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The following considerations apply to the software construction coding activity: Techniques for creating understandable source code, including naming conventions and source code layout; Use of classes, enumerated types, variables,
named constants, and other similar entities; Use of control structures; Handling of error conditions both anticipated and exceptional (input of bad data, for example); Prevention of code-level security breaches (buffer overflows or array index bounds, for example); Resource usage via use of exclusion mechanisms and discipline in accessing serially reusable resources (including threads and database locks); Source code organization (into statements, routines, classes, packages, or other structures); Code documentation; Code tuning.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Coding</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Coding</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Comments</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">To most people, programming is coding. These people do not realize that programming also includes writing comments and that comments are an integral part of programming. True, comments are not used by the computer and certainly do not constitute final instructions for the computer, but they improve the readability of the programs by explaining the meaning and logic of the statements or sections of code. It should be remembered that programs are not only meant for computers, they are also read, written, and modified by humans. The types of comments include repeat of the code, explanation of the code, marker of the code, summary of the code, description of the code’s intent, and information that cannot possibly be expressed by the code itself. Some comments are good, some are not. The good ones are those that explain the intent of the code and justify why this code looks the way it does. The bad ones are repeat of the code and stating irrelevant information. The best comments are selfdocumenting code. If the code is written in such a clear and precise manner that its meaning is selfproclaimed, then no comment is needed. But this is easier said than done. Most programs are not
self-explanatory and are often hard to read and understand if no comments are given.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Comments</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Comments</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Communication_Skills</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">It is vital that a software engineer communicate well, both orally and in reading and writing. Successful attainment of software requirements and deadlines depends on developing clear understanding between the software engineer and customers, supervisors, coworkers, and suppliers. Optimal problem solving is made possible through the ability to investigate, comprehend, and summarize information. Customer product acceptance and safe product usage depend on the provision of relevant training and documentation. It follows that the software engineer’s own career success is affected by the ability to consistently provide oral and written communication effectively and on time.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Communication_Skills</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Communication Skills</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Compiler_Basics</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Compiler Basics</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Compiler_or_Interpreter_Overview</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Programmers usually write programs in high level language code, which the CPU cannot execute; so this source code has to be converted into machine code to be understood by a computer. Due to the differences between different ISAs, the translation must be done for each ISA or specific machine language under consideration. The translation is usually performed by a piece of software called a compiler or an interpreter. This process of translation from a high-level language
to a machine language is called compilation, or, sometimes, interpretation.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Compiler_or_Interpreter_Overview</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Compiler/Interpreter Overview</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Component_Based_Design</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A software component is an independent unit, having well-defined interfaces and dependencies that can be composed and deployed independently. Component-based design addresses issues related to providing, developing, and
integrating such components in order to improve reuse. Reused and off-the-shelf software components should meet the same security requirements as new software. Trust management is a design concern; components treated as having
a certain degree of trustworthiness should not depend on less trustworthy components or services.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Component_Based_Design</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Component-Based Design (CBD)</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Computer_Expression_of_Data</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">As mentioned before, a computer expresses data with electrical signals or digital zeros and ones. Since there are only two different digits used in data expression, such a system is called a binary expression system. Due to the inherent nature of
a binary system, the maximum numerical value expressible by an n-bits binary code is 2n − 1. Specifically, binary number an an−1…a1 a0 corresponds to an × 2n + an−1 × 2n−1 + … + a1 × 21 + a0 × 20. Thus, the numerical value of the binary
expression of 1011 is 1 × 8 + 0 × 4 + 1 × 2 + 1 × 1 = 11. To express a nonnumerical value, we need to decide the number of zeros and ones to use and the order in which those zeros and ones are arranged.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Computer_Expression_of_Data</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Computer Expression of Data</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Computer_Organization</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">From the perspective of a computer, a wide semantic gap exists between its intended behavior and the workings of the underlying electronic devices that actually do the work within the computer. This gap is bridged through computer organization, which meshes various electrical, electronic, and mechanical devices into one device that forms a computer. The objects that computer organization deals with are the devices, connections, and controls. The abstraction built in computer organization is the computer.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Computer_Organization</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Computer Organization</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Computer_Organization_Overview</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A computer generally consists of a CPU, memory, input devices, and output devices. Abstractly speaking, the organization of a computer can be divided into four levels. The macro architecture level is the formal specification of all the functions a particular machine can carry out and is known as the instruction set architecture (ISA). The micro architecture level is the implementation of the ISA in a specific CPU in other words, the way in which the ISA’s specifications are actually carried out. The logic circuits level is the level where each functional component of the micro architecture is built up of circuits that make decisions based on simple rules. The devices level is the level where, finally, each logic circuit is actually built of electronic devices such as complementary metal-oxide semiconductors (CMOS), n-channel metal oxide semiconductors (NMOS), or gallium arsenide (GaAs) transistors, and so forth.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Computer_Organization_Overview</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Computer Organization Overview</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Computing_Foundations</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The scope of the Computing Foundations knowledge area (KA) encompasses the development and operational environment in which software evolves and executes. Because no software can exist in a vacuum or run without a computer, the core of such an environment is the computer and its various components. Knowledge about the computer and its underlying principles of hardware and software serves as a framework on which software engineering is anchored. Thus, all software engineers must have good understanding of the Computing Foundations KA. It is generally accepted that software engineering builds on top of computer science. For example, “Software Engineering 2004: Curriculum Guidelines for Undergraduate Degree Programs in Software Engineering” clearly states, “One particularly important aspect is that software engineering builds on computer science and mathematics” (italics added).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Computing_Foundations</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Computing Foundations</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Concepts_of_Correlation_and_Regression</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A major objective of many statistical investigations is to establish relationships that make it possible to predict one or more variables in terms of others. Although it is desirable to predict a quantity exactly in terms of another quantity, it is seldom possible and, in many cases, we have to be satisfied with estimating the average or expected values. The relationship between two variables is studied using the methods of correlation and regression. Both these concepts are explained briefly in
the following paragraphs. Correlation. The strength of linear relationship between two variables is measured using the correlation coefficient. While computing the
correlation coefficient between two variables, we assume that these variables measure two different attributes of the same entity. The correlation coefficient takes a value between –1 to +1. The values –1 and +1 indicate a situation when the
association between the variables is perfect—i.e., given the value of one variable, the other can be estimated with no error. It is important to remember that correlation does not imply causation. Thus, if two variables are correlated, we cannot conclude that one causes the other. Regression. The correlation analysis only measures the degree of relationship between two variables. The analysis to find the relationship between two variables is called regression analysis. The strength of the relationship between two variables is measured using the coefficient of determination.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Concepts_of_Correlation_and_Regression</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Concepts of Correlation and Regression</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Conceptual_Modeling</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The development of models of a real-world problem is key to software requirements analysis. Their purpose is to aid in understanding the situation in which the problem occurs, as well as depicting a solution. Hence, conceptual models comprise models of entities from the problem domain, configured to reflect their real-world relationships and dependencies. This topic is closely related to the Software Engineering Models and Methods KA. Several kinds of models can be developed. These include use case diagrams, data flow models, state models, goal-based models, user interactions, object models, data models, and many others. Many of these modeling notations are part of the Unified Modeling Language (UML). Use case diagrams, for example, are routinely used to depict scenarios where the boundary separates the actors (users or systems in the external environment) from the internal behavior where each use case depicts a functionality of the system. The factors that influence the choice of modeling notation include these: The nature of the problem, the expertise of the software engineer, the process requirements of the customer. Note that, in almost all cases, it is useful to start by building a model of the software context. The software context provides a connection between the intended software and its external environment. This is crucial to understanding the software’s context in its operational environment and to identifying its interfaces with the environment.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Conceptual_Modeling</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Conceptual Modeling</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Concurrency</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Design for concurrency is concerned with decomposing software into processes, tasks, and threads and dealing with related issues of efficiency, atomicity, synchronization, and scheduling.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Concurrency</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Concurrency</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Concurrency_Primitives</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A synchronization primitive is a programming abstraction provided by a programming language or the operating system that facilitates concurrency and synchronization. Well-known concurrency primitives include semaphores, monitors, and mutexes. A semaphore is a protected variable or abstract data type that provides a simple but useful abstraction for controlling access to a common resource by multiple processes or threads in a concurrent programming environment. A monitor is an abstract data type that presents a set of programmer-defined operations that are executed with mutual exclusion. A monitor contains the declaration of shared variables and procedures or functions that operate on those variables. The monitor construct ensures that only one process at a time is active within the monitor. A mutex (mutual exclusion) is a synchronization primitive that grants exclusive access to a shared resource by only one process or thread at a time.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Concurrency_Primitives</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Concurrency Primitives</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Constraints_and_Guidance_for_the_SCM_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Constraints affecting, and guidance for, the SCM process come from a number of sources. Policies and procedures set forth at corporate or other organizational levels might influence or prescribe the design and implementation of the SCM process
for a given project. In addition, the contract between the acquirer and the supplier might contain provisions affecting the SCM process. For example, certain configuration audits might be required, or it might be specified that certain items
be placed under CM. When software products to be developed have the potential to affect public safety, external regulatory bodies may impose constraints. Finally, the particular software life cycle process chosen for a software project and the level of formalism selected to implement the software affect the design and implementation of the SCM process. Guidance for designing and implementing an
SCM process can also be obtained from “best practice,” as reflected in the standards on software engineering issued by the various standards organizations.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Constraints_and_Guidance_for_the_SCM_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Constraints and Guidance for the SCM Process</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Constructing_Heterogeneous_Systems</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Heterogeneous systems consist of a variety of specialized computational units of different types, such as Digital Signal Processors (DSPs), microcontrollers, and peripheral processors. These computational units are independently controlled
and communicate with one another. Embedded systems are typically heterogeneous systems. The design of heterogeneous systems may require the combination of several specification languages in order to design different parts of
the system in other words, hardware/software codesign. The key issues include multilanguage validation, cosimulation, and interfacing. During the hardware/software codesign, software development and virtual hardware development proceed concurrently through stepwise decomposition. The hardware part is usually simulated in field programmable gate arrays (FPGAs) or application-specific integrated circuits (ASICs). The software part is translated into
a low-level programming language.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Constructing_Heterogeneous_Systems</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Constructing Heterogeneous Systems</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Constructing_for_Verification</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Constructing for verification means building software in such a way that faults can be readily found by the software engineers writing the software as well as by the testers and users during independent testing and operational activities. Specific techniques that support constructing for verification include following coding standards to support code reviews and unit testing, organizing code to support automated testing, and restricting the use of complex or hard-to-understand language structures, among others.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Constructing_for_Verification</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Constructing for Verification</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Construction_Design</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Some projects allocate considerable design activity to construction, while others allocate design to a phase explicitly focused on design. Regardless of the exact allocation, some detailed design work will occur at the construction level, and that
design work tends to be dictated by constraints imposed by the real-world problem that is being addressed by the software. Just as construction workers building a physical structure must make small-scale modifications to account for unanticipated gaps in the builder’s plans, software construction workers must make modifications on a smaller or larger scale to flesh out details of the software design
during construction. The details of the design activity at the construction level are essentially the same as described in the Software Design KA, but they are applied on
a smaller scale of algorithms, data structures, and interfaces.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Construction_Design</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Construction Design</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Construction_Languages</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Construction languages include all forms of communication by which a human can specify an executable problem solution to a problem. Construction languages and their implementations (for example, compilers) can affect software quality attributes of performance, reliability, portability, and so forth. They can be serious contributors to security vulnerabilities. The simplest type of construction language is a configuration language, in which software engineers choose from a limited set of predefined options to create new or custom software installations. Toolkit languages are used to build applications out of elements in toolkits (integrated sets of application-specific reusable parts); they are more complex than configuration languages. Programming languages are the most flexible type of construction languages. There are three general kinds of notation used for programming languages, namely linguistic (e.g., C/C++, Java), formal (e.g., Event-B), visual (e.g., MatLab). Linguistic notations are distinguished in particular by the use of textual strings to represent complex software constructions. The combination of textual strings into patterns may have a sentence-like syntax. Formal notations rely less on intuitive, everyday meanings of words and text strings and more on definitions backed up by precise, unambiguous, and formal (or mathematical) definitions.
Formal constructions also use precisely defined ways of combining symbols that avoid the ambiguity of many natural language constructions. Visual notations rely much less on the textual notations of linguistic and formal construction and instead rely on direct visual interpretation and placement of visual entities that represent the underlying software. Visual construction tends to be somewhat limited by the difficulty of making “complex” statements using only the arrangement of icons on a display.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Construction_Languages</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Construction Languages</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Construction_Measurement</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Numerous construction activities and artifacts can be measured including code developed, code modified, code reused, code destroyed, code complexity, code inspection statistics, fault-fix and fault-find rates, effort, and scheduling. These measurements can be useful for purposes of managing construction, ensuring quality during construction, and improving the construction process, among other uses.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Construction_Measurement</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Construction Measurement</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Construction_Methods_for_Distributed_Software</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A distributed system is a collection of physically separate, possibly heterogeneous computer systems that are networked to provide the users with access to the various resources that the system maintains. Construction of distributed software is
distinguished from traditional software construction by issues such as parallelism, communication, and fault tolerance. Distributed programming typically falls into one of several basic architectural categories: clientserver, 3-tier architecture, n-tier architecture, distributed objects, loose coupling, or tight coupling.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Construction_Methods_for_Distributed_Software</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Construction Methods for Distributed Software</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Construction_Planning</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The choice of construction method is a key aspect of the construction-planning activity. The choice of construction method affects the extent to which construction prerequisites are performed, the order in which they are performed, and the degree to which they should be completed before construction work begins. The approach to construction affects the project team’s ability to reduce complexity, anticipate change, and construct for verification. Each of these objectives may also be addressed at the process, requirements, and design levels but they will be influenced by the choice of construction method. Construction planning also defines the order in which components are created and integrated,
the integration strategy (for example, phased or incremental integration), the software quality management processes, the allocation of task assignments to specific software engineers, and other tasks, according to the chosen method.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Construction_Planning</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Construction Planning</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Construction_Quality</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">In addition to faults resulting from requirements and design, faults introduced during construction can result in serious quality problems for example, security vulnerabilities. This includes not only faults in security functionality but also faults elsewhere that allow bypassing of this functionality and other security weaknesses or violations. Numerous techniques exist to ensure the quality of code as it is constructed. The primary techniques used for construction quality include unit testing and integration testing; test-first development; use of assertions and defensive programming; debugging; inspections; technical reviews, including security-oriented reviews; static analysis. The specific technique or techniques selected depend on the nature of the software being constructed as well as on the skillset of the software engineers performing the construction activities. Programmers should know good practices and common vulnerabilities for example, from widely recognized lists about common vulnerabilities. Automated static analysis of code for security weaknesses is available for several common
programming languages and can be used in security-critical projects. Construction quality activities are differentiated from other quality activities by their focus.
Construction quality activities focus on code and artifacts that are closely related to code such as detailed design as opposed to other artifacts that are less directly connected to the code, such as requirements, high-level designs, and plans.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Construction_Quality</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Construction Quality</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Construction_Technologies</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Construction Technologies</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Construction_Testing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Construction involves two forms of testing, which are often performed by the software engineer who wrote the code: Unit testing; Integration testing. The purpose of construction testing is to reduce the gap between the time when faults are inserted into the code and the time when those faults are detected, thereby reducing the cost incurred to fix them. In some instances, test cases are written after code has been written. In other instances, test cases may be created before code is written. Construction testing typically involves a subset of the various types of testing, which are described in the Software Testing KA. For instance, construction testing does not typically include system testing, alpha testing, beta testing, stress testing, configuration testing, usability testing, or other more specialized kinds of testing.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Construction_Testing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Construction Testing</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Construction_for_Reuse</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Construction for reuse creates software that has the potential to be reused in the future for the present project or other projects taking a broadbased, multisystem perspective. Construction for reuse is usually based on variability analysis and design. To avoid the problem of code clones, it is desired to encapsulate reusable code fragments into well-structured libraries or components. The tasks related to software construction for reuse during coding and testing are as follows: Variability implementation with mechanisms such as parameterization, conditional compilation, design patterns, and so forth. Variability encapsulation to make the software assets easy to configure and customize. Testing the variability provided by the reusable software assets. Description and publication of reusable software
assets.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Construction_for_Reuse</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Construction for Reuse</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Construction_in_Life_Cycle_Models</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Numerous models have been created to develop software; some emphasize construction more than others. Some models are more linear from the construction point of view such as the waterfall and staged-delivery life cycle models. These models treat construction as an activity that occurs only after significant prerequisite work has been completed including detailed requirements work, extensive design work, and detailed planning. The more linear approaches tend to emphasize the activities that precede construction (requirements and design) and to create more distinct separations between activities. In these models, the
main emphasis of construction may be coding. Other models are more iterative such as evolutionary prototyping and agile development. These approaches tend to treat construction as an activity that occurs concurrently with other software development activities (including requirements, design, and planning) or that overlaps them. These approaches tend to mix design, coding, and testing activities, and they often treat the combination of activities as construction. Consequently, what is considered to be “construction” depends to some degree on the life cycle model used. In general, software construction is mostly coding and debugging, but
it also involves construction planning, detailed design, unit testing, integration testing, and other activities.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Construction_in_Life_Cycle_Models</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Construction in Life Cycle Models</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Construction_with_Reuse</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Construction with reuse means to create new software with the reuse of existing software assets. The most popular method of reuse is to reuse code from the libraries provided by the language, platform, tools being used, or an organizational
repository. Asides from these, the applications developed today widely make use of many open-source libraries. Reused and off-the-shelf software often have the same or better quality requirements as newly developed software (for example, security level). The tasks related to software construction with reuse during coding and testing are as follows: The selection of the reusable units, databases, test procedures, or test data; The evaluation of code or test reusability; The integration of reusable software assets into the current software; The reporting of reuse information on new code, test procedures, or test data.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Construction_with_Reuse</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Construction with Reuse</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Context_of_Software_Design</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software design is an important part of the software development process. To understand the role of software design, we must see how it fits in the software development life cycle. Thus, it is important to understand the major characteristics
of software requirements analysis, software design, software construction, software testing, and software maintenance.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Context_of_Software_Design</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Context of Software Design</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Continuous_and_Staged_Software_Process_Ratings</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software process capability and software process maturity are typically rated using five or six levels to characterize the capability or maturity of the software processes used within an organization. A continuous rating system involves assigning
a rating to each software process of interest; a staged rating system is established by assigning the same maturity rating to all of the software processes within a specified process level.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Continuous_and_Staged_Software_Process_Ratings</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Continuous and Staged Software Process Ratings</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Control_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The outcomes of project monitoring activities provide the basis on which decisions can be made. Where appropriate, and when the probability and impact of risk factors are understood, changes can be made to the project. This may take the form of corrective action (for example, retesting certain software components); it may involve incorporating additional actions (for example, deciding to use prototyping to assist in software requirements validation); and/or it may entail revision of the project plan and other project documents (for example, the software requirements specification) to accommodate unanticipated events and their implications. In some instances, the control process may lead to abandonment of the project. In all cases, software configuration control and software configuration
management procedures should be adhered to, decisions should be documented
and communicated to all relevant parties, plans should be revisited and revised when necessary, and relevant data recorded.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Control_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Control Process</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Control_and_Handling_of_Events</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">This design issue is concerned with how to organize data and control flow as well as how to handle reactive and temporal events through various mechanisms such as implicit invocation and call-backs.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Control_and_Handling_of_Events</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Control and Handling of Events</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Controlling</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Controlling is an element of finance and accounting. Controlling involves measuring and correcting the performance of finance and accounting. It ensures that an organization’s objectives and plans are accomplished. Controlling cost is a specialized branch of controlling used to detect variances of actual costs from planned costs.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Controlling</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Controlling</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Core_Basic_Content</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Required by opinion CNE / CES 136 of 2012 (Curricular Guidelines for Graduation in Computing).

Content Core: Scientific and Technological Methodology, Communication and Expression, Graphic Expression, Mathematics, Physics, Production, Innovation, Administration, Economics, Environmental Sciences, Humanities, Social Sciences, Citizenship</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Core_Basic_Content</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Core Basic Content (BC)</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Core_Professional_Content</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Disciplines with basic vocational content that allow to reach the basic elements of the professional profile of the egress.

Content Core: Programming Logic, Algorithms and Data Structure, Digital Circuits, Computing, Programming Language, Database.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Core_Professional_Content</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Core Professional Content</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Core_Specific_Content</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Courses addressing the fundamentals and specific topics of Software Engineering, as well as other specific contents aimed at the development of specific or complementary skills and abilities in the area of programming, product and software process

Content Core: Specific disciplines for software engineering</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Core_Specific_Content</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Core Specific Content</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Cost_Benefit_Analysis</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Cost-benefit analysis is one of the most widely used methods for evaluating individual proposals. Any proposal with a benefit-cost ratio of less than 1.0 can usually be rejected without further analysis because it would cost more than the benefit. Proposals with a higher ratio need to consider the associated risk of an investment and compare the benefits with the option of investing the money at a guaranteed interest rate.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Cost_Benefit_Analysis</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Cost-Benefit Analysis</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Cost_Effectiveness_Analysis</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Cost-effectiveness analysis is similar to costbenefit analysis. There are two versions of costeffectiveness analysis: the fixed-cost version maximizes the benefit given some upper bound on cost; the fixed-effectiveness version minimizes the cost needed to achieve a fixed goal.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Cost_Effectiveness_Analysis</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Cost-Effectiveness Analysis</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Cost_and_Costing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A cost is the value of money that has been used up to produce something and, hence, is not available for use anymore. In economics, a cost is an alternative that is given up as a result of a decision. A sunk cost is the expenses before a certain time, typically used to abstract decisions from expenses in the past, which can cause emotional hurdles in looking forward. From a traditional economics point of view, sunk costs should not be considered in decision making. Opportunity cost is the cost of an alternative that must be forgone in order to pursue another alternative.
Costing is part of finance and product management. It is the process to determine the cost based on expenses (e.g., production, software engineering, distribution, rework) and on the target cost to be competitive and successful in a market. The target cost can be below the actual estimated cost. The planning and controlling of these costs (called cost management) is important and should always be included in costing. An important concept in costing is the total cost of ownership (TCO). This holds especially for software, because there are many not-so-obvious costs related to SPLC activities after initial product development. TCO for a software product is defined as the total cost for acquiring, activating, and keeping that product running. These costs can be grouped as direct and indirect costs. TCO is an accounting method that is crucial in making sound economic decisions.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Cost_and_Costing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Cost and Costing</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Course_Completion_Work</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Completion of course work that can be done individually or in double, demonstrating the ability of both teamwork of participants, as well as synthesis, integration and deepening of the knowledge acquired throughout the course. The performance is verified through standardized document and public defense before an examining bank.

The work consists of the development, by the student, of a study or engineering project that allows the integrated application of knowledge related to the course. In its development, the methodology, content of the topic, written documentation and oral presentation should be observed. The TCC aims to provide students with the ability to solve and (or) investigate problem (s) in Software Engineering in a global and objective way, implying in an improvement of their ability to prepare a technical document and its ability to express oral in public.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Course_Completion_Work</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Course Completion Work 1 and 2 (CBT)</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Curriculum</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Curriculum</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Data_Management</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A database must manage the data stored in it. This management includes both organization and storage. The organization of the actual data in a database depends on the database model. In a relational model, data are organized as tables with different tables representing different entities or relations among a set of entities. The storage of data deals with the storage of these database tables on disks. The common ways for achieving this is to use files. Sequential, indexed, and hash files are all used in this purpose with different file structures providing different access performance and convenience.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Data_Management</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Data Management</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Data_Mining</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">One often has to know what to look for before querying a database. This type of “pinpointing” access does not make full use of the vast amount of information stored in the database, and in fact reduces the database into a collection of discrete
records. To take full advantage of a database, one can perform statistical analysis and pattern discovery on the content of a database using a technique called data mining. Such operations can be used to support a number of business activities
that include, but are not limited to, marketing, fraud detection, and trend analysis.
Numerous ways for performing data mining have been invented in the past decade and include such common techniques as class description, class discrimination, cluster analysis, association analysis, and outlier analysis.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Data_Mining</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Data Mining</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Data_Persistence</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">This design issue is concerned with how to handle long-lived data.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Data_Persistence</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Data Persistence</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Data_Structure_Centered_Design</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Data structure-centered design starts from the data structures a program manipulates rather than from the function it performs. The software engineer first describes the input and output data structures and then develops the program’s control structure based on these data structure diagrams. Various heuristics have been proposed to deal with special cases for example, when there is a mismatch between the input and output structures</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Data_Structure_Centered_Design</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Data Structure-Centered Design</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Data_Structure_Overview</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Data structures are computer representations of data. Data structures are used in almost every program. In a sense, no meaningful program can be constructed without the use of some sort of data structure. Some design methods and programming languages even organize an entire software system around data structures. Fundamentally, data structures are abstractions defined on a collection of data and its associated operations. Often, data structures are designed for improving program or algorithm efficiency. Examples of such data structures include stacks, queues, and heaps. At other times, data structures are used for
conceptual unity (abstract data type), such as the name and address of a person. Often, a data structure can determine whether a program runs in a few seconds or in a few hours or even a few days. From the perspective of physical and logical
ordering, a data structure is either linear or nonlinear. Other perspectives give rise to different classifications that include homogeneous vs. heterogeneous, static vs. dynamic, persistent vs. transient, external vs. internal, primitive vs. aggregate, recursive vs. nonrecursive; passive vs. active; and stateful vs. stateless structures.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Data_Structure_Overview</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Data Structure Overview</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Data_Structure_and_Representation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Programs work on data. But data must be expressed and organized within computers before being processed by programs. This organization and expression of data for programs’ use is the subject of data structure and representation. Simply
put, a data structure tries to store and organize data in a computer in such a way that the data can be used efficiently. There are many types of data structures and each type of structure is suitable for some kinds of applications. For example, B/B+ trees are well suited for implementing massive file systems and databases.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Data_Structure_and_Representation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Data Structure and Representation</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Database_Basics_and_Data_Management</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A database consists of an organized collection of data for one or more uses. In a sense, a database is a generalization and expansion of data structures. But the difference is that a database is usually external to individual programs and permanent in existence compared to data structures. Databases are used when the data volume is large or logical relations between data items are important. The factors considered in database design include performance, concurrency, integrity, and recovery from hardware failures.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Database_Basics_and_Data_Management</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Database Basics and Data Management</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Database_Management_Systems</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Database Management System (DBMS) components include database applications for the storage of structured and unstructured data and the required database management functions needed to view, collect, store, and retrieve data from the databases. A DBMS controls the creation, maintenance, and use of the database and is usually categorized according to the database model it supports such as the relational, network, or object model. For example, a relational database management system (RDBMS) implements features of the relational model. An object database management system (ODBMS) implements features of the object model.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Database_Management_Systems</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Database Management Systems (DBMS)</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Database_Query_Language</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Users/applications interact with a database through a database query language, which is a specialized programming language tailored to database use. The database model tends to determine the query languages that are available to access
the database. One commonly used query language for the relational database is the structured query language, more commonly abbreviated as SQL. A common query language for object databases is the object query language (abbreviated as OQL). There are three components of SQL: Data Definition Language (DDL), Data Manipulation Language (DML), and Data Control Language (DCL).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Database_Query_Language</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Database Query Language</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Dealing_with_Multicultural_Environments</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Multicultural environments can have an impact on the dynamics of a group. This is especially true when the group is geographically separated or communication is infrequent, since such separation elevates the importance of each contact. Intercultural communication is even more difficult if the difference in time zones make oral communication less frequent. Multicultural environments are quite prevalent in software engineering, perhaps more than in other fields of engineering, due to the strong trend of international outsourcing and the easy shipment of software components instantaneously across the globe. For example, it is rather common for a software project to be divided into pieces across national and cultural borders, and it is also quite common for a software project team to consist of people from diverse cultural backgrounds. For a software project to be a success, team members must achieve a level of tolerance, acknowledging that some rules depend on societal norms and that not all societies derive the same solutions and expectations. This tolerance and accompanying understanding can be facilitated by the support of leadership and management. More frequent communication, including face-to-face meetings, can help to mitigate geographical and cultural divisions, promote cohesiveness, and raise productivity. Also, being able to communicate with teammates in their native language could be very beneficial.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Dealing_with_Multicultural_Environments</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Dealing with Multicultural Environments</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Dealing_with_Problem_Complexity</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Many, if not most, software engineering problems are too complex and difficult to address as a whole or to be tackled by individual software engineers. When such circumstances arise, the usual means to adopt is teamwork and problem decomposition. Teams work together to deal with complex and large problems by sharing burdens and drawing upon each other’s knowledge and creativity. When software engineers work in teams, different views and abilities of the individual engineers complement each other and help build a solution that is otherwise difficult to come by. Some specific teamwork examples to software engineering
are pair programming.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Dealing_with_Problem_Complexity</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Dealing with Problem Complexity</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Dealing_with_Uncertainty_and_Ambiguity</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">As with engineers of other fields, software engineers must often deal with and resolve uncertainty and ambiguities while providing services and developing products. The software engineer must attack and reduce or eliminate any lack of
clarity that is an obstacle to performing work. Often, uncertainty is simply a reflection of lack of knowledge. In this case, investigation through recourse to formal sources such as textbooks and professional journals, interviews with stakeholders, or consultation with teammates and peers can overcome it. When uncertainty or ambiguity cannot be overcome easily, software engineers or organizations may choose to regard it as a project risk. In this case, work estimates or pricing are adjusted to mitigate the anticipated cost of addressing it.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Dealing_with_Uncertainty_and_Ambiguity</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Dealing with Uncertainty and Ambiguity</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Debugging_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Debugging involves many activities and can be static, dynamic, or postmortem. Static debugging usually takes the form of code review, while dynamic debugging usually takes the form of tracing and is closely associated with testing. Postmortem debugging is the act of debugging the core dump (memory dump) of a process. Core dumps are often generated after a process has terminated due to an unhandled exception. All three techniques are used at various stages of program
development. The main activity of dynamic debugging is tracing, which is executing the program one piece at a time, examining the contents of registers and
memory, in order to examine the results at each step. There are three ways to trace a program. Single-stepping: execute one instruction at a time to make sure each instruction is executed correctly. This method is tedious but useful in verifying each step of a program. Breakpoints: tell the program to stop executing when it reaches a specific instruction. This technique lets one quickly execute selected code sequences to get a high-level overview of the execution behavior. Watch points: tell the program to stop when a register or memory location changes or when it equals to a specific value. This technique is useful when one doesn’t know where or when a value is changed and when this value change likely causes the error.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Debugging_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Debugging Techniques</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Debugging_Tools</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Debugging can be complex, difficult, and tedious. Like programming, debugging is also highly creative (sometimes more creative than programming). Thus some help from tools is in order. For dynamic debugging, debuggers are widely used and enable the programmer to monitor the execution of a program, stop the execution, restart the execution, set breakpoints, change values in memory, and even, in some cases, go back in time. For static debugging, there are many static code analysis tools, which look for a specific set of known problems within the source code.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Debugging_Tools</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Debugging Tools</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Debugging_Tools_and_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Once a program is coded and compiled, the next step is debugging, which is a methodical process of finding and reducing the number of bugs or faults in a program. The purpose of debugging is to find out why a program doesn’t work or produces a wrong result or output. Except for very simple programs, debugging is always necessary.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Debugging_Tools_and_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Debugging Tools and Techniques</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Decision_Making_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">If we assume that candidate solutions solve a given technical problem equally well, why should the organization care which one is chosen? The answer is that there is usually a large difference in the costs and incomes from the different solutions. A commercial, off-the-shelf, objectrequest broker product might cost a few thousand dollars, but the effort to develop a homegrown service that gives the same functionality could easily cost several hundred times that amount. If the candidate solutions all adequately solve the problem from a technical perspective, then
the selection of the most appropriate alternative should be based on commercial factors such as optimizing total cost of ownership (TCO) or maximizing the short-term return on investment (ROI). Life cycle costs such as defect correction,
field service, and support duration are also relevant considerations. These costs need to be factored in when selecting among acceptable technical approaches, as they are part of the lifetime ROI. A systematic process for making decisions will
achieve transparency and allow later justification. Governance criteria in many organizations demand selection from at least two alternatives. It starts with a business challenge at hand and describes the steps to identify alternative solutions,
define selection criteria, evaluate the solutions, implement one selected solution, and monitor the performance of that solution.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Decision_Making_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Decision-Making Process</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Decisions_under_Risk</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Decisions under risk techniques are used when the decision maker can assign probabilities to the different possible outcomes. The specific techniques include  expected value decision making, expectation variance and decision making, Monte Carlo analysis, decision trees, expected value of perfect information.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Decisions_under_Risk</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Decisions under Risk</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Decisions_under_Uncertainty</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Decisions under uncertainty techniques are used when the decision maker cannot assign probabilities to the different possible outcomes because needed information is not available. Specific techniques include, Laplace Rule, Maximin Rule, Maximax Rule, Hurwicz Rule, Minimax Regret Rule.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Decisions_under_Uncertainty</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Decisions under Uncertainty</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Declarative_vs_Imperative_Programming_Languages</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Most programming languages (high-level or lowlevel) allow programmers to specify the individual instructions that a computer is to execute. Such programming languages are called imperative programming languages because one has to specify every step clearly to the computer. But some programming languages allow programmers to only describe the function to be performed without specifying the exact instruction sequences to be executed. Such programming languages are called declarative programming languages. Declarative languages are high-level languages. The actual implementation of the
computation written in such a language is hidden from the programmers and thus is not a concern for them. The key point to note is that declarative programming
only describes what the program should accomplish without describing how to
accomplish it. For this reason, many people believe declarative programming facilitates easier software development. Declarative programming languages include Lisp (also a functional programming language) and Prolog, while
imperative programming languages include C, C++, and JAVA.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Declarative_vs_Imperative_Programming_Languages</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Declarative vs. Imperative Programming Languages</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Defect_Characterization</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software quality evaluation (i.e., software quality control) techniques find defects, faults and failures. Characterizing these techniques leads to an understanding of the product, facilitates corrections to the process or the product, and informs management and other stakeholders of the status of the process or product. Defect characterization is also used in audits and reviews, with the review leader often presenting a list of issues provided by team members for consideration at a review meeting. However, different engineering cultures and standards may use somewhat different meanings for these terms. The variety of terms prompts this section to provide a widely used set of definitions: Computational Error: “the difference between a computed, observed, or measured value or condition and the true, specified, or theoretically correct value or condition.” Error: “A human action that produces an incorrect result.” A slip or mistake that a person makes. Also called human error. Defect: An “imperfection or deficiency in a work product where that work product does not meet its requirements or specifications and needs to be either repaired or replaced.” A defect is caused by a person committing an error. Fault: A defect in source code. An “incorrect step, process, or data definition in computer program.” The encoding of a human error in source code. Fault is the formal name of a bug. Failure: An “event in which a system or system component does not perform a required function within specified limits.” A failure is produced when a fault is encountered by the processor under specified conditions.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Defect_Characterization</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Defect Characterization</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Definition_of_Problem_Solving</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Problem solving refers to the thinking and activities conducted to answer or derive a solution to a problem. There are many ways to approach a problem, and each way employs different tools and uses different processes. These different ways of approaching problems gradually expand and define themselves and finally give rise to different disciplines. For example, software engineering focuses on solving problems using computers and software. While different problems warrant different solutions and may require different tools and processes, the methodology and techniques used in solving problems do follow some guidelines and can often be generalized as problem solving techniques. For example, a general guideline for
solving a generic engineering problem is to use the three-step process given below: Formulate the real problem; Analyze the problem; Design a solution search strategy.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Definition_of_Problem_Solving</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Definition of Problem Solving</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Definition_of_a_Software_Requirement</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">At its most basic, a software requirement is a property that must be exhibited by something in order to solve some problem in the real world. It may aim to automate part of a task for someone to support the business processes of an organization, to correct shortcomings of existing software, or to control a device to name just a few of the many problems for which software solutions are possible. The ways in which users, business processes, and devices function are typically complex. By extension, therefore, the requirements on particular software are typically a complex combination from various people at different levels of an organization, and who are in one way or another involved or connected with this feature from the environment in which the software will operate.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Definition_of_a_Software_Requirement</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Definition of a Software Requirement</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Definitions_and_Terminology</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">In the context of software engineering, software maintenance is essentially one of the many technical processes. The objective of software maintenance is to modify existing software while preserving its integrity. The international standard also states the importance of having some maintenance activities prior to the final delivery of software (predelivery activities). Notably, IEEE 14764 emphasizes the importance of the predelivery aspects of maintenance planning, for example.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Definitions_and_Terminology</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Definitions and Terminology</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Design_Patterns</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Succinctly described, a pattern is “a common solution to a common problem in a given context”. While architectural styles can be viewed as patterns describing the high-level organization of software, other design patterns can be used to describe details at a lower level. These lower level design patterns include the following: Creational patterns (for example, builder, factory, prototype, singleton); Structural patterns (for example, adapter, bridge, composite, decorator, façade, flyweight,
proxy); Behavioral patterns (for example, command, interpreter, iterator, mediator, memento, observer, state, strategy, template, visitor).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Design_Patterns</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Design Patterns</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Design_a_Solution_Search_Strategy</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Once the problem analysis is complete, we can focus on structuring a search strategy to find the solution. In order to find the “best” solution (here, “best” could mean different things to different people, such as faster, cheaper, more usable, different capabilities, etc.), we need to eliminate paths that do not lead to viable solutions, design tasks in a way that provides the most guidance in searching for a solution, and use various attributes of the final solution state to guide our choices in the problem solving process.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Design_a_Solution_Search_Strategy</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Design a Solution Search Strategy</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Design_as_a_Problem_Solving_Activity</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">It is to be noted that engineering design is primarily a problem solving activity. Design problems are open ended and more vaguely defined. There are usually several alternative ways to solve the same problem. Design is generally considered to be a wicked problem a term first coined by Horst Rittel in the 1960s when design methods were a subject of intense interest. Rittel sought an alternative to the linear, step-by-step model of the design process being explored by many designers and
design theorists and argued that most of the problems addressed by the designers are wicked problems. As explained by Steve McConnell, a wicked problem is one that could be clearly defined only by solving it or by solving part of it. This paradox
implies, essentially, that a wicked problem has to be solved once in order to define it clearly and then solved again to create a solution that works. This has been an important insight for software designers for several decades.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Design_as_a_Problem_Solving_Activity</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Design as a Problem Solving Activity</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Designed_Experiment</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A designed or controlled experiment is an investigation of a testable hypothesis where one or more independent variables are manipulated to measure their effect on one or more dependent variables. A precondition for conducting an experiment is the existence of a clear hypothesis. It is important for an engineer to understand how to formulate clear hypotheses. Designed experiments allow engineers to determine in precise terms how the variables are related and, specifically, whether a cause-effect relationship exists between them. Each combination of values of the independent variables is a treatment. The simplest experiments have just two treatments representing two levels of a single independent variable (e.g., using a tool vs. not using a tool). More complex experimental designs arise when more than two levels, more than one independent variable, or any dependent variables are used.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Designed_Experiment</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Designed Experiment</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Determination_and_Negotiation_of_Requirements</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Determining and negotiating requirements set the visible boundaries for the set of tasks being undertake. Activities include requirements elicitation, analysis, specification, and validation. Methods and techniques should be selected and applied, taking into account the various stakeholder perspectives. This leads to the determination of project scope in order to meet objectives and satisfy constraints.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Determination_and_Negotiation_of_Requirements</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Determination and Negotiation of Requirements</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Determine_Deliverables</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The work product(s) of each project activity (for example, software architecture design documents, inspection reports, tested software) should be identified and characterized. Opportunities to reuse software components from previous projects
or to utilize off-the-shelf software products should be evaluated. Procurement of software and use of third parties to develop deliverables should be planned and suppliers selected.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Determine_Deliverables</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Determine Deliverables</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Determining_Closure</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Closure occurs when the specified tasks for a project, a phase, or an iteration have been completed and satisfactory achievement of the completion criteria has been confirmed. Software requirements can be confirmed as satisfied or not, and the degree of achieving the objectives can be determined. Closure processes should involve relevant stakeholders and result in documentation of relevant stakeholders’ acceptance; any known problems should be documented.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Determining_Closure</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Determining Closure</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Determining_Satisfaction_of_Requirements</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Because achieving stakeholder satisfaction is a principal goal of the software engineering manager, progress towards this goal should be assessed periodically. Progress should be assessed on achievement of major project milestones (for example, completion of software design architecture or completion of a software technical review), or upon completion of an iterative development cycle that results in a product increment. Variances from software requirements should be identified and appropriate actions should be taken. As in the control process activity above, software configuration control and software configuration management procedures should be followed, decisions documented and communicated to all relevant parties, plans revisited and revised where necessary, and relevant data recorded.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Determining_Satisfaction_of_Requirements</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Determining Satisfaction of Requirements</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Development_Environments</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A development environment, or integrated development environment (IDE), provides comprehensive facilities to programmers for software construction by integrating a set of development tools. The choices of development environments
can affect the efficiency and quality of software construction. In additional to basic code editing functions, modern IDEs often offer other features like compilation and error detection from within the editor, integration with source code control, build/
test/debugging tools, compressed or outline views of programs, automated code transforms, and support for refactoring.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Development_Environments</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Development Environments</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Deviations_and_Waivers</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The constraints imposed on a software engineering effort or the specifications produced during the development activities might contain provisions that cannot be satisfied at the designated point in the life cycle. A deviation is a written authorization, granted prior to the manufacture of an item, to depart from a particular performance or design requirement for a specific number of units or a specific period of time. A waiver is a written authorization to accept a configuration item or other designated item that is found, during production or after having been submitted for inspection, to depart from specified requirements but is nevertheless
considered suitable for use as-is or after rework by an approved method. In these cases, a formal process is used for gaining approval for deviations from, or waivers of, the provisions.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Deviations_and_Waivers</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Deviations and Waivers</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Difference_between_Parallel_and_Distributed_Computing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Though parallel and distributed computing resemble each other on the surface, there is a subtle but real distinction between them: parallel computing does not necessarily refer to the execution of programs on different computers instead, they
can be run on different processors within a single computer. In fact, consensus among computing professionals limits the scope of parallel computing to the case where a shared memory is used by all processors involved in the computing, while
distributed computing refers to computations where private memory exists for each processor involved in the computations. Another subtle difference between parallel and distributed computing is that parallel computing necessitates concurrent execution of several tasks while distributed computing does not have this necessity. Based on the above discussion, it is possible to classify concurrent systems as being “parallel” or “distributed” based on the existence or nonexistence
of shared memory among all the processor: parallel computing deals with computations within a single computer; distributed computing deals with computations within a set of computers. According to this view, multicore computing is a form of parallel computing.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Difference_between_Parallel_and_Distributed_Computing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Difference between Parallel and Distributed Computing</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Digital_Logic</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Obviously, logics are needed to manipulate data and to control the operation of computers. This logic, which is behind a computer’s proper function, is called digital logic because it deals with the operations of digital zeros and ones. Digital
logic specifies the rules both for building various digital devices from the simplest elements (such as transistors) and for governing the operation of digital devices. For example, digital logic spells out what the value will be if a zero and one is ANDed, ORed, or exclusively ORed together. It also specifies how to build decoders, multiplexers (MUX), memory, and adders that are used to assemble the computer.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Digital_Logic</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Digital Logic</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Digital_Systems</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">At the lowest level, computations are carried out by the electrical and electronic devices within a computer. The computer uses circuits and memory to hold charges that represents the presence or absence of voltage. The presence of voltage
is equal to a 1 while the absence of voltage is a zero. On disk the polarity of the voltage is represented by 0s and 1s that in turn represents the data stored. Everything including instruction and data is expressed or encoded using digital zeros and ones. In this sense, a computer becomes a digital system. For example, decimal value 6 can be encoded as 110, the addition instruction may be encoded as 0001, and so forth. The component of the computer such as the control unit, ALU,
memory and I/O use the information to compute the instructions.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Digital_Systems</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Digital Systems</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Direct_and_Derived_Measures</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Measures may be either direct or derived (sometimes called indirect measures). An example of a direct measure would be a count of how many times an event occurred, such as the number of defects found in a software product. A derived
measure is one that combines direct measures in some way that is consistent with the measurement method. An example of a derived measure would be calculating the productivity of a team as the number of lines of code developed per developermonth. In both cases, the measurement method determines how to make the measurement.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Direct_and_Derived_Measures</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Direct and Derived Measures</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Discrete_Probability</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Probability is the mathematical description of randomness. Here, let us start with the concepts behind probability distribution and discrete probability. A probability model is a mathematical description of a random phenomenon consisting of two
parts: a sample space S and a way of assigning probabilities to events. The sample space defines the set of all possible outcomes, whereas an event is a subset of a sample space representing a possible outcome or a set of outcomes. A random variable is a function or rule that assigns a number to each outcome. Basically, it
is just a symbol that represents the outcome of an experiment.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Discrete_Probability</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Discrete Probability</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Distribution_of_Components</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">This design issue is concerned with how to distribute the software across the hardware (including computer hardware and network hardware), how the components communicate, and how middleware can be used to deal with heterogeneous software.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Distribution_of_Components</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Distribution of Components</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Divisibility</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Let’s start this section with a brief description of each of the above types of numbers: Natural Numbers; Whole Numbers; Integers; Rational Numbers; Irrational Numbers; Real Numbers; Imaginary Numbers; Complex Numbers.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Divisibility</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Divisibility</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Documentation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Providing clear, thorough, and accurate documentation is the responsibility of each software engineer. The adequacy of documentation is judged by different criteria based on the needs of the various stakeholder audiences. Good documentation complies with accepted standards and guidelines. In particular, software engineers should document relevant facts, significant risks and tradeoffs, and warnings of undesirable or dangerous consequences from use or misuse of the software. Software engineers should avoid certifying or approving unacceptable products, disclosing confidential information, or falsifying facts or data. In addition, software engineers and their managers should notably provide the following documentation for use by other elements of the software development organization: software requirements specifications, software design documents, details on the software engineering tools used, software test specifications and results, and details on the adopted software engineering methods; problems encountered during the development process. For external stakeholders (customer, users, others) software documentation should notably provide information needed to determine if the software is likely to meet the customer’s and users’ needs, description of the safe, and unsafe, use of the software, description of the protection of sensitive information created by or stored using the software, and clear identification of warnings and critical procedures. Use of software may include installation, operation, administration, and performance of other functions by various groups of users and support personnel.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Documentation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Documentation</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Dynamics_of_Working_in_Teams_Groups</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software engineers must work with others. On one hand, they work internally in engineering teams; on the other hand, they work with customers, members of the public, regulators, and other stakeholders. Performing teams those that demonstrate consistent quality of work and progress toward goals are cohesive and possess a cooperative, honest, and focused atmosphere. Individual and team goals are aligned so that the members naturally commit to and feel ownership of shared outcomes. Team members facilitate this atmosphere by being intellectually honest, making use of group thinking, admitting ignorance, and acknowledging mistakes. They share responsibility, rewards, and workload fairly. They take care to communicate clearly, directly to each other and in documents, as well as in source code, so that information is accessible to everyone. Peer reviews about work products are framed in a constructive and nonpersonal way. This allows all the members to pursue a cycle of continuous improvement and growth without personal risk. In general, members of cohesive teams demonstrate respect for each other and their leader. One point to emphasize is that software engineers must be able to work in multidisciplinary environments and in varied application domains.
Since today software is everywhere, from a phone to a car, software is impacting people’s lives far beyond the more traditional concept of software made for information management in a business environment.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Dynamics_of_Working_in_Teams_Groups</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Dynamics of Working in Teams/Groups</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Earned_Value_Management</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Earned value management (EVM) is a project management technique for measuring progress based on created value. At a given moment, the results achieved to date in a project are compared with the projected budget and the planned schedule progress for that date. Progress relates already-consumed resources and achieved results at a given point in time with the respective planned values for the same date. It helps to identify possible performance problems at an
early stage. A key principle in EVM is tracking cost and schedule variances via comparison of planned versus actual schedule and budget versus actual cost. EVM tracking gives much earlier visibility to deviations and thus permits corrections earlier than classic cost and schedule tracking that only looks at delivered documents and products.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Earned_Value_Management</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Earned Value Management</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Economic_Analysis_Methods</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Economic Analysis Methods</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Economic_Impact_of_Software</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software has economic effects at the individual, business, and societal levels. Software “success” may be determined by the suitability of a product for a recognized problem as well as by its effectiveness when applied to that problem.
At the individual level, an engineer’s continuing employment may depend on their ability and willingness to interpret and execute tasks in meeting customers’ or employers’ needs and expectations. The customer or employer’s financial
situation may in turn be positively or negatively affected by the purchase of software. At the business level, software properly applied to a problem can eliminate months of work and translate to elevated profits or more effective
organizations. Moreover, organizations that acquire or provide successful software may be a boon to the society in which they operate by providing both employment and improved services. However, the development or acquisition costs of software can also equate to those of any major acquisition. At the societal level, direct impacts of software success or failure include or exclude accidents, interruptions, and loss of service. Indirect impacts include the success or failure of the organization that acquired or produced the software, increased or decreased societal productivity, harmonious or disruptive social order, and even the saving or
loss of property and life.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Economic_Impact_of_Software</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Economic Impact of Software</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Ecosystems</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">An ecosystem is an environment consisting of all the mutually dependent stakeholders, business units, and companies working in a particular area. In a typical ecosystem, there are producers and consumers, where the consumers add value to the consumed resources. Note that a consumer is not the end user but an organization that uses the product to enhance it. A software ecosystem is, for instance, a supplier of an application working with companies doing the installation and support in different regions. Neither one could exist without the other. Ecosystems can be permanent or temporary. Software engineering economics provides the mechanisms to evaluate alternatives in establishing or extending an ecosystem for instance, assessing whether to work with a specific
distributor or have the distribution done by a company doing service in an area.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Ecosystems</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Ecosystems</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Effectiveness</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Effectiveness is about having impact. It is the relationship between achieved objectives to defined objectives. Effectiveness means “doing the right things.” Effectiveness looks only at whether defined objectives are reached not at
how they are reached.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Effectiveness</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Effectiveness</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Efficiency</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Economic efficiency of a process, activity, or task is the ratio of resources actually consumed to resources expected to be consumed or desired to be consumed in accomplishing the process, activity, or task. Efficiency means “doing things right.”
An efficient behavior, like an effective behavior, delivers results but keeps the necessary effort to a minimum. Factors that may affect efficiency in software engineering include product complexity, quality requirements, time pressure, process capability, team distribution, interrupts, feature churn, tools, and programming language.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Efficiency</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Efficiency</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Effort_Schedule_and_Cost_Estimation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The estimated range of effort required for a project, or parts of a project, can be determined using a calibrated estimation model based on historical size and effort data (when available) and other relevant methods such as expert judgment and
analogy. Task dependencies can be established and potential opportunities for completing tasks concurrently and sequentially can be identified and documented using a Gantt chart, for example. For predictive SDLC projects, the expected schedule of tasks with projected start times, durations, and end times is typically produced during planning. For adaptive SDLC projects, an overall estimate of effort and schedule is typically developed from the initial understanding of the requirements, or, alternatively, constraints on overall effort and schedule may be specified and used to determine an initial estimate of the number of iterative cycles and estimates of effort and other resources allocated to each cycle. Resource requirements (for example, people and tools) can be translated into cost estimates.
Initial estimation of effort, schedule, and cost is an iterative activity that should be negotiated and revised among affected stakeholders until consensus is reached on resources and time available for project completion.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Effort_Schedule_and_Cost_Estimation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Effort, Schedule, and Cost Estimation</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Elicitation_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Once the requirements sources have been identified, the software engineer can start eliciting requirements information from them. Note that requirements are seldom elicited ready-made. Rather, the software engineer elicits information
from which he or she formulates requirements. This topic concentrates on techniques for getting human stakeholders to articulate requirements relevant information. It is a very difficult task and the software engineer needs to be sensitized to the fact that (for example) users may have difficulty describing their tasks, may leave important information unstated, or may be unwilling or unable to cooperate. It is particularly important to understand that elicitation is not a passive activity and that, even if cooperative and articulate stakeholders are available, the software engineer has to work hard to elicit the right information. Many business or
technical requirements are tacit or in feedback that has yet to be obtained from end users. The importance of planning, verification, and validation in requirements elicitation cannot be overstated. A number of techniques exist for requirements elicitation; the principal ones are these: Interviews, scenarios, prototypes, facilitated meetings, observation, users stories.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Elicitation_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Elicitation Techniques</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Emergent_Properties</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Some requirements represent emergent properties of software that is, requirements that cannot be addressed by a single component but that depend on how all the software components interoperate. The throughput requirement for a call center would, for example, depend on how the telephone system, information system, and the operators all interacted under actual operating conditions. Emergent properties are crucially dependent on the system architecture.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Emergent_Properties</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Emergent Properties</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Emergent_System_Properties</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A system is more than simply the sum of its parts. Thus, the properties of a system are not simply the sum of the properties of its components. Instead, a system often exhibits properties that are properties of the system as a whole. These properties are called emergent properties because they develop only after the integration of constituent parts in the system. Emergent system properties can be either functional or nonfunctional. Functional properties describe the things that a system does. For example, an aircraft’s functional properties include flotation on air, carrying people or cargo, and use as a weapon of mass destruction. Nonfunctional
properties describe how the system behaves in its operational environment. These
can include such qualities as consistency, capacity, weight, security, etc.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Emergent_System_Properties</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Emergent System Properties</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Empirical_Methods_and_Experimental_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">An engineering method for problem solving involves proposing solutions or models of solutions and then conducting experiments or tests to study the proposed solutions or models. Thus, engineers must understand how to create an experiment and then analyze the results of the experiment in order to evaluate the proposed solution. Empirical methods and experimental techniques help the engineer to describe and understand variability in their observations, to identify the sources of variability, and to make decisions. Three different types of empirical studies commonly used in engineering efforts are designed experiments, observational studies, and retrospective studies. Brief descriptions of the commonly
used methods are given below.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Empirical_Methods_and_Experimental_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Empirical Methods and Experimental Techniques</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Employment_Contracts</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software engineering services may be provided under a variety of client-engineer relationships. The software engineering work may be solicited as company-to-customer supplier, engineerto-customer consultancy, direct hire, or even volunteering. In all of these situations, the customer and supplier agree that a product or service will be provided in return for some sort of consideration. Here, we are most concerned with the engineer-to-customer arrangement and its attendant agreements or contracts, whether they are of the direct-hire or consultant variety, and the issues they typically address. A common concern in software engineering contracts is confidentiality. Employers derive commercial advantage from intellectual property, so they strive to protect that property from disclosure. Therefore, software engineers are often required to sign non-disclosure (NDA) or intellectual property (IP) agreements as a precondition to work. These agreements typically apply to information the software engineer could only gain through association with the customer. The terms of these agreements may extend past termination of the association. Another concern is IP ownership. Rights to
software engineering assets products, innovations, inventions, discoveries, and ideas may reside with the employer or customer, either under explicit contract terms or relevant laws, if those assets are obtained during the term of the software
engineer’s relationship with that employer or customer. Contracts differ in the ownership of assets created using non-employer-owned equipment or information.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Employment_Contracts</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Employment Contracts</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Encapsulation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Encapsulation is a mechanism used to implement abstraction. When we are dealing with one level of abstraction, the information concerning the levels below and above that level is encapsulated. This information can be the concept, problem, or observable phenomenon; or it may be the permissible operations on these relevant entities. Encapsulation usually comes with some degree of information hiding in which some or all of the underlying details are hidden from the level above the interface provided by the abstraction. To an object, information hiding means we don’t need to know the details of how the object is represented or how the operations on those objects are implemented.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Encapsulation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Encapsulation</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Engineering_Design</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A product’s life cycle costs are largely influenced by the design of the product. This is true for manufactured products as well as for software products. The design of a software product is guided by the features to be included and the quality attributes
to be provided. It is important to note that software engineers use the term “design” within their own context; while there are some commonalities. The scope of engineering design is generally viewed as much broader than that of software design. The primary aim of this section is to identify the concepts needed to develop a clear understanding regarding the process of engineering design. Many disciplines engage in problem solving activities where there is a single correct solution. In engineering, most problems have many solutions and the focus is on finding a feasible solution (among the many alternatives) that best meets the needs presented. The set of possible solutions is often constrained by explicitly imposed limitations such as cost, available resources, and the state of discipline or domain knowledge. In engineering problems, sometimes there are also implicit constraints (such as the physical properties of materials or laws of physics) that also restrict the set of feasible solutions for a given problem.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Engineering_Design</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Engineering Design</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Engineering_Design_in_Engineering_Education</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The importance of engineering design in engineering education can be clearly seen by the high expectations held by various accreditation bodies for engineering education. Both the Canadian Engineering Accreditation Board and the Accreditation Board for Engineering and Technology (ABET) note the importance of including engineering design in education programs. The Canadian Engineering Accreditation Board includes requirements for the amount of engineering design experience/coursework that is necessary for engineering students as well as qualifications for the faculty members who teach such coursework or supervise design projects. Their accreditation criteria states: Design: An ability to design solutions for complex, open-ended engineering problems and to design systems, components or processes that meet specified needs with appropriate attention to health and safety risks, applicable standards, and economic, environmental, cultural and societal considerations. In a similar manner, ABET defines engineering
design as the process of devising a system, component, or process to meet desired needs. It is a decision-making process (often iterative), in which the basic sciences, mathematics, and the engineering sciences are applied to convert resources optimally to meet these stated needs. Thus, it is clear that engineering design is a
vital component in the training and education for all engineers. The remainder of this section will focus on various aspects of engineering design.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Engineering_Design_in_Engineering_Education</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Engineering Design in Engineering Education</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Engineering_Foundations</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">IEEE defines engineering as “the application of a systematic, disciplined, quantifiable approach to structures, machines, products, systems or processes”. This chapter outlines some of the engineering foundational skills and techniques
that are useful for a software engineer. The focus is on topics that support other KAs while minimizing duplication of subjects covered elsewhere in this document. As the theory and practice of software engineering matures, it is increasingly apparent that software engineering is an engineering discipline that is based on knowledge and skills common to all engineering disciplines. This Engineering
Foundations knowledge area (KA) is concerned with the engineering foundations that apply to software engineering and other engineering disciplines. Topics in this KA include empirical methods and experimental techniques; statistical analysis; measurement; engineering design; modeling, prototyping, and simulation;
standards; and root cause analysis. Application of this knowledge, as appropriate, will allow software engineers to develop and maintain software more efficiently and effectively. Completing their engineering work efficiently and effectively is a goal of all engineers in all engineering disciplines.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Engineering_Foundations</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Engineering Foundations</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Entity_and_Schema</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The things a database tries to model and store are called entities. Entities can be real-world objects such as persons, cars, houses, and so forth, or they may be abstract concepts such as persons, salary, names, and so forth. An entity can be primitive such as a name or composite such as an employee that consists of a name, identification number, salary, address, and so forth. The single most important concept in a database is the schema, which is a description of the entire
database structure from which all other database activities are built. A schema defines the relationships between the various entities that compose a database. For example, a schema for a company payroll system would consist of such things as
employee ID, name, salary rate, address, and so forth. Database software maintains the database according to the schema. Another important concept in database is the database model that describes the type of relationship among various entities. The commonly used models include relational, network, and object models.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Entity_and_Schema</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Entity and Schema</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Error_Handling_Exception_Handling_and_Fault_Tolerance</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The way that errors are handled affects software’s ability to meet requirements related to correctness, robustness, and other nonfunctional attributes. Assertions are sometimes used to check for errors. Other error handling techniques such as returning a neutral value, substituting the next piece of valid data, logging a warning message, returning an error code, or shutting down the software are also used. Exceptions are used to detect and process errors or exceptional events. The basic structure of an exception is that a routine uses throw to throw a detected exception and an exception handling block will catch the exception in a try-catch
block. The try-catch block may process the erroneous condition in the routine or it may return control to the calling routine. Exception handling policies should be carefully designed following common principles such as including in the
exception message all information that led to the exception, avoiding empty catch blocks, knowing the exceptions the library code throws, perhaps building a centralized exception reporter, and standardizing the program’s use of exceptions.
Fault tolerance is a collection of techniques that increase software reliability by detecting errors and then recovering from them if possible or containing their effects if recovery is not possible. The most common fault tolerance strategies
include backing up and retrying, using auxiliary code, using voting algorithms, and replacing an erroneous value with a phony value that will have a benign effect.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Error_Handling_Exception_Handling_and_Fault_Tolerance</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Error Handling, Exception Handling, and Fault Tolerance</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Error_Messages</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">It is understandable that most software contains faults and fails from time to time. But users should be notified if there is anything that impedes the smooth execution of the program. Nothing is more frustrating than an unexpected termination or behavioral deviation of software without any warning or explanation. To be user friendly, the software should report all error conditions to the users or upper-level applications so that some measure can be taken to rectify the situation or to exit gracefully. There are several guidelines that define what constitutes a good error message: error messages should be clear, to the point, and timely. First, error messages should clearly explain what is happening so that users know what is
going on in the software. Second, error messages should pinpoint the cause of the error, if at all possible, so that proper actions can be taken. Third, error messages should be displayed right when the error condition occurs. According to Jakob Nielsen, “Good error messages should be expressed in plain language (no codes), precisely indicate the problem, and constructively suggest a solution”. Fourth, error messages should not overload the users with too much information and cause them to ignore the messages all together. However, messages relating to security access errors should not provide extra information that would help unauthorized persons break in.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Error_Messages</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Error Messages</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Error_and_Exception_Handling_and_Fault_Tolerance</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">This design issue is concerned with how to prevent, tolerate, and process errors and deal with exceptional conditions.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Error_and_Exception_Handling_and_Fault_Tolerance</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Error and Exception Handling and Fault Tolerance</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Establish_and_Sustain_Measurement_Commitment</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Requirements for measurement. Each measurement endeavor should be guided by organizational objectives and driven by a set of measurement requirements established by the organization and the project (for example, an organizational objective might be “first-to-market with new products”). Scope of measurement. The organizational unit to which each measurement requirement is to be applied should be established. This may consist of a functional area, a single project, a single site, or an entire enterprise. The temporal scope of the measurement
effort should also be considered because time series of some measurements may be required; for example, to calibrate estimation models. Team commitment to measurement. The commitment should be formally established, communicated, and supported by resources. Resources for measurement. An organization’s commitment to measurement is an essential factor for success, as evidenced by
the assignment of resources for implementing the measurement process. Assigning resources includes allocation of responsibility for the various tasks of the measurement process (such as analyst and librarian). Adequate funding, training, tools, and support to conduct the process should also be allocated.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Establish_and_Sustain_Measurement_Commitment</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Establish and Sustain Measurement Commitment</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Estimation_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Estimations are used to analyze and forecast the resources or time necessary to implement requirements. Five families of estimation techniques exist: Expert judgment, Analogy, Estimation by parts, Parametric methods, Statistical methods.
No single estimation technique is perfect, so using multiple estimation technique is useful. Convergence among the estimates produced by different techniques indicates that the estimates are probably accurate. Spread among the estimates
indicates that certain factors might have been overlooked. Finding the factors that caused the spread and then reestimating again to produce results that converge could lead to a better estimate.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Estimation_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Estimation Techniques</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Evaluate_Measurement</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Evaluate information products and the measurement process against specified evaluation criteria and determine strengths and weaknesses of the information products or process, respectively. Evaluation may be performed by an internal process or an external audit; it should include feedback from measurement users. Lessons learned should be recorded in an appropriate database. Identify potential improvements. Such improvements may be changes in the format of indicators, changes in units measured, or reclassification of measurement categories. The costs and benefits of potential improvements should be determined and appropriate improvement actions should be reported. Communicate proposed improvements to the measurement process owner and stakeholders for review and approval. Also, lack of potential improvements should be communicated if the analysis fails to identify any improvements.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Evaluate_Measurement</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Evaluate Measurement</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Evaluation_of_the_Program_Under_Test</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Measures based on software size (for example, source lines of code or functional size) or on program structure can be used to guide testing. Structural measures also include measurements that determine the frequency with which modules call one another. The testing literature is rich in classifications and taxonomies of faults. To make testing more effective, it is important to know which types of faults may be found in the software under test and the relative frequency with which these faults have occurred in the past. This information can be useful in making quality predictions as well as in process improvement. A program under test can be evaluated by counting discovered faults as the ratio between the number of faults found and the size of the program. A statistical estimate of software reliability,
which can be obtained by observing reliability achieved, can be used to evaluate a software product and decide whether or not testing can be stopped. Reliability growth models provide a prediction of reliability based on failures. They assume, in general, that when the faults that caused the observed failures have been fixed (although some models also accept imperfect fixes), the estimated product’s
reliability exhibits, on average, an increasing trend. There are many published reliability growth models. Notably, these models are divided into failure-count and time-between-failure models.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Evaluation_of_the_Program_Under_Test</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Evaluation of the Program Under Test</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Evaluation_of_the_Tests_Performed</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Several test adequacy criteria require that the test cases systematically exercise a set of elements identified in the program or in the specifications. To evaluate the thoroughness of the executed tests, software engineers can monitor the elements covered so that they can dynamically measure the ratio between covered elements and the total number. For example, it is possible to measure the percentage of branches covered in the program flow graph or the percentage of functional requirements exercised among those listed in the specifications document. Code-based adequacy criteria require appropriate instrumentation of the program under test. In fault seeding, some faults are artificially introduced into a program before testing. When the tests are executed, some of these seeded faults will be revealed as well as, possibly, some faults that were already there. In theory, depending on which and how many of the artificial faults are discovered, testing effectiveness can be evaluated and the remaining number of genuine faults can be estimated. In practice, statisticians question the distribution and representativeness of seeded faults relative to genuine faults and the small sample size on which any extrapolations are based. Some also argue that this technique should be used with great care since inserting faults into software involves the obvious risk of leaving them there. In mutation testing, the ratio of killed mutants to the total number of generated mutants can be a measure of the effectiveness of the executed test set. Several studies have been conducted to compare the relative effectiveness of different testing techniques. It is important to be precise as to the property against which the techniques are being assessed; what, for instance, is the exact meaning
given to the term “effectiveness”? Possible interpretations include the number of tests needed to find the first failure, the ratio of the number of faults found through testing to all the faults found during and after testing, and how much reliability was improved. Analytical and empirical comparisons between different techniques have been conducted according to each of the notions of effectiveness specified above.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Evaluation_of_the_Tests_Performed</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Evaluation of the Tests Performed</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Evolution_of_Software</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software maintenance in terms of evolution was first addressed in the late 1960s. Over a period of twenty years, research led to the formulation of eight “Laws of Evolution.” Key findings include a proposal that maintenance is evolutionary development and that maintenance decisions are aided by understanding what happens to software over time. Some state that maintenance is continued development, except that there is an extra input (or constraint)–in other words, existing large software is never complete and continues to evolve; as it evolves, it grows more complex unless some action is taken to reduce this complexity.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Evolution_of_Software</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Evolution of Software</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Executable_Models</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Executable models abstract away the details of specific programming languages and decisions about the organization of the software. Different from traditional software models, a specification built in an executable modeling language like
xUML (executable UML) can be deployed in various software environments without change. An executable-model compiler (transformer) can turn an executable model into an implementation using a set of decisions about the target hardware and software environment. Thus, constructing executable models can be regarded as a way of constructing executable software. Executable models are one foundation supporting the Model-Driven Architecture (MDA) initiative of the Object Management Group (OMG). An executable model is a way to completely specify
a Platform Independent Model (PIM); a PIM is a model of a solution to a problem that does not rely on any implementation technologies. Then a Platform Specific Model (PSM), which is a model that contains the details of the implementation,
can be produced by weaving together the PIM and the platform on which it relies.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Executable_Models</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Executable Models</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Extension_Activities</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Courses in the technical or business management area, foreign language courses, extension projects with the community Institutional Program of Extension Scholarships (PIBEX), Continuous Action Extension Projects (PEAC), participation in Engineering Week;</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Extension_Activities</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Extension Activities</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Families_of_Programs_and_Frameworks</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">One approach to providing for reuse of software designs and components is to design families of programs, also known as software product lines. This can be done by identifying the commonalities among members of such families and by designing reusable and customizable components to account for the variability among family members. In object-oriented (OO) programming, a key related notion is that of a framework: a partially completed software system that can be extended by appropriately instantiating specific extensions (such as plug-ins).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Families_of_Programs_and_Frameworks</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Families of Programs and Frameworks</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Fault_Based_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">With different degrees of formalization, faultbased testing techniques devise test cases specifically aimed at revealing categories of likely or predefined faults. To better focus the test case generation or selection, a fault model can be introduced that classifies the different types of faults. In error guessing, test cases are specifically designed by software engineers who try to anticipate the most plausible faults in a given program. A good source of information is the history of faults discovered in earlier projects, as well as the software engineer’s expertise. A mutant is a slightly modified version of the program under test, differing from it by a small
syntactic change. Every test case exercises both the original program and all generated mutants: if a test case is successful in identifying the difference
between the program and a mutant, the latter is said to be “killed.” Originally conceived as a technique to evaluate test sets, mutation testing is also a testing criterion in itself: either tests are randomly generated until enough mutants have been killed, or tests are specifically designed to kill surviving mutants. In the latter
case, mutation testing can also be categorized as a code-based technique. The underlying assumption of mutation testing, the coupling effect, is that by looking for simple syntactic faults, more complex but real faults will be found. For
the technique to be effective, a large number of mutants must be automatically generated and executed in a systematic way.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Fault_Based_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Fault-Based Techniques</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Feasibility_Analysis</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The purpose of feasibility analysis is to develop a clear description of project objectives and evaluate alternative approaches in order to determine whether the proposed project is the best alternative given the constraints of technology, resources, finances, and social/political considerations. An initial project and product scope statement, project deliverables, project duration constraints, and an estimate of resources needed should be prepared. Resources include a sufficient number of people who have the needed skills, facilities, infrastructure, and support (either internally or externally). Feasibility analysis often requires approximate estimations of effort and cost based on appropriate methods.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Feasibility_Analysis</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Feasibility Analysis</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Finance</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Finance is the branch of economics concerned with issues such as allocation, management, acquisition, and investment of resources. Finance is an element of every organization, including software engineering organizations. The field of finance deals with the concepts of time, money, risk, and how they are interrelated. It also deals with how money is spent and budgeted. Corporate finance is concerned with providing the funds for an organization’s activities. Generally, this involves balancing risk and profitability, while attempting to maximize an organization’s wealth and the value of its stock. This holds primarily for “for-profit” organizations, but also applies to “not-for-profit” organizations. The latter needs finances to ensure sustainability, while not targeting tangible profit. To do this, an
organization must identify organizational goals, time horizons, risk factors, tax considerations, and financial constraints; identify and implement the appropriate business strategy, such as which portfolio and investment decisions to take, how to manage cash flow, and where to get the funding; measure financial performance, such as cash flow and ROI , and take corrective actions in case of deviation from objectives and strategy.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Finance</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Finance</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Finite_State_Machines</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Alternately, a finite state machine (FSM) is a mathematical abstraction composed of a finite number of states and transitions between those states. An FSM has a finite internal memory, an input feature that reads symbols in a sequence and one
at a time, and an output feature. The operation of an FSM begins from a start
state, goes through transitions depending on input to different states, and can end in any valid state. However, only a few of all the states mark a successful flow of operation. These are called accept states.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Finite_State_Machines</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Finite State Machines</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/For_Profit_Decision_Analysis</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Decision criteria depend on the business objectives and typically include ROI or Return on Capital Employed (ROCE). For-profit decision techniques don’t apply for government and nonprofit organizations. In these cases, organizations have different goals which means that a different set of decision techniques are needed, such as cost-benefit or cost-effectiveness analysis.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/For_Profit_Decision_Analysis</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">For-Profit Decision Analysis</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Formal_Analysis</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">This topic is also related to Formal Methods in the Software Engineering
Models and Methods Knowledge Area. Formal analysis has made an impact on some application domains, particularly those of highintegrity systems. The formal expression of requirements requires a language with formally defined semantics. The use of a formal analysis for requirements expression has two benefits. First, it enables requirements expressed in the language to be specified precisely and unambiguously, thus (in principle) avoiding the potential for misinterpretation. Secondly, requirements can be reasoned over, permitting desired properties of the specified software to be proven. Formal reasoning requires tool support to be practicable for anything other than trivial systems, and tools generally fall into two types: theorem provers or model checkers. In neither case can proof be fully automated, and the level of competence in formal reasoning needed in order to use the tools restricts the wider application of formal analysis. Most formal analysis is focused on relatively late stages of requirements analysis. However, once the requirements have stabilized and have been elaborated to specify concrete properties of the software, it may be beneficial to formalize at least the critical requirements. This permits static validation that the software specified by the requirements does indeed have the properties (for example, absence of deadlock) that the customer, users, and software engineer expect it to have.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Formal_Analysis</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Formal Analysis</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Formal_Methods</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Formal methods are software engineering methods used to specify, develop, and verify the software through application of a rigorous mathematically based notation and language. Through use of a specification language, the software model can be checked for consistency (in other words, lack of ambiguity), completeness, and correctness in a systematic and automated or semi-automated fashion. Specification Languages: Specification languages provide the mathematical basis for a formal method; specification languages are formal, higher level computer languages (in other words, not a classic 3rd Generation Language (3GL) programming language) used during the software specification, requirements analysis, and/or design stages to describe specific input/output behavior. Program Refinement and Derivation: Program refinement is the process of creating a lower level (or more detailed) specification using a series of transformations. It is through successive transformations that the software engineer derives an executable representation of a program. Formal Verification: Model checking is a formal verification method; it typically involves performing a state-space exploration or reachability analysis to demonstrate that the represented software design has or preserves certain model properties of interest. Logical Inference: Logical inference is a method of designing software that involves specifying preconditions and postconditions around each significant block of the design, and using mathematical logic developing the proof that those preconditions and postconditions must hold under all inputs.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Formal_Methods</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Formal Methods</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Formulating_the_Real_Problem</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Gerard Voland writes, “It is important to recognize that a specific problem should be formulated if one is to develop a specific solution”. This formulation is called the problem statement, which explicitly specifies what both the problem and the desired outcome are. Although there is no universal way of stating a problem, in general a problem should be expressed in such a way as to facilitate the development of solutions. Some general techniques to help one formulate the real problem include statement-restatement, determining the source and the cause, revising the statement, analyzing present and desired state, and using the fresh eye
approach.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Formulating_the_Real_Problem</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Formulating the Real Problem</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Free_Module_and_Complementary_and_Extension_Activities</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The disciplines that constitute complementary training and free training enable the student to be co-responsible for the construction of his / her curriculum, with training in his or her area of ​​greatest interest, and not only a generalized theoretical and practical training. Free training, disciplines categorized as free module, consists of activities / disciplines developed by the student based on their personal interests, which are not part of the activities of the basic cycle, nor of the professional, complementary / optional or integrative. They can be taken at any of the University&apos;s campuses.

In addition to the subjects of free choice of the student, it also contemplates the completion of complementary and extension activities such as: scientific initiation, multidisciplinary projects, participation in events, participation in a junior company, etc. All these programs provide for paid scholarships; proof of participation as a volunteer, in addition to credits in free module.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Free_Module_and_Complementary_and_Extension_Activities</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Free Module (ML) and Complementary and Extension Activities (ACEx)</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Friction_Free_Economy</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Economic friction is everything that keeps markets from having perfect competition. It involves distance, cost of delivery, restrictive regulations, and/or imperfect information. In high-friction markets, customers don’t have many suppliers from which to choose. Having been in a business for a while or owning a store in a good location determines the economic position. It’s hard for new competitors to start business and compete. The marketplace moves slowly and predictably. Friction-free markets are just the reverse. New competitors emerge and customers are quick to respond. The marketplace is anything but predictable.
Theoretically, software and IT are frictionfree. New companies can easily create products and often do so at a much lower cost than established companies, since they need not consider any legacies. Marketing and sales can be done via the Internet and social networks, and basically free distribution mechanisms can enable a ramp up to a global business. Software engineering economics aims to provide foundations to judge how a software business performs and how friction-free a market actually is. For instance, competition among software app developers is
inhibited when apps must be sold through an app store and comply with that store’s rules.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Friction_Free_Economy</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Friction-Free Economy</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Function_Oriented_Structured_Design</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">This is one of the classical methods of software design, where decomposition centers on identifying the major software functions and then elaborating and refining them in a hierarchical topdown manner. Structured design is generally used after structured analysis, thus producing (among other things) data flow diagrams and associated process descriptions. Researchers have proposed various strategies (for example, transformation analysis, transaction analysis) and heuristics (for example, fan-in/fan-out, scope of effect vs. scope of control) to transform a DFD into a software architecture generally represented as a structure chart.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Function_Oriented_Structured_Design</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Function-Oriented (Structured) Design</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Functional_and_Nonfunctional_Requirements</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Functional requirements describe the functions that the software is to execute; for example, formatting some text or modulating a signal. They are sometimes known as capabilities or features. A functional requirement can also be described
as one for which a finite set of test steps can be written to validate its behavior. Nonfunctional requirements are the ones that act to constrain the solution. Nonfunctional requirements are sometimes known as constraints or quality requirements. They can be further classified according to whether they are performance requirements, maintainability requirements, safety requirements, reliability requirements, security requirements, interoperability requirements or one of many other types of software requirements.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Functional_and_Nonfunctional_Requirements</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Functional and Nonfunctional Requirements</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/GUI_Builders</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A GUI (Graphical User Interface) builder is a software development tool that enables the developer to create and maintain GUIs in a WYSIWYG (what you see is what you get) mode. A GUI builder usually includes a visual editor for the developer to design forms and windows and manage the layout of the widgets by dragging, dropping, and parameter setting. Some GUI builders can automatically generate the source code corresponding to the visual GUI design. Because current GUI applications  usually follow the event-driven style (in which the flow of the program is determined by events and event handling), GUI builder tools usually provide code generation assistants, which automate the most repetitive tasks required for event handling. The supporting code connects widgets with the outgoing and incoming events that trigger the functions providing the application logic. Some modern IDEs provide integrated GUI builders or GUI builder plug-ins. There are also many standalone GUI builders.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/GUI_Builders</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">GUI Builders</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/General_Design_Concepts</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">In the general sense, design can be viewed as a form of problem solving. For example, the concept of a wicked problem a problem with no definitive solution is interesting in terms of understanding the limits of design. A number of other notions and concepts are also of interest in understanding design in its general sense: goals, constraints, alternatives, representations, and solutions.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/General_Design_Concepts</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">General Design Concepts</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/General_Strategies</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Some often-cited examples of general strategies useful in the design process include the divideand-conquer and stepwise refinement strategies, top-down vs. bottom-up strategies, and strategies making use of heuristics, use of patterns and pattern languages, and use of an iterative and incremental approach.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/General_Strategies</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">General Strategies</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/General_User_Interface_Design_Principles</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Learnability. The software should be easy to learn so that the user can rapidly start working with the software; User familiarity. The interface should use terms and concepts drawn from the experiences of the people who will use the software; Consistency. The interface should be consistent so that comparable operations are activated in the same way; Minimal surprise. The behavior of software should not surprise users; Recoverability. The interface should provide mechanisms allowing users to recover from errors; User guidance. The interface should give meaningful feedback when errors occur and provide context-related help to users; User diversity. The interface should provide appropriate interaction mechanisms for diverse types of users and for users with different capabilities (blind, poor eyesight,
deaf, colorblind, etc.).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/General_User_Interface_Design_Principles</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">General User Interface Design Principles</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Goals_Estimates_and_Plans</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Goals in software engineering economics are mostly business goals (or business objectives). A business goal relates business needs (such as increasing profitability) to investing resources (such as starting a project or launching a product with a given budget, content, and timing). Goals apply to operational planning and to the strategic level (such as reaching a certain profitability or market share in a stated time period). An estimate is a well-founded evaluation of resources and time that will be needed to achieve stated goals. A software estimate is used to determine whether the project goals can be achieved within the constraints on schedule,
budget, features, and quality attributes. Estimates are typically internally generated and are not necessarily visible externally. Estimates should not be driven exclusively by the project goals because this could make an estimate overly optimistic. Estimation is a periodic activity; estimates should be continually revised during a project. A plan describes the activities and milestones that are necessary in order to reach the goals of a project. The plan should be in line with the goal and the estimate, which is not necessarily easy and obvious such as when a software project with given requirements would take longer than the target date foreseen by the client. In such cases, plans demand a review of initial goals as well as estimates and the underlying uncertainties and inaccuracies. Creative solutions with the underlying rationale of achieving a win-win position are applied to resolve conflicts.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Goals_Estimates_and_Plans</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Goals, Estimates, and Plans</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Grammar_Based_Input_Processing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Grammar-based input processing involves syntax analysis, or parsing, of the input token stream. It involves the creation of a data structure (called a parse tree or syntax tree) representing the input data. The inorder traversal of the parse tree usually gives the expression just parsed. The parser checks the symbol table for the presence of programmer-defined variables that populate the tree. After building the parse tree, the program uses it as input to the computational processes.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Grammar_Based_Input_Processing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Grammar-Based Input Processing</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Grammars</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The grammar of a natural language tells us whether a combination of words makes a valid sentence. Unlike natural languages, a formal language is specified by a well-defined set of rules for syntaxes. The valid sentences of a formal language can be described by a grammar with the help of these rules, referred to as production rules. A formal language is a set of finite-length words or strings over some finite alphabet, and a grammar specifies the rules for formation of these words or strings. The entire set of words that are valid for a grammar constitutes the language for the grammar. Thus, the grammar G is any compact, precise mathematical definition of a language L as opposed to just a raw listing of all of the language’s legal sentences or examples of those sentences.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Grammars</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Grammars</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Graphs</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A graph G = (V, E) where V is the set of vertices (nodes) and E is the set of edges. Edges are also referred to as arcs or links. In a multigraph, more than one edge may connect the same two vertices. Two or more connecting edges between the same pair of vertices may reflect multiple associations between the same two vertices. Such edges are called parallel or multiple edges.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Graphs</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Graphs</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Graphs_and_Trees</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Graphs and Trees</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Group</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A set S closed under a binary operation • forms a group if the binary operation satisfies the following four criteria: Associative, identity, inverse, closure property.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Group</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Group</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Group_Dynamics_and_Psychology</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Engineering work is very often conducted in the context of teamwork. A software engineer must be able to interact cooperatively and constructively with others to first determine and then meet both needs and expectations. Knowledge of group dynamics and psychology is an asset when interacting with customers, coworkers, suppliers, and subordinates to solve software engineering problems.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Group_Dynamics_and_Psychology</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Group Dynamics and Psychology</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Heuristic_Methods</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Heuristic methods are those experience-based software engineering methods that have been and are fairly widely practiced in the software industry. This topic area contains three broad discussion categories: structured analysis and design
methods, data modeling methods, and objectoriented analysis and design methods. Structured Analysis and Design Methods: The software model is developed primarily from a functional or behavioral viewpoint, starting from a high-level view of the software (including data and control elements) and then progressively decomposing or refining the model components through increasingly detailed designs. Data Modeling Methods: The data model is
constructed from the viewpoint of the data or information used. Data tables and relationships define the data models. This data modeling method is used primarily for defining and analyzing data requirements supporting database designs or data repositories typically found in business software, where data is actively managed as a business systems resource or asset; Object-Oriented Analysis and Design Methods: The object-oriented model is represented as a collection of objects that encapsulate data and relationships and interact with other objects through methods. Objects may be real-world items or virtual items. The software model is constructed using diagrams to constitute selected views of the software.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Heuristic_Methods</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Heuristic Methods</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Hierarchy</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">When we use abstraction in our problem formulation and solution, we may use different abstractions at different times in other words, we work on different levels of abstraction as the situation calls. Most of the time, these different levels of abstraction are organized in a hierarchy. There are many ways to structure a particular hierarchy and the criteria used in determining the specific content of each layer in the hierarchy varies depending on the individuals performing the work. Sometimes, a hierarchy of abstraction is sequential, which means that each layer has one and only one predecessor (lower) layer and one and only one successor (upper) layer except the upmost layer (which has no successor) and the bottommost layer (which has no predecessor). Sometimes, however, the hierarchy is organized in a tree-like structure, which means each layer can have more than one predecessor layer but only one successor layer. Occasionally, a hierarchy can have a manyto-many structure, in which each layer can have multiple predecessors and successors. At no time, shall there be any loop in a hierarchy. A hierarchy often forms naturally in task decomposition. Often, a task analysis can be decomposed
in a hierarchical fashion, starting with the larger tasks and goals of the organization and breaking each of them down into smaller subtasks that can again be further subdivided This continuous division of tasks into smaller ones would produce a
hierarchical structure of tasks-subtasks.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Hierarchy</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Hierarchy</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/High_Level_Programming_Languages</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A high-level programming language has a strong abstraction from the details of the computer’s ISA. In comparison to low-level programming languages, it often uses natural-language elements and is thus much easier for humans to
understand. Such languages allow symbolic naming of variables, provide expressiveness, and enable abstraction of the underlying hardware. For example, while each microprocessor has its own ISA, code written in a high-level programming language is usually portable between many different hardware platforms. For these reasons, most programmers use and most software are written in high-level programming languages. Examples of high-level programming languages include C, C++, C#, and Java.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/High_Level_Programming_Languages</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">High-Level Programming Languages</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Identifying_Items_to_Be_Controlled</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">One of the first steps in controlling change is identifying the software items to be controlled. This involves understanding the software configuration within the context of the system configuration, selecting software configuration items,
developing a strategy for labeling software items and describing their relationships, and identifying both the baselines to be used and the procedure for a baseline’s acquisition of the items. Software Configuration, Software Configuration Item, Software Configuration Item, Software Version, Baseline, Acquiring Software Configuration Items.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Identifying_Items_to_Be_Controlled</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Identifying Items to Be Controlled</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Implementation_of_Measurement_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The measurement process should be enacted during the software project to ensure that relevant and useful data are collected.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Implementation_of_Measurement_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Implementation of Measurement Process</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Implementation_of_Plans</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Project activities should be undertaken in accordance with the project plan and supporting plans. Resources (for example, personnel, technology, and funding) are utilized and work products (for example, software design, software code, and software test cases) are generated.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Implementation_of_Plans</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Implementation of Plans</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Implementing_Software_Changes</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Approved SCRs are implemented using the defined software procedures in accordance with the applicable schedule requirements. Since a number of approved SCRs might be implemented simultaneously, it is necessary to provide a means for tracking which SCRs are incorporated into particular software versions and baselines. As part of the closure of the change process, completed changes may undergo configuration audits and software quality verification this includes ensuring that only approved changes have been made. The software change request process described above will typically document the SCM (and other) approval information for the change. Changes may be supported by source code version control tools. These tools allow a team of software engineers, or a single software engineer, to track and document changes to the source code. These tools provide a single repository for storing the source code, can prevent more than one software engineer from editing the same module at the same time, and record all changes made to the source code. Software engineers check modules out of the repository, make changes, document the changes, and then save the edited modules in the repository. If needed, changes can also be discarded, restoring a previous baseline. More powerful tools can support parallel development and geographically distributed environments. These tools may be manifested as separate, specialized applications under the control of an independent SCM group. They may also appear as an integrated part of the software engineering environment. Finally, they may be as elementary as a rudimentary change control system provided with an operating system.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Implementing_Software_Changes</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Implementing Software Changes</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/In_Process_Audits_of_a_Software_Baseline</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">As mentioned above, audits can be carried out during the development process to investigate the current status of specific elements of the configuration. In this case, an audit could be applied to sampled baseline items to ensure that performance
is consistent with specifications or to ensure that evolving documentation continues to be consistent with the developing baseline item.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/In_Process_Audits_of_a_Software_Baseline</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">In-Process Audits of a Software Baseline</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Individual_Cognition</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Engineers desire to solve problems. The ability to solve problems effectively and efficiently is what every engineer strives for. However, the limits and processes of individual cognition affect problem solving. In software engineering, notably due
to the highly abstract nature of software itself, individual cognition plays a very prominent role in problem solving. In general, an individual’s (in particular, a software engineer’s) ability to decompose a problem and creatively develop a solution can be inhibited by need for more knowledge, subconscious assumptions, volume of data, fear of failure or consequence of failure, culture, either application domain or organizational, lack of ability to express the problem, perceived working atmosphere, and emotional status of the individual. The impact of these inhibiting factors can be reduced by cultivating good problem solving habits that minimize the impact of misleading assumptions. The ability to focus is vital, as is intellectual humility: both allow a software engineer to suspend personal considerations and consult with others freely, which is especially important when working in teams.
There is a set of basic methods engineers use to facilitate problem solving.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Individual_Cognition</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Individual Cognition</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Inflation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Inflation describes long-term trends in prices. Inflation means that the same things cost more than they did before. If the planning horizon of a business decision is longer than a few years, or if the inflation rate is over a couple of percentage points annually, it can cause noticeable changes in the value of a proposal. The present time value therefore needs to be adjusted for inflation rates and also for exchange rate fluctuations.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Inflation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Inflation</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Information_Modeling</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Information models provide a central focus on data and information. An information model is an abstract representation that identifies and defines a set of concepts, properties, relations, and constraints on data entities. The semantic or conceptual information model is often used to provide some formalism and context to the software being modeled as viewed from the problem perspective, without concern for how this model is actually mapped to the implementation of the software. The semantic or conceptual information model is an abstraction and, as such, includes only the concepts, properties, relations, and constraints needed to conceptualize the real-world view of the information. Subsequent transformations of the semantic or conceptual information model lead to the elaboration of logical and then physical data models as implemented in the software.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Information_Modeling</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Information Modeling</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Initiation_and_Scope_Definition</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The focus of these activities is on effective determination of software requirements using various elicitation methods and the assessment of project feasibility from a variety of standpoints. Once project feasibility has been established, the remaining tasks within this section are the specification of requirements and selection of the processes for revision and review of requirements.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Initiation_and_Scope_Definition</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Initiation and Scope Definition</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Input_Domain_Based_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Equivalence partitioning involves partitioning the input domain into a collection of subsets (or equivalent classes) based on a specified criterion or relation. This criterion or relation may be different computational results, a relation based on control flow or data flow, or a distinction made between valid inputs that are accepted and processed by the system and invalid inputs, such as out of range values, that are not accepted and should generate an error message or initiate error processing. A representative set of tests (sometimes only one) is usually
taken from each equivalency class. Test cases are derived by combining interesting values for every pair of a set of input variables instead of considering all possible combinations. Pairwise testing belongs to combinatorial testing,
which in general also includes higher-level combinations than pairs: these techniques are referred to as t-wise, whereby every possible combination
of t input variables is considered.Test cases are chosen on or near the boundaries of the input domain of variables, with the underlying rationale that many faults tend to concentrate near the extreme values of inputs. An extension of this technique is robustness testing, wherein test cases are also chosen outside the input domain of variables to test program robustness in processing unexpected or erroneous inputs. Tests are generated purely at random. This form of testing falls under the heading of input domain testing since the input domain must be known in order to be able to pick random points within it. Random testing provides a relatively simple approach for test automation; recently, enhanced forms of random testing have
been proposed in which the random input sampling is directed by other input selection criteria. Fuzz testing or fuzzing is a special form of random testing aimed at breaking the software; it is most often used for security testing.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Input_Domain_Based_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Input Domain-Based Techniques</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Input_and_Output</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A computer is useless without I/O. Common input devices include the keyboard and mouse; common output devices include the disk, the screen, the printer, and speakers. Different I/O devices operate at different data rates and reliabilities. How computers connect and manage various input and output devices to facilitate the
interaction between computers and humans (or other computers) is the focus of topics in I/O. The main issues that must be resolved in input and output are the ways I/O can and should be performed. In general, I/O is performed at both hardware and software levels. Hardware I/O can be performed in any of three ways. Dedicated I/O dedicates the CPU to the actual input and output operations during I/O; memory-mapped I/O treats I/O operations as memory operations; and hybrid
I/O combines dedicated I/O and memory-mapped I/O into a single holistic I/O operation mode. Coincidentally, software I/O can also be performed in one of three ways. Programmed I/O lets the CPU wait while the I/O device is doing I/O; interrupt-driven I/O lets the CPU’s handling of I/O be driven by the I/O device; and direct memory access (DMA) lets I/O be handled by a secondary CPU embedded in a DMA device (or channel). (Except during the initial setup, the main CPU is not disturbed during a DMA I/O operation.)</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Input_and_Output</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Input and Output (I/O)</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Integration</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A key activity during construction is the integration of individually constructed routines, classes, components, and subsystems into a single system. In addition, a particular software system may need to be integrated with other software or
hardware systems. Concerns related to construction integration include planning the sequence in which components will be integrated, identifying what hardware is needed, creating scaffolding to support interim versions of the software, determining the degree of testing and quality work performed on components before they are integrated, and determining points in the project at which interim versions of the software are tested. Programs can be integrated by means of either the phased or the incremental approach. Phased integration, also called “big bang” integration, entails delaying the integration of component software parts until all parts intended for release in a version are complete. Incremental integration is thought to offer many advantages over the traditional phased integration for example, easier error location, improved progress monitoring, earlier product delivery, and improved customer relations. In incremental integration, the developers write and test a program in small pieces and then combine the pieces one at a time. Additional test infrastructure, such as stubs, drivers, and mock objects, are usually needed to enable incremental integration. By building and integrating one unit at a time (for example, a class or component), the construction process can provide early feedback to developers and customers. Other advantages of incremental integration include easier error location, improved progress monitoring, more fully tested units, and so forth.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Integration</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Integration</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Integrator_Project</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The Engineering Integrator Project disciplines allow the student body to present to the student body problem-based project methodology encompassing aspects of teamwork, communication and expression, synthesis and integration skills, notions of entrepreneurship, social responsibility and the environment.

The Engineering Integrator Project disciplines are used in a way that complements the inclusion of Core Core contents and implements throughout the course a project-based learning methodology, allowing the student an understanding of scientific and technological methodology, communication and graphic expression, among other knowledges. In the dynamics of these disciplines, it is expected that the students of the various courses work together for a project that contemplates several areas. For this reason, it is important that these disciplines are viewed as essential activities and are provided with adequate resources to accommodate the teams that will work separately.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Integrator_Project</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Integrator Project</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Interacting_with_Stakeholders</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Success of a software engineering endeavor depends upon positive interactions with stakeholders. They should provide support, information, and feedback at all stages of the software life cycle process. For example, during the early stages, it is critical to identify all stakeholders and discover how the product will affect them, so that sufficient definition of the stakeholder requirements can be properly and completely captured. During development, stakeholders may provide feedback on specifications and/or early versions of the software, change of priority, as well as clarification of detailed or new software requirements. Last, during software maintenance and until the end of product life, stakeholders provide feedback on evolving or new requirements as well problem reports so that the software may
be extended and improved. Therefore, it is vital to maintain open and productive
communication with stakeholders for the duration of the software product’s lifetime.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Interacting_with_Stakeholders</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Interacting with Stakeholders</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Interaction_Analysis</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Interaction analysis focuses on the communications or control flow relations between entities used to accomplish a specific task or function within the software model. This analysis examines the dynamic behavior of the interactions between different portions of the software model, including other software layers (such as the operating system, middleware, and applications). It may also be important for some software applications to examine interactions between the computer software application and the user interface software. Some software modeling environments provide simulation facilities to study aspects of the dynamic behavior of modeled software. Stepping through the simulation provides an analysis option for the software engineer to review the interaction design and verify that the different parts of the software work together to provide the intended functions.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Interaction_Analysis</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Interaction Analysis</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Interaction_and_Presentation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">This design issue is concerned with how to structure and organize interactions with users as well as the presentation of information (for example, separation of presentation and business logic using the Model-View-Controller approach). Note that this topic does not specify user interface details, which is the task of user interface design.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Interaction_and_Presentation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Interaction and Presentation</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Internet_of_Things</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The Internet of Things refers to the networking of everyday objects such as cars, cell phones, PDAs, TVs, refrigerators, and even buildings using wired or wireless networking technologies. The function and purpose of Internet of Things
is to interconnect all things to facilitate autonomous and better living. Technologies used in the Internet of Things include RFID, wireless and wired networking, sensor technology, and much software of course. As the paradigm of Internet of Things is still taking shape, much work is needed for Internet of Things to gain wide spread acceptance.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Internet_of_Things</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Internet of Things</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Interpretation_and_Compilation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">There are two ways to translate a program written in a higher-level language into machine code: interpretation and compilation. Interpretation translates the source code one statement at a time into machine language, executes it on the spot, and then goes back for another statement. Both the high-level-language source code and the interpreter are required every time the program is run. Compilation translates the high-level-language source code into an entire machine-language program (an executable image) by a program called a compiler. After compilation, only the executable image is needed to run the program. Most application software is sold in this form. While both compilation and interpretation convert high level language code into machine code, there are some important differences between the two methods. First, a compiler makes the conversion just once, while an interpreter typically converts it every time a program is executed. Second, interpreting code is slower than running the compiled code, because the interpreter must analyze each statement in the program when it is executed and then perform the desired action, whereas the compiled code just performs the action within a fixed context determined by the compilation. Third, access to variables is also slower in an interpreter because the mapping of identifiers to storage locations must be done repeatedly at runtime rather than at compile time.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Interpretation_and_Compilation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Interpretation and Compilation</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Investment_Decisions</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Investors make investment decisions to spend money and resources on achieving a target objective. Investors are either inside (e.g., finance, board) or outside (e.g., banks) the organization. The target relates to some economic criteria, such as achieving a high return on the investment, strengthening the capabilities of the organization, or improving the value of the company. Intangible aspects such as goodwill, culture, and competences should be considered.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Investment_Decisions</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Investment Decisions</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Iterative_Nature_of_the_Requirements_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">There is general pressure in the software industry for ever shorter development cycles, and this is particularly pronounced in highly competitive, market-driven sectors. Moreover, most projects are constrained in some way by their environment, and many are upgrades to, or revisions of, existing software where the architecture is a given. In practice, therefore, it is almost always impractical to implement the requirements process as a linear, deterministic process in which software requirements are elicited from the stakeholders, baselined, allocated, and handed over to the software development team. It is certainly a myth that the
requirements for large software projects are ever perfectly understood or perfectly specified. Instead, requirements typically iterate towards a level of quality and detail that is sufficient to permit design and procurement decisions to be made. In some projects, this may result in the requirements being baselined before all their properties are fully understood. This risks expensive rework if problems emerge late in the software engineering process. However, software engineers are necessarily constrained by project management plans and must therefore take steps to ensure that the “quality” of the requirements is as high as possible given the available resources. They should, for example, make explicit any assumptions that underpin the requirements as well as any known problems.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Iterative_Nature_of_the_Requirements_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Iterative Nature of the Requirements Process</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Key_Issues</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A test selection criterion is a means of selecting test cases or determining that a set of test cases is sufficient for a specified purpose. Test adequacy criteria can be used to decide when sufficient testing will be, or has been accomplished. Testing effectiveness is determined by analyzing a set of program executions. Selection of tests to be executed can be guided by different objectives: it is only in light of the objective pursued that the effectiveness of the test set can be evaluated. In testing for defect discovery, a successful test is one that causes the system to fail. This is quite different from testing to demonstrate that the
software meets its specifications or other desired properties, in which case testing is successful if no failures are observed under realistic test cases and test environments. An oracle is any human or mechanical agent that decides whether a program behaved correctly in a given test and accordingly results in a verdict of “pass” or “fail.” There exist many different kinds of oracles; for example, unambiguous requirements specifications, behavioral models, and code annotations. Automation of mechanized oracles can be difficult and expensive. Testing theory warns against ascribing an unjustified level of confidence to a series of successful tests. Unfortunately, most established results of testing theory are negative ones, in that they state what testing can never achieve as opposed to what is actually achieved. The most famous quotation
in this regard is the Dijkstra aphorism that “program testing can be used to show the presence of bugs, but never to show their absence”. The obvious reason for this is that complete testing is not feasible in realistic software. Because of this,
testing must be driven based on risk and can be seen as a risk management strategy. Infeasible paths are control flow paths that cannot be exercised by any input data. They are a significant problem in path-based testing, particularly
in automated derivation of test inputs to exercise control flow paths. The term “software testability” has two related but different meanings: on the one hand, it refers to the ease with which a given test coverage criterion can be satisfied; on the other hand, it is defined as the likelihood, possibly measured statistically, that a set of test cases will expose a failure if the software is faulty. Both meanings are important.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Key_Issues</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Key Issues</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Key_Issues_in_Software_Design</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A number of key issues must be dealt with when designing software. Some are quality concerns that all software must address for example, performance, security, reliability, usability, etc. Another important issue is how to decompose, organize, and package software components. This is so fundamental that all design approaches address it in one way or another. In contrast, other issues “deal with some aspect of software’s behavior that is not in the application domain, but which addresses some of the supporting domains”. Such issues, which often crosscut the system’s functionality, have been referred to as aspects, which “tend not to be units of software’s functional decomposition, but rather to be properties that affect the performance or semantics of the components in systemic ways”. A number of these key, crosscutting issues are discussed in the following sections (presented in
alphabetical order).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Key_Issues_in_Software_Design</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Key Issues in Software Design</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Key_Issues_in_Software_Maintenance</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A number of key issues must be dealt with to ensure the effective maintenance of software. Software maintenance provides unique technical and management challenges for software engineers for example, trying to find a fault in software containing a large number of lines of code that another software engineer developed. Similarly, competing with software developers for resources is a constant battle. Planning for a future release, which often includes coding the next release while sending out emergency patches for the current release, also creates a challenge. The following section presents some of the technical and management issues related to software maintenance.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Key_Issues_in_Software_Maintenance</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Key Issues in Software Maintenance</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Knowledge_Area</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A body of knowledge or Knowlwdge area is the complete set of concepts, terms and activities that make up a professional domain, as defined by the relevant learned society or professional association. It is a type of knowledge representation by any knowledge organization. A BOK/KA is the accepted ontology for a specific domain. A BOK/KA is more than simply a collection of terms; a professional reading list; a library; a website or a collection of websites; a description of professional functions; or even a collection of information.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Knowledge_Area</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Knowledge Area</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Language_Recognition</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Formal grammars can be classified according to the types of productions that are allowed. The Chomsky hierarchy (introduced by Noam Chomsky in 1956) describes such a classification scheme.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Language_Recognition</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Language Recognition</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Legal_Issues</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Legal issues surrounding software engineering professional practice notably include matters related to standards, trademarks, patents, copyrights, trade secrets, professional liability, legal requirements, trade compliance, and cybercrime. It is therefore beneficial to possess knowledge of these issues and their applicability. Legal issues are jurisdictionally based; software engineers must consult attorneys who specialize in the type and jurisdiction of any identified legal issues.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Legal_Issues</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Legal Issues</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Levels_of_Abstraction</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">When abstracting, we concentrate on one “level” of the big picture at a time with confidence that we can then connect effectively with levels above and below. Although we focus on one level, abstraction does not mean knowing nothing about the neighboring levels. Abstraction levels do not necessarily correspond to discrete components in reality or in the problem domain, but to welldefined standard interfaces such as programming APIs. The advantages that standard interfaces provide include portability, easier software/hardware integration and wider usage.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Levels_of_Abstraction</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Levels of Abstraction</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Levels_of_Measurement</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Once the operational definitions are determined, the actual measurements need to be undertaken. It is to be noted that measurement may be carried out in four different scales: namely, nominal, ordinal, interval, and ratio. Brief descriptions of
each are given below. Nominal scale: This is the lowest level of measurement
and represents the most unrestricted assignment of numerals. The numerals serve only as labels, and words or letters would serve as well. Ordinal scale: Refers to the measurement scale where the different values obtained through the process of measurement have an implicit ordering. Interval scales: With the interval scale, we
come to a form that is quantitative in the ordinary sense of the word. Almost all the usual statistical measures are applicable here, unless they require knowledge of a true zero point. The zero point on an interval scale is a matter of convention. Ratio scale: These are quite commonly encountered in physical science. These scales of measures are characterized by the fact that operations exist for determining all 4 relations: equality, rank order, equality of intervals, and equality of ratios.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Levels_of_Measurement</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Levels (Scales) of Measurement</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Life_Cycle_Economics</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Life Cycle Economics</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Localization_and_Internationalization</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">User interface design often needs to consider internationalization and localization, which are means of adapting software to the different languages, regional differences, and the technical requirements of a target market. Internationalization is the process of designing a software application so that it can be adapted to various languages and regions without major engineering changes. Localization is the process of adapting internationalized software for a specific region or language by adding locale-specific components and translating the text. Localization and internationalization should consider factors such as symbols, numbers, currency, time, and measurement units.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Localization_and_Internationalization</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Localization and Internationalization</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Low_Level_Programming_Languages</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Programming language can be classified into two classes: low-level languages and high-level languages. Low-level languages can be understood by a computer with no or minimal assistance and typically include machine languages and assembly
languages. A machine language uses ones and zeros to represent instructions and variables, and is directly understandable by a computer. An assembly language contains the same instructions as a machine language but the instructions and variables have symbolic names that are easier for humans to remember.
Assembly languages cannot be directly understood by a computer and must be translated into a machine language by a utility program called an assembler. There often exists a correspondence between the instructions of an assembly language
and a machine language, and the translation from assembly code to machine code is straightforward.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Low_Level_Programming_Languages</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Low-Level Programming Languages</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Main_Issues_in_Distributed_Computing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Coordination among all the components in a distributed computing environment is often complex and time-consuming. As the number of cores/CPUs/computers increases, the complexity of distributed computing also increases. Among the many issues faced, memory coherency and consensus among all computers are the most difficult ones. Many computation paradigms have been invented to solve these problems and are the main discussion issues in distributed/parallel computing.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Main_Issues_in_Distributed_Computing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Main Issues in Distributed Computing</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Maintenance_Activities</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The maintenance process contains the activities and tasks necessary to modify an existing software product while preserving its integrity. These activities and tasks are the responsibility of the maintainer. As already noted, many maintenance activities are similar to those of software development. Maintainers perform analysis, design, coding, testing, and documentation. Unique Activities: There are a number of processes, activities, and practices that are unique to software maintenance: Program understanding; Transition; Modification request acceptance/rejection; Maintenance help desk;  Impact analysis; Maintenance Service-Level Agreements (SLAs) and maintenance licenses and contracts: Supporting Activities: Maintainers may also perform support activities, such as documentation, software configuration management, verification and validation, problem resolution, software quality assurance, reviews, and audits. Maintenance Planning Activities: An important activity for software maintenance is planning, and maintainers must address the issues associated with a number of planning perspectives. At the individual request level, planning is carried out during the impact analysis.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Maintenance_Activities</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Maintenance Activities</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Maintenance_Cost_Estimation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software engineers must understand the different categories of software maintenance, discussed above, in order to address the question of estimating the cost of software maintenance. For planning purposes, cost estimation is an important aspect of planning for software maintenance. Cost Estimation: Maintenance cost estimates are affected by many technical and nontechnical factors. IEEE 14764 states that “the two most popular approaches to estimating resources for software maintenance are the use of parametric models and the use of experience”. A combination of these two can also be used. Parametric cost modeling has been applied to software maintenance. Of significance is that historical data from past maintenance are needed in order to use and calibrate
the mathematical models. Cost driver attributes affect the estimates. Experience: Experience, in the form of expert judgment, is often used to estimate maintenance effort. Clearly, the best approach to maintenance estimation is to combine historical data and experience. The cost to conduct a modification (in terms
of number of people and amount of time) is then derived. Maintenance estimation historical data should be provided as a result of a measurement program.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Maintenance_Cost_Estimation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Maintenance Cost Estimation</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Maintenance_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">In addition to standard software engineering processes and activities described in IEEE 14764, there are a number of activities that are unique to maintainers.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Maintenance_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Maintenance Process</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Maintenance_Processes</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Maintenance processes provide needed activities and detailed inputs/outputs to those activities as described in IEEE 14764. Software maintenance activities include: process implementation; problem and modification analysis; modification implementation; maintenance review/acceptance; migration, and, software retirement. Other maintenance process models include: quick fix; spiral; Osborne’s; iterative enhancement, and, reuse-oriented. Recently, agile methodologies, which promote light processes, have been also adapted to maintenance. This requirement emerges from the everincreasing demand for fast turnaround of maintenance
services. Improvement to the software maintenance process is supported by specialized software maintenance capability maturity models.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Maintenance_Processes</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Maintenance Processes</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Majority_of_Maintenance_Costs</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Maintenance consumes a major share of the financial resources in a software life cycle. A common perception of software maintenance is that it merely fixes faults. However, studies and surveys over the years have indicated that the majority,
over 80 percent, of software maintenance is used for noncorrective actions. Grouping enhancements and corrections together in management reports contributes to some misconceptions regarding the high cost of corrections.
Understanding the categories of software maintenance helps to understand the structure of software maintenance costs. Also, understanding the factors that influence the maintainability of software can help to contain costs. Some environmental factors and their relationship to software maintenance costs include the following: Operating environment refers to hardware and software. Organizational environment refers to policies, competition, process, product, and
personnel.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Majority_of_Maintenance_Costs</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Majority of Maintenance Costs</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Management_Issues</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Organizational objectives describe how to demonstrate the return on investment of software maintenance activities. Initial software development is usually project-based, with a defined time scale and budget. The main emphasis is to deliver a product that meets user needs on time and within budget. In contrast, software maintenance often has the objective of extending the life of software for as long as possible. Process: The software life cycle process is a set of activities, methods, practices, and transformations that people use to develop and maintain software and its associated products. At the process level, software maintenance activities share much in common with software development (for example, software configuration management is a crucial activity in both). Maintenance also requires several activities that are not found in software development. Organizational Aspects of Maintenance: Organizational aspects describe how to identify which organization and/or function will be responsible for the maintenance of software. The team that develops the software is not necessarily assigned to maintain the software once it is operational. In deciding where the software maintenance function will be located, software engineering organizations may, for example, stay with the original developer or go to a permanent maintenance-specific team (or maintainer). Since there are many pros and cons to each option, the decision should be made on a case-bycase basis. Outsourcing: Outsourcing and offshoring software maintenance has become a major industry. Organizations are outsourcing entire portfolios of software, including software maintenance. More often, the outsourcing option is selected for less mission-critical software, as organizations are unwilling to lose control of the software used in their core business. One of the major challenges for outsourcers is to determine the scope of the maintenance services required, the terms of a service-level agreement, and the contractual details.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Management_Issues</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Management Issues</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Management_of_the_SCM_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">SCM controls the evolution and integrity of a product by identifying its elements; managing and controlling change; and verifying, recording, and reporting on configuration information. From the software engineer’s perspective, SCM facilitates development and change implementation activities. A successful SCM implementation requires careful planning and management. This, in turn, requires an understanding of the organizational context for, and the constraints placed on, the design and implementation of the SCM process.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Management_of_the_SCM_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Management of the SCM Process</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Managing_Construction</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Managing Construction</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Mathematical_Foundations</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software professionals live with programs. In a very simple language, one can program only for something that follows a well-understood, nonambiguous logic. The Mathematical Foundations knowledge area (KA) helps software engineers comprehend this logic, which in turn is translated into programming language code. The mathematics that is the primary focus in this KA is quite different from typical arithmetic, where numbers are dealt with and discussed. Logic and reasoning are the essence of mathematics that a software engineer must address. Mathematics, in a sense, is the study of formal systems. The word “formal” is associated with preciseness, so there cannot be any ambiguous or erroneous interpretation of the fact. Mathematics is therefore the study of any and all certain
truths about any concept. This concept can be about numbers as well as about symbols, images, sounds, video almost anything. In short, not only numbers and numeric equations are subject to preciseness. On the contrary, a software engineer needs to have a precise abstraction on a diverse application domain.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Mathematical_Foundations</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Mathematical Foundations</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Measurement</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Knowing what to measure and which measurement method to use is critical in engineering endeavors. It is important that everyone involved in an engineering project understand the measurement methods and the measurement results
that will be used. Measurements can be physical, environmental, economic, operational, or some other sort of measurement that is meaningful for the particular project. This section explores the theory of measurement and how it is fundamental to engineering. Measurement starts as a conceptualization then moves from abstract concepts to definitions of the measurement method to the actual application of that method to obtain a measurement result. Each of these steps must be understood, communicated, and properly employed in order to generate usable data. In traditional engineering, direct measures are often used. In software engineering, a combination of both direct and derived measures is necessary. The theory of measurement states that measurement is an attempt to describe an underlying real empirical system. Measurement methods define activities that allocate a value or a symbol to an attribute of an entity. Attributes must then be defined in terms of the operations used to identify and measure them that is, the measurement methods. In this approach, a measurement method is defined to be a precisely specified operation that yields a number (called the measurement result) when measuring an attribute. It follows that, to be useful,
the measurement method has to be well defined. Arbitrariness in the method will reflect itself in ambiguity in the measurement results.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Measurement</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Measurement</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Measures</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Measures can be used to assess or to quantitatively estimate various aspects of a software design; for example, size, structure, or quality. Most measures that have been proposed depend on the approach used for producing the design. These measures are classified in two broad categories: Function-based (structured) design measures: measures obtained by analyzing functional decomposition; generally represented using a structure chart (sometimes called a hierarchical diagram) on which various measures can be computed; Object-oriented design measures: the design structure is typically represented as a class diagram, on which various measures can be computed. Measures on the properties of the internal content of each class can also be computed.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Measures</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Measures</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Measuring_Requirements</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">As a practical matter, it is typically useful to have some concept of the “volume” of the requirements for a particular software product. This number is useful in evaluating the “size” of a change in requirements, in estimating the cost of a development or maintenance task, or simply for use as the denominator in other measurements. Functional size measurement (FSM) is a technique for evaluating the size of a body of functional requirements. Additional information on size measurement and standards will be found in the Software Engineering Process KA.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Measuring_Requirements</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Measuring Requirements</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Memory_System_Organization</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Memory is the storage unit of a computer. It concerns the assembling of a large-scale memory system from smaller and single-digit storage units. The main topics covered by memory system architecture include the following: Memory cells and chips; Memory boards and modules; Memory hierarchy and cache; Memory as a subsystem of the computer. Memory cells and chips deal with single-digital storage and the assembling of single-digit units into one-dimensional memory arrays as well as the assembling of one-dimensional storage arrays into multi-dimensional storage memory chips. Memory boards and modules concern the assembling of memory chips into memory systems, with the focus being on the organization, operation, and management of the individual chips in the system. Memory hierarchy and cache are used to support efficient memory operations.
Memory as a sub-system deals with the interface between the memory system and other parts of the computer.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Memory_System_Organization</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Memory System Organization</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Metaphors_and_Conceptual_Models</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">User interface designers can use metaphors and conceptual models to set up mappings between the software and some reference system known to the users in the real world, which can help the users to more readily learn and use the interface. For example, the operation “delete file” can be made into a metaphor using the icon of a trash can. When designing a user interface, software engineers should be careful to not use more than one metaphor for each concept. Metaphors also present potential problems with respect to internationalization, since not all metaphors are meaningful or are applied in the same way within all cultures.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Metaphors_and_Conceptual_Models</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Metaphors and Conceptual Models</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Methods_of_Proving_Theorems</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Direct Proof. Direct proof is a technique to establish that the implication p → q is true by showing that q must be true when p is true. Proof by Contradiction. A proposition p is true by contradiction if proved based on the truth of the implication ¬ p → q where q is a contradiction. Proof by Induction. Proof by induction is done in two phases. First, the proposition is established to be true for a base case—typically for the positive integer 1. In the second phase, it is established
that if the proposition holds for an arbitrary positive integer k, then it must also hold for the next greater integer, k + 1.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Methods_of_Proving_Theorems</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Methods of Proving Theorems</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Middleware</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Middleware is a broad classification for software that provides services above the operating system layer yet below the application program layer. Middleware can provide runtime containers for software components to provide message
passing, persistence, and a transparent location across a network. Middleware can be viewed as a connector between the components that use the middleware. Modern message-oriented middleware usually provides an Enterprise Service Bus
(ESB), which supports service-oriented interaction and communication between multiple software applications.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Middleware</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Middleware</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Migration</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">During software’s life, it may have to be modified to run in different environments. In order to migrate it to a new environment, the maintainer needs to determine the actions needed to accomplish the migration, and then develop and document the steps required to effect the migration in a migration plan that covers migration requirements, migration tools, conversion of product and data, execution, verification, and support. Migrating software can also entail a number of additional activities such as: notification of intent: a statement of why the old environment is no longer to be supported, followed by a description of the new environment and its date of availability; parallel operations: make available the old and new environments so that the user experiences a smooth transition to the new environment; notification of completion: when the scheduled migration is completed, a notification is sent to all concerned;  postoperation review: an assessment of parallel operation and the impact of changing to the new environment; data archival: storing the old software data.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Migration</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Migration</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Minimizing_Complexity</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Most people are limited in their ability to hold complex structures and information in their working memories, especially over long periods of time. This proves to be a major factor influencing how people convey intent to computers and leads to one of the strongest drives in software construction: minimizing complexity. The need to reduce complexity applies to essentially every aspect of software construction and is particularly critical to testing of software constructions. In software construction, reduced complexity is achieved through emphasizing code creation
that is simple and readable rather than clever. It is accomplished through making use of standards, modular design , and numerous other specific techniques. It is also supported by construction-focused quality techniques.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Minimizing_Complexity</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Minimizing Complexity</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Minimum_Acceptable_Rate_of_Return</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The minimum acceptable rate of return (MARR) is the lowest internal rate of return the organization would consider to be a good investment. Generally speaking, it wouldn’t be smart to invest in an activity with a return of 10% when there’s another activity that’s known to return 20%. The MARR is a statement that an organization is confident it can achieve at least that rate of return. The MARR represents the organization’s opportunity cost for investments. By choosing to invest in some activity, the organization is explicitly deciding to not invest that same money
somewhere else. If the organization is already confident it can get some known rate of return, other alternatives should be chosen only if their rate of return is at least that high. A simple way to account for that opportunity cost is to use the MARR as the interest rate in business decisions. An alternative’s present worth evaluated at the MARR shows how much more or less (in present-day cash terms) that alternative is worth than investing at the MARR.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Minimum_Acceptable_Rate_of_Return</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Minimum Acceptable Rate of Return</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Mobility_and_Exchange_Activities</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Permanent exchange with national and international institutions and companies;</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Mobility_and_Exchange_Activities</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Mobility and exchange activities</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Model_Based_Testing_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A model in this context is an abstract (formal) representation of the software under test or of its software requirements. Model-based testing is used to validate requirements, check their consistency, and generate test cases focused on the behavioral aspects of the software. The key components of model-based
testing are: the notation used to represent the model of the software or its requirements; workflow models or similar models; the test strategy or algorithm used for test case generation; the supporting infrastructure for the test execution; and the evaluation of test results compared to expected results. Due to the complexity of the techniques, model-based testing approaches are often used in conjunction with test automation harnesses. Model-based testing techniques include the following. Decision tables represent logical relationships between conditions (roughly, inputs) and actions (roughly, outputs). Test cases are systematically derived by considering every possible combination of conditions and their corresponding resultant actions. A related technique is cause-effect graphing. By modeling a program as a finite state machine, tests can be selected in order to cover the states and transitions. Stating the specifications in a formal language permits automatic derivation of functional test cases, and, at the same time, provides an oracle for checking test results. TTCN3 (Testing and Test Control Notation version 3) is a language developed for writing test cases. The notation was conceived for the specific needs of testing telecommunication systems, so it is particularly suitable for testing complex communication protocols. Workflow models specify a sequence of activities performed by humans and/or software applications, usually represented through graphical notations. Each sequence of actions constitutes one workflow (also called a scenario). Both typical and alternate workflows should be tested. A special focus on the roles in a workflow specification is targeted in business process testing.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Model_Based_Testing_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Model-Based Testing Techniques</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Model_Validation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">It is typically necessary to validate the quality of the models developed during analysis. For example, in object models, it is useful to perform a static analysis to verify that communication paths exist between objects that, in the stakeholders’ domain, exchange data. If formal analysis notations are used, it is possible to use formal reasoning to prove specification properties. This topic is closely related to the Software Engineering Models and Methods KA.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Model_Validation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Model Validation</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Modeling</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Modeling of software is becoming a pervasive technique to help software engineers understand, engineer, and communicate aspects of the software to appropriate stakeholders. Stakeholders are those persons or parties who have a stated or implied interest in the software (for example, user, buyer, supplier, architect, certifying authority, evaluator, developer, software engineer, and perhaps others). While there are many modeling languages, notations, techniques, and tools in the literature and in practice, there are unifying general concepts that apply in some form to them all. The following sections provide background on these general concepts.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Modeling</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Modeling</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Modeling_Engineering</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A model is always an abstraction of some real or imagined artifact. Engineers use models in many ways as part of their problem solving activities. Some models are physical, such as a made-to-scale miniature construction of a bridge or building. Other models may be nonphysical representations, such as a CAD drawing of a cog
or a mathematical model for a process. Models help engineers reason and understand aspects of a problem. They can also help engineers understand what they do know and what they don’t know about the problem at hand. There are three types of models: iconic, analogic, and symbolic. An iconic model is a visually
equivalent but incomplete 2-dimensional or 3-dimensional representation for example, maps, globes, or built-to-scale models of structures such as bridges or highways. An iconic model actually resembles the artifact modeled. In contrast, an analogic model is a functionally equivalent but incomplete representation. That
is, the model behaves like the physical artifact even though it may not physically resemble it. Examples of analogic models include a miniature airplane for wind tunnel testing or a computer simulation of a manufacturing process.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Modeling_Engineering</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Modeling</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Modeling_Principles</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Modeling provides the software engineer with an organized and systematic approach for representing significant aspects of the software under study, facilitating decision-making about the software or elements of it, and communicating those significant decisions to others in the stakeholder communities. There are three general principles guiding such modeling activities: Model the Essentials: good models do not usually represent every aspect or feature of the software under every possible condition. Modeling typically involves developing only those aspects or features of the software that need specific answers, abstracting away any nonessential information; Provide Perspective: modeling provides views of the software under study using a defined set of rules for expression of the model within each view; Enable Effective Communications: modeling employs the application domain vocabulary of the software, a modeling language, and semantic expression (in other words, meaning within context). When used rigorously and systematically, this modeling results in a reporting approach that facilitates effective communication of software information to project stakeholders.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Modeling_Principles</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Modeling Principles</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Modeling_Simulation_and_Prototyping</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Modeling is part of the abstraction process used to represent some aspects of a system. Simulation uses a model of the system and provides a means of conducting designed experiments with that model to better understand the system, its behavior, and relationships between subsystems, as well as to analyze aspects of the design. Modeling and simulation are techniques that can be used to construct theories or hypotheses about the behavior of the system; engineers then use those
theories to make predictions about the system. Prototyping is another abstraction process where a partial representation (that captures aspects of interest) of the product or system is built. A prototype may be an initial version of the system but
lacks the full functionality of the final version.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Modeling_Simulation_and_Prototyping</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Modeling, Simulation, and Prototyping</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Models_and_Quality_Characteristics</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Terminology for software quality characteristics differs from one taxonomy (or model of software quality) to another, each model perhaps having a different number of hierarchical levels and a different total number of characteristics. Various authors have produced models of software quality characteristics or attributes that can be useful for discussing, planning, and rating the quality of software products. Software quality management and software engineering process quality have a direct bearing on the quality of the software product. Models and criteria that evaluate the capabilities of software organizations are primarily project organization and management considerations and, as such, are covered in the Software Engineering Management and Software Engineering Process KAs. It is not possible to completely distinguish process quality from product quality because process outcomes include products. Determining whether a process has the capability to consistently produce products of desired quality is not simple. The software engineering process, discussed in the Software Engineering Process KA, influences the quality characteristics of software products, which in turn affect quality as perceived by stakeholders. The software engineer, first of all, must determine the real purpose of the software. In this regard, stakeholder requirements are paramount, and they include quality requirements in addition to functional requirements. Thus, software engineers have a responsibility to elicit quality requirements that may not be explicit at the outset and to understand their importance as well as the level of difficulty in attaining them. All software development processes (e.g., eliciting requirements, designing, constructing, building, checking, improving quality) are designed with these quality requirements in mind and may carry additional development costs if attributes such as safety, security, and dependability are important. The additional development costs help ensure that quality obtained can be traded off against the anticipated benefits.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Models_and_Quality_Characteristics</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Models and Quality Characteristics</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Monitor_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Adherence to the project plan and related plans should be assessed continually and at predetermined intervals. Also, outputs and completion criteria for each task should be assessed. Deliverables should be evaluated in terms of their required characteristics (for example, via inspections or by demonstrating working functionality). Effort expenditure, schedule adherence, and costs to date should be analyzed, and resource usage examined. The project risk profile should be revisited, and adherence to software quality requirements evaluated. Measurement data should be analyzed. Variance analysis based on the deviation of actual from expected outcomes and values should be determined. This may include cost overruns, schedule slippage, or other similar measures. Outlier identification and analysis of quality and other measurement data should be performed. Risk exposures should be recalculated . These activities can enable problem detection and exception identification based on thresholds that have been exceeded. Outcomes should be reported when thresholds have been exceeded, or as necessary.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Monitor_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Monitor Process</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Multidisciplinary</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Projetos Multidisciplinares, ou seja, há a participação de outros cursos.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Multidisciplinary</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Multidisciplinary</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Multiple_Attribute_Evaluation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The topics discussed so far are used to make decisions based on a single decision criterion: money. The alternative with the best present worth, the best ROI, and so forth is the one selected. Aside from technical feasibility, money is almost always the most important decision criterion, but it’s not always the only one. Quite often there are other criteria, other “attributes,” that need to be considered, and those attributes can’t be cast in terms of money. Multiple attribute decision techniques allow other, nonfinancial criteria to be factored into the decision. There are two families of multiple attribute decision techniques that differ in how they use
the attributes in the decision. One family is the “compensatory,” or single-dimensioned, techniques. This family collapses all of the attributes
onto a single figure of merit. The family is called compensatory because, for any given alternative, a lower score in one attribute can be compensated
by or traded off against a higher score in other attributes. The compensatory techniques include nondimensional scaling, additive weighting, analytic hierarchy process. In contrast, the other family is the “noncompensatory,” or fully dimensioned, techniques. This family does not allow tradeoffs among the attributes. Each attribute is treated as a separate entity in the decision process. The noncompensatory techniques include, dominance, satisficing, lexicography.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Multiple_Attribute_Evaluation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Multiple Attribute Evaluation</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Nature_and_Role_of_Professional_Societies</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Professional societies are comprised of a mix of practitioners and academics. These societies serve to define, advance, and regulate their corresponding professions. Professional societies help to establish professional standards as well as codes of ethics and professional conduct. For this reason, they also engage in related activities, which include establishing and promulgating a body of generally accepted knowledge; accrediting, certifying, and licensing; dispensing disciplinary actions; advancing the profession through conferences, training, and publications.
Participation in professional societies assists the individual engineer in maintaining and sharpening their professional knowledge and relevancy and in expanding and maintaining their professional network.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Nature_and_Role_of_Professional_Societies</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Nature and Role of Professional Societies</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Nature_and_Role_of_Software_Engineering_Standards</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software engineering standards cover a remarkable variety of topics. They provide guidelines for the practice of software engineering and processes to be used during development, maintenance, and support of software. By establishing a consensual body of knowledge and experience, software engineering standards establish a basis upon which further guidelines may be developed. The benefits of software engineering standards are many and include improving software quality, helping avoid errors, protecting both software producers and users, increasing professional discipline, and helping technology transition.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Nature_and_Role_of_Software_Engineering_Standards</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Nature and Role of Software Engineering Standards</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Nature_of_Maintenance</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software maintenance sustains the software product throughout its life cycle (from development to operations). Modification requests are logged and tracked, the impact of proposed changes is determined, code and other software artifacts are
modified, testing is conducted, and a new version of the software product is released. Also, training and daily support are provided to users. The term maintainer is defined as an organization that performs maintenance activities. In this KA, the term will sometimes refer to individuals who perform those activities, contrasting them with the developers. IEEE 14764 identifies the primary activities of
software maintenance as process implementation, problem and modification analysis, modification implementation, maintenance review/acceptance, migration, and retirement. Maintenance Activities. Maintainers can learn from the developers’ knowledge of the software. Contact with the developers and early involvement by the maintainer helps reduce the overall maintenance effort. In some instances, the initial developer cannot be reached or has moved on to other tasks, which creates an additional challenge for maintainers. Maintenance must take software artifacts from development (for example, code or documentation)
and support them immediately, then progressively evolve/maintain them over a software life cycle.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Nature_of_Maintenance</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Nature of Maintenance</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Need_for_Maintenance</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Maintenance is needed to ensure that the software continues to satisfy user requirements. Maintenance is applicable to software that is developed using any software life cycle model (for example, spiral or linear). Software products change due to corrective and noncorrective software actions. Maintenance must be performed in order to correct faults; improve the design; implement enhancements; interface with other software; adapt programs so that different hardware, software, system features, and telecommunications facilities can be used; migrate legacy software; and retire software. Five key characteristics comprise the maintainer’s activities: maintaining control over the software’s dayto-day
functions; maintaining control over software modification; perfecting existing functions; identifying security threats and fixing security vulnerabilities; and preventing software performance from degrading to unacceptable levels.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Need_for_Maintenance</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Need for Maintenance</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Network_Communication_Basics</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A computer network connects a collection of computers and allows users of different computers to share resources with other users. A network facilitates the communications between all the connected computers and may give the illusion
of a single, omnipresent computer. Every computer or device connected to a network is called a network node. A number of computing paradigms have emerged to benefit from the functions and capabilities provided by computer networks. These paradigms include distributed computing, grid computing,  Internet computing, and cloud computing.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Network_Communication_Basics</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Network Communication Basics</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Networking_Protocols_and_Standards</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Computers communicate with each other using protocols, which specify the format and regulations used to pack and un-pack data. To facilitate easier communication and better structure, network protocols are divided into different layers with each layer dealing with one aspect of the communication. For example, the physical layers deal with the physical connection between the parties that are to communicate, the data link layer deals with the raw data transmission and flow control, and the network layer deals with the packing and un-packing of data into a particular format that is understandable by the relevant parties. The most commonly used OSI networking model organizes network protocols into seven
layers. One thing to note is that not all network protocols implement all layers of the OSI model. For example, the TCP/IP protocol implements neither the presentation layer nor the session layer. There can be more than one protocol for each layer. For example, UDP and TCP both work on the transport layer above IP’s network layer, providing best-effort, unreliable transport (UDP) vs. reliable transport function (TCP). Physical layer protocols include token ring, Ethernet, fast Ethernet,
gigabit Ethernet, and wireless Ethernet. Data link layer protocols include frame-relay, asynchronous transfer mode (ATM), and Point-toPoint Protocol (PPP). Application layer protocols include Fibre channel, Small Computer System Interface (SCSI), and Bluetooth.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Networking_Protocols_and_Standards</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Networking Protocols and Standards</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Number_Theory</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Number theory is one of the oldest branches of pure mathematics and one of the largest. Of course, it concerns questions about numbers, usually meaning whole numbers and fractional or rational numbers. The different types of numbers include integer, real number, natural number, complex number, rational number, etc.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Number_Theory</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Number Theory</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Numerical_Precision_Accuracy_and_Errors</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The main goal of numerical analysis is to develop efficient algorithms for computing precise numerical values of functions, solutions of algebraic and differential equations, optimization problems, etc. A matter of fact is that all digital computers can only store finite numbers. In other words, there is no way that a computer can represent an infinitely large number be it an integer, rational number, or any real or all complex numbers. So the mathematics of approximation becomes very critical to handle all the numbers in the finite range that a computer
can handle. Let’s define a couple of very important terms: accuracy and precision as associated with numerical analysis. Accuracy is the closeness with which a measured or computed value agrees with the true value. Precision, on the other hand, is the closeness with which two or more measured or computed values for the same physical substance agree with each other. In other words, precision is the closeness with which a number represents an exact value.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Numerical_Precision_Accuracy_and_Errors</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Numerical Precision, Accuracy, and Errors</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Object_Oriented_Design</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Numerous software design methods based on objects have been proposed. The field has evolved from the early object-oriented (OO) design of the mid-1980s (noun = object; verb = method; adjective = attribute), where inheritance and polymorphism play a key role, to the field of component-based design, where metainformation can be defined and accessed (through reflection, for example). Although OO design’s roots stem from the concept of data abstraction, responsibility-driven design has been proposed as an alternative approach to OO design.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Object_Oriented_Design</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Object-Oriented Design</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Object_Oriented_Runtime_Issues</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Object-oriented languages support a series of runtime mechanisms including polymorphism and reflection. These runtime mechanisms increase the flexibility and adaptability of objectoriented programs. Polymorphism is the ability of a language to support general operations without knowing until runtime what kind of concrete objects the software will include. Because the program does not know the exact types of the objects in advance, the exact behaviour is determined at runtime (called dynamic binding). Reflection is the ability of a program to observe
and modify its own structure and behavior at runtime. Reflection allows inspection of classes, interfaces, fields, and methods at runtime without knowing their names at compile time. It also allows instantiation at runtime of new objects and invocation of methods using parameterized class and method names.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Object_Oriented_Runtime_Issues</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Object-Oriented Runtime Issues</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Objectives_of_Testing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Testing is conducted in view of specific objectives, which are stated more or less explicitly and with varying degrees of precision. Stating the objectives of testing in precise, quantitative terms supports measurement and control of the test process. Testing can be aimed at verifying different properties. Test cases can be designed to check that the functional specifications are correctly implemented, which is variously referred to in the literature as conformance testing, correctness testing,
or functional testing. However, several other nonfunctional properties may be tested as well including performance, reliability, and usability, among many others. Other important objectives for testing include but are not limited to reliability measurement, identification of security vulnerabilities, usability evaluation, and software acceptance, for which different approaches would be taken. Note that,
in general, the test objectives vary with the test target; different purposes are addressed at different levels of testing. The subtopics listed below are those most
often cited in the literature. Note that some kinds of testing are more appropriate for custom-made software packages installation testing, for example and others for consumer products, like beta testing.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Objectives_of_Testing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Objectives of Testing</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Observational_Study</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">An observational or case study is an empirical inquiry that makes observations of processes or phenomena within a real-life context. While an experiment deliberately ignores context, an observational or case study includes context as part of the observation. A case study is most useful when the focus of the study is on how and why questions, when the behavior of those involved in the study cannot be manipulated, and when contextual conditions are relevant and the boundaries
between the phenomena and context are not clear.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Observational_Study</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Observational Study</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Offshoring_and_Outsourcing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Offshoring means executing a business activity beyond sales and marketing outside the home country of an enterprise. Enterprises typically either have their offshoring branches in lowcost countries or they ask specialized companies abroad to execute the respective activity. Offshoring should therefore not be confused with outsourcing. Offshoring within a company is called captive offshoring. Outsourcing is the result-oriented relationship with a supplier who executes
business activities for an enterprise when, traditionally, those activities were executed inside the enterprise. Outsourcing is site-independent. The supplier can reside in the neighborhood of the enterprise or offshore (outsourced offshoring). Software engineering economics provides the basic criteria and business tools to evaluate different sourcing mechanisms and control their performance. For instance, using an outsourcing supplier for software development and maintenance might reduce the cost per hour of software development, but increase the number of hours and capital expenses due to an increased need for
monitoring and communication.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Offshoring_and_Outsourcing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Offshoring and Outsourcing</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Operating_System_Abstractions</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The arsenal of OSs is abstraction. Corresponding to the five physical tasks, OSs use five abstractions: process/thread, virtual memory, file systems, input/output, and protection domains. The overall OS abstraction is the virtual machine. For each task area of OS, there is both a physical reality and a conceptual abstraction. The physical reality refers to the hardware resource under management; the conceptual abstraction refers to the interface the OS presents to the users/programs above. For example, in the thread model of the OS, the physical reality is the CPU and the
abstraction is multiple CPUs. Thus, a user doesn’t have to worry about sharing the CPU with others when working on the abstraction provided by an OS. In the virtual memory abstraction of an OS, the physical reality is the physical RAM or ROM (whatever), the abstraction is multiple unlimited memory space. Thus, a user doesn’t have to worry about sharing physical memory with others or about limited physical memory size. Abstractions may be virtual or transparent; in this context virtual applies to something that appears to be there, but isn’t (like usable memory
beyond physical), whereas transparent applies to something that is there, but appears not to be there (like fetching memory contents from disk or physical memory).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Operating_System_Abstractions</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Operating System Abstractions</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Operating_Systems_Basics</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Every system of meaningful complexity needs to be managed. A computer, as a rather complex electrical-mechanical system, needs its own manager for managing the resources and activities occurring on it. That manager is called an operating
system (OS).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Operating_Systems_Basics</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Operating Systems Basics</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Operating_Systems_Classification</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Different operating systems can have different functionality implementation. In the early days of the computer era, operating systems were relatively simple. As time goes on, the complexity and sophistication of operating systems increases
significantly. From a historical perspective, an operating system can be classified as one of the following: Batching OS; Multiprogrammed batching OS; Time-sharing OS; Real-time OS; Distributed OS; Embedded OS; Mainframe OS; Server OS; Multicomputer OS; Personal computers OS; Mobile device OS.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Operating_Systems_Classification</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Operating Systems Classification</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Operating_Systems_Overview</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Operating systems is a collection of software and firmware, that controls the execution of computer programs and provides such services as computer resource allocation, job control, input/output control, and file management in a computer system. Conceptually, an operating system is a computer program that manages the hardware resources and makes it easier to use by applications by presenting
nice abstractions. This nice abstraction is often called the virtual machine and includes such things as processes, virtual memory, and file systems. An OS hides the complexity of the underlying hardware and is found on all modern computers. The principal roles played by OSs are management and illusion. Management refers to the OS’s management (allocation and recovery) of physical resources among multiple competing users/applications/tasks. Illusion refers to the nice abstractions the OS provides.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Operating_Systems_Overview</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Operating Systems Overview</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Operations_on_Data_Structures</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">All data structures support some operations that produce a specific structure and ordering, or retrieve relevant data from the structure, store data into the structure, or delete data from the structure. Basic operations supported by all data structures
include create, read, update, and delete (CRUD). Create: Insert a new data entry into the structure; Read: Retrieve a data entry from the structure; Update: Modify an existing data entry; Delete: Remove a data entry from the structure. Some data structures also support additional operations; Find a particular element in the structure; Sort all elements according to some ordering; Traverse all elements in some specific order; Reorganize or rebalance the structure. Different structures support different operations with different efficiencies. The difference between operation efficiency can be significant. For example, it is easy to retrieve the last item inserted into a stack, but finding a particular element within a stack is rather slow and tedious.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Operations_on_Data_Structures</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Operations on Data Structures</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Optimization_Analysis</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The typical use of optimization analysis is to study a cost function over a range of values to find the point where overall performance is best. Software’s classic space-time tradeoff is an example of optimization; an algorithm that runs faster will often use more memory. Optimization balances the value of the faster runtime against the cost of the additional memory. Real options analysis can be used to quantify the value of project choices, including the value of delaying a decision. Such options are difficult to compute with precision. However, awareness
that choices have a monetary value provides insight in the timing of decisions such as increasing project staff or lengthening time to market to improve quality.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Optimization_Analysis</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Optimization Analysis</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Organizational_Context_for_SCM</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">To plan an SCM process for a project, it is necessary to understand the organizational context and the relationships among organizational elements. SCM interacts with several other activities or organizational elements. The organizational elements responsible for the software engineering supporting processes may be structured in various ways. Although the responsibility for performing certain SCM tasks might be assigned to other parts of the organization (such as the development organization), the overall responsibility for SCM often rests with a distinct organizational element or designated individual. Software is frequently developed as part of a larger system containing hardware and firmware elements. In this case, SCM activities take place in parallel with hardware and firmware CM activities and must be consistent with system-level CM. Note that firmware contains hardware and software; therefore, both hardware and software CM concepts are applicable. SCM might interface with an organization’s quality assurance activity on issues such as records management and nonconforming items. Regarding the former, some items under SCM control might also be project records subject to provisions of the organization’s quality assurance program. Managing nonconforming items is usually the responsibility of the quality assurance activity; however, SCM might assist with tracking and reporting on software configuration items falling into this category. Perhaps the closest relationship is with the software development and maintenance organizations. It is within this context that many of the software configuration control tasks are conducted. Frequently, the same tools support development, maintenance, and SCM purposes.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Organizational_Context_for_SCM</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Organizational Context for SCM</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Overview_of_Algorithms</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Abstractly speaking, algorithms guide the operations of computers and consist of a sequence of actions composed to solve a problem. Alternative definitions include but are not limited to: An algorithm is any well-defined computational procedure that takes some value or set of values as input and produces some value or set of values as output; An algorithm is a sequence of computational steps that transform the input into the output; An algorithm is a tool for solving a wellspecified computation problem. Of course, different definitions are favored by different people. Though there is no universally accepted definition, some agreement exists
that an algorithm needs to be correct, finite (in other words, terminate eventually or one must be able to write it in a finite number of steps), and unambiguous.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Overview_of_Algorithms</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Overview of Algorithms</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Overview_of_a_Computer_System</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Among all the systems, one that is obviously relevant to the software engineering community is the computer system. A computer is a machine that executes programs or software. It consists of a purposeful collection of mechanical, electrical, and electronic components with each component performing a preset function. Jointly, these components are able to execute the instructions that are given by the program. Abstractly speaking, a computer receives some input, stores and manipulates some data, and provides some output. The most distinct feature of a computer is its ability to store and execute sequences of instructions called programs. An interesting phenomenon concerning the computer is the universal equivalence in functionality. According to Turing, all computers with a certain minimum capability are equivalent in their ability to perform computation tasks. In other words, given enough time and memory, all computers ranging from a netbook to a supercomputer are capable of computing exactly the same things,
irrespective of speed, size, cost, or anything else. Most computer systems have a structure that is known as the “von Neumann model,” which consists of five components: a memory for storing instructions and data, a central processing unit
for performing arithmetic and logical operations, a control unit for sequencing and interpreting instructions, input for getting external information into the memory, and output for producing results for the user.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Overview_of_a_Computer_System</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Overview of a Computer System</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Parallel_and_Distributed_Computing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Parallel computing is a computing paradigm that emerges with the development of multi-functional units within a computer. The main objective of parallel computing is to execute several tasks simultaneously on different functional units and thus improve throughput or response or both. Distributed computing, on the other hand, is a computing paradigm that emerges with the development of computer networks. Its main objective is to either make use of multiple computers in the network to accomplish things otherwise not possible within a single computer or improve computation efficiency by harnessing the power of multiple computers.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Parallel_and_Distributed_Computing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Parallel and Distributed Computing</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Parallel_and_Distributed_Computing_Models</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Since multiple computers/processors/cores are involved in distributed/parallel computing, some coordination among the involved parties is necessary to ensure correct behavior of the system. Different ways of coordination give rise to different computing models. The most common models in this regard are the shared memory (parallel) model and the message-passing (distributed) model. In a shared memory (parallel) model, all computers have access to a shared central memory where local caches are used to speed up the processing power. These caches use a protocol to insure the localized data is fresh and up to date, typically the MESI protocol. The algorithm designer chooses the program for execution by each computer. Access to the central memory can be synchronous or asynchronous, and must be coordinated such that coherency is maintained. Different access models have been invented for such a purpose. In a message-passing (distributed) model, all computers run some programs that collectively achieve some purpose. The system must work correctly regardless of the structure of the network. This model can be further classified into client-server (C/S), browser-server (B/S), and
n-tier models. In the C/S model, the server provides services and the client requests services from the server. In the B/S model, the server provides services and the client is the browser. In the n-tier model, each tier (i.e. layer) provides services to the tier immediately above it and requests services from the tier immediately below it.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Parallel_and_Distributed_Computing_Models</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Parallel and Distributed Computing Models</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Parallel_and_Distributed_Computing_Overview</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Traditionally, parallel computing investigates ways to maximize concurrency (the simultaneous execution of multiple tasks) within the boundary of a computer. Distributed computing studies distributed systems, which consists of multiple
autonomous computers that communicate through a computer network. Alternatively, distributed computing can also refer to the use of distributed systems to solve computational or transactional problems. In the former definition, distributed computing investigates the protocols, mechanisms, and strategies that provide the foundation for distributed computation; in the latter definition, distributed computing studies the ways of dividing a problem into many tasks and assigning such tasks to various computers involved in the computation. Fundamentally, distributed computing is another form of parallel computing, albeit on a grander scale. In distributed computing, the functional units are not ALU, FPU, or separate cores, but individual computers. For this reason, some people regard distributed computing as being the same as parallel computing. Because both distributed and parallel computing involve some form of concurrency, they are both also called concurrent computing.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Parallel_and_Distributed_Computing_Overview</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Parallel and Distributed Computing Overview</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Parameterization_and_Generics</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Parameterized types, also known as generics (Ada, Eiffel) and templates (C++), enable the definition of a type or class without specifying all the other types it uses. The unspecified types are supplied as parameters at the point of use. Parameterized types provide a third way (in addition to class inheritance and object composition) to compose behaviors in object-oriented software.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Parameterization_and_Generics</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Parameterization and Generics</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Pedagogical_Project</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">PPC (Pedagogical Course Project) approved in 2011 based on the guidelines of the National Education Council (CNE); In the curriculum guidelines for the Software Engineering courses of the major US engineering and computing associations, such as IEEE-CS and ACM, in the Reference Curricula of Computer Courses of the Brazilian Computer Society SBC</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Pedagogical_Project</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Pedagogical Project of the Bachelor&apos;s Degree in Software Engineering</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Perform_the_Measurement_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Integrate measurement procedures with relevant software processes. The measurement procedures, such as data collection, should be integrated into the software processes they are measuring. This may involve changing current software processes to accommodate data collection or generation activities. It may also involve analysis of current software processes to minimize additional effort and evaluation of the effect on employees to ensure that the measurement procedures will be accepted. Training and support may also need to be provided. Data analysis and reporting procedures are typically integrated into organizational and/or project processes in a similar manner. Collect data. Data should be collected, verified, and stored. Collection can sometimes be automated by using software engineering management tools to analyze data and develop reports. Data may be aggregated, transformed, or recoded as part of the analysis process, using a degree of rigor appropriate to the nature of the data and the information needs. The results of this analysis are typically indicators such as graphs, numbers, or other indications that will be interpreted, resulting in conclusions and recommendations to be presented to stakeholders. Communicate results. Information products should be documented and communicated to users and stakeholders.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Perform_the_Measurement_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Perform the Measurement Process</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Performance_Analysis_and_Tuning</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Code efficiency determined by architecture, detailed design decisions, and data-structure and algorithm selection influences an execution speed and size. Performance analysis is the investigation of a program’s behavior using information gathered as the program executes, with the goal of identifying possible hot spots in the program to be improved. Code tuning, which improves performance at the code level, is the practice of modifying correct code in ways that make it run more efficiently. Code tuning usually involves only small-scale
changes that affect a single class, a single routine, or, more commonly, a few lines of code. A rich set of code tuning techniques is available, including those for tuning logic expressions, loops, data transformations, expressions, and routines. Using a low-level language is another common technique for improving some hot spots in a program.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Performance_Analysis_and_Tuning</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Performance Analysis and Tuning</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Performance_Measurement</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Performance measurement is the process whereby an organization establishes and measures the  parameters used to determine whether programs, investments, and acquisitions are achieving the desired results. It is used to evaluate whether performance objectives are actually achieved; to control budgets, resources, progress, and decisions; and to improve performance.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Performance_Measurement</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Performance Measurement</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Plan_Management</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">For software projects, where change is an expectation, plans should be managed. Managing the project plan should thus be planned. Plans and processes selected for software development should be systematically monitored, reviewed, reported, and, when appropriate, revised. Plans associated with supporting processes (for example, documentation, software configuration management, and problem resolution) also should be managed. Reporting, monitoring, and controlling a project should fit within the selected SDLC and the realities of the project; plans should account for the various artifacts that will be used to manage the project.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Plan_Management</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Plan Management</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Plan_the_Measurement_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Characterize the organizational unit. The organizational unit provides the context for measurement, so the organizational context should be made explicit, including the constraints that the organization imposes on the measurement process. Identify information needs. Information needs are based on the goals, constraints, risks, and problems of the organizational unit. They may be derived from business, organizational, regulatory, and/or product objectives. Select measures. Candidate measures should be selected, with clear links to the information needs. Measures should be selected based on the priorities of the information needs and other criteria such as cost of collection, degree of process disruption during collection, ease of obtaining accurate, consistent data, and ease of analysis and reporting. Define data collection, analysis, and reporting procedures. This encompasses collection procedures and schedules, storage, verification, analysis, reporting, and configuration management of data. Select criteria for evaluating the information products. Criteria for evaluation are influenced by the technical and business objectives of the organizational unit. Provide resources for measurement tasks. The measurement plan should be reviewed and approved by the appropriate stakeholders to include all data collection procedures; storage, analysis, and reporting procedures; evaluation criteria; schedules; and responsibilities.  Identify resources to be made available for implementing the planned and approved measurement tasks. Resource availability may be staged in cases where changes are
to be piloted before widespread deployment. Acquire and deploy supporting technologies. This includes evaluation of available supporting technologies, selection of the most appropriate technologies, acquisition of those technologies,
and deployment of those technologies.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Plan_the_Measurement_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Plan the Measurement Process</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Planning_Horizon</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">When an organization chooses to invest in a particular proposal, money gets tied up in that proposal so-called “frozen assets.” The economic impact of frozen assets tends to start high and decreases over time. On the other hand, operating and maintenance costs of elements associated with the proposal tend to start low but increase over time. The total cost of the proposal that is, owning and operating a product is the sum of those two costs. Early on, frozen asset costs dominate; later, the operating and maintenance costs dominate. There is a point in time where the
sum of the costs is minimized; this is called the minimum cost lifetime. To properly compare a proposal with a fouryear life span to a proposal with a six-year life span, the economic effects of either cutting the six-year proposal by two years or investing the profits from the four-year proposal for another two years need to be addressed. The planning horizon, sometimes known as the study period, is the consistent time frame over which proposals are considered. Effects such as software lifetime will need to be factored into establishing a planning horizon. Once the planning horizon is established, several techniques are available for
putting proposals with different life spans into that planning horizon.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Planning_Horizon</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Planning Horizon</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Planning_for_SCM</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The planning of an SCM process for a given project should be consistent with the organizational context, applicable constraints, commonly accepted guidance, and the nature of the project (for example, size, safety criticality, and security). The major activities covered are software configuration identification, software configuration control, software configuration status accounting, software configuration auditing, and software release management and delivery. In addition, issues such as organization and responsibilities, resources and schedules, tool selection and implementation, vendor and subcontractor control, and interface control are typically considered. The results of the planning activity are recorded in an SCM Plan (SCMP), which is typically subject to SQA review and audit. Branching and merging strategies should be carefully planned and communicated, since they impact many SCM activities. From an SCM standpoint, a branch is defined as a set of evolving source file versions. Merging consists in combining different changes to the same file. This typically occurs when more than one person changes a configuration item. There are many branching and merging strategies in common use. The software development life cycle model also impacts SCM activities, and SCM planning should take this into account. For instance, continuous integration is a common practice in many software development approaches. It is typically characterized by frequent build-test-deploy cycles. SCM activities must be planned accordingly.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Planning_for_SCM</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Planning for SCM</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Platform_Standards</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Platform standards enable programmers to develop portable applications that can be executed in compatible environments without changes. Platform standards usually involve a set of standard services and APIs that compatible platform implementations must implement. Typical examples of platform standards are Java
2 Platform Enterprise Edition (J2EE) and the POSIX standard for operating systems (Portable Operating System Interface), which represents a set of standards implemented primarily for UNIX-based operating systems.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Platform_Standards</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Platform Standards</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Portfolio</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Portfolios are “projects, programs, subportfolios, and operations managed as a group to achieve strategic objectives.” Portfolios are used to group and then manage simultaneously all assets within a business line or organization. Looking to an entire portfolio makes sure that impacts of decisions are considered, such as resource allocation to a specific project which means that the same resources are not available for other projects.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Portfolio</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Portfolio</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Practical_Considerations</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Practical Considerations</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Practical_Considerations_Construction</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Construction is an activity in which the software engineer has to deal with sometimes chaotic and changing real-world constraints, and he or she must do so precisely. Due to the influence of realworld constraints, construction is more driven by practical considerations than some other KAs, and software engineering is perhaps most craftlike in the construction activities.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Practical_Considerations_Construction</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Practical Considerations</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Practical_Considerations_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">In practice, software processes and activities are often interleaved, overlapped, and applied concurrently. Software life cycle models that specify discrete software processes, with rigorously specified entry and exit criteria and prescribed boundaries and interfaces, should be recognized as idealizations that must be adapted to reflect the realities of software development and maintenance within the organizational context and business environment. Another practical consideration: software processes (such as configuration management, construction, and testing) can be adapted to facilitate operation, support, maintenance, migration, and retirement of the software. Additional factors to be considered when defining and tailoring a software life cycle model include required conformance to standards, directives, and policies; customer demands; criticality
of the software product; and organizational maturity and competencies. Other factors include the nature of the work (e.g., modification of existing software versus new development) and the application domain (e.g., aerospace versus hotel
management).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Practical_Considerations_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Practical Considerations</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Practical_Considerations_Quality</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Practical Considerations</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Practical_Considerations_Requirements</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The first level of topic decomposition presented in this KA may seem to describe a linear sequence of activities. This is a simplified view of the process. The requirements process spans the whole software life cycle. Change management and the maintenance of the requirements in a state that accurately mirrors the software to be built, or that has been built, are key to the success of the software engineering process. Not every organization has a culture of documenting and managing requirements. It is common in dynamic start-up companies, driven by a
strong “product vision” and limited resources, to view requirements documentation as unnecessary overhead. Most often, however, as these companies
expand, as their customer base grows, and as their product starts to evolve, they discover that they need to recover the requirements that motivated product features in order to assess the impact of proposed changes. Hence, requirements
documentation and change management are key to the success of any requirements process.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Practical_Considerations_Requirements</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Practical Considerations</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Practical_Considerations_Testing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">An important element of successful testing is a collaborative attitude towards testing and quality assurance activities. Managers have a key role in fostering a generally favorable reception towards failure discovery and correction during software development and maintenance; for instance, by overcoming the mindset of individual code ownership among programmers and by promoting a collaborative environment with team responsibility for anomalies in the code. The testing phases can be guided by various aims for example, risk-based testing uses the product risks to prioritize and focus the test strategy, and scenario-based testing defines test cases based on specified software scenarios. Test activities conducted at different levels, must be organized together with people, tools, policies, and measures into a well-defined process that is an integral part of the life cycle. Documentation is an integral part of the formalization of the test process. Test documents may include, among others, the test plan, test design specification, test procedure specification, test case specification, test log, and test incident report. The software under test is documented as the test item. Test documentation should be produced and continually updated to the same level of quality as other types of documentation in software engineering. Test documentation should also be under the control of software configuration
management. Moreover, test documentation includes work products that can provide material for user manuals and user training. Test-driven development (TDD) originated as one of the core XP (extreme programming) practices and consists of writing unit tests prior to writing the code to be tested. In this way, TDD develops the test cases as a surrogate for a software requirements specification document rather than as an independent check that the software has correctly implemented the requirements. Rather than a testing strategy, TDD is a practice that requires software developers to define and maintain unit tests; it thus can also have a positive impact on elaborating user needs and software requirements specifications.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Practical_Considerations_Testing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Practical Considerations</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Preconditions_Postconditions_and_Invariants</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">When modeling functions or methods, the software engineer typically starts with a set of assumptions about the state of the software prior to, during, and after the function or method executes. These assumptions are essential to the correct
operation of the function or method and are grouped, for discussion, as a set of preconditions, postconditions, and invariants. Preconditions: a set of conditions that must be satisfied prior to execution of the function or method. If these preconditions do not hold prior to execution of the function or method, the function or method may produce erroneous results; Postconditions: a set of conditions that is guaranteed to be true after the function or method has executed successfully. Typically, the postconditions represent how the state of the software has changed, how parameters passed to the function or method have changed, how data values have changed, or how the return value has been affected; Invariants: a set of conditions within the operational environment that persist (in
other words, do not change) before and after execution of the function or method. These invariants are relevant and necessary to the software and the correct operation of the function or method.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Preconditions_Postconditions_and_Invariants</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Preconditions, Postconditions, and Invariants</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Predicate_Logic</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A predicate is a verb phrase template that describes a property of objects or a relationship among objects represented by the variables. For example, in the sentence, The flower is red, the template is red is a predicate. It describes the
property of a flower. The same predicate may be used in other sentences too.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Predicate_Logic</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Predicate Logic</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Presentation_Skills</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software engineers rely on their presentation skills during software life cycle processes. For example, during the software requirements phase, software engineers may walk customers and teammates through software requirements
and conduct formal requirements reviews. During and after software design, software construction, and software maintenance, software engineers lead reviews, product walkthroughs, and training. All of these require the ability to present technical information to groups and solicit ideas or feedback. The software engineer’s ability to convey concepts effectively in a presentation therefore
influences product acceptance, management, and customer support; it also influences the ability of stakeholders to comprehend and assist in the product effort. This knowledge needs to be archived in the form of slides, knowledge writeup, technical whitepapers, and any other material utilized for knowledge creation.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Presentation_Skills</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Presentation Skills</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Price_and_Pricing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A price is what is paid in exchange for a good or service. Price is a fundamental aspect of financial modeling and is one of the four Ps of the marketing mix. The other three Ps are product, promotion, and place. Price is the only revenue-generating element amongst the four Ps; the rest are costs. Pricing is an element of finance and marketing. It is the process of determining what a company will receive in exchange for its products. Pricing factors include manufacturing cost, market placement, competition, market condition, and quality of product. Pricing applies prices to products and services based on factors such as fixed amount, quantity break, promotion or sales campaign, specific vendor quote, shipment or invoice date, combination of multiple orders, service offerings, and many others. The needs of the consumer can be converted into demand only if the consumer has the willingness and capacity to buy the product. Thus, pricing is very important in marketing. Pricing is initially done during the project initiation phase and is a part of “go” decision making.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Price_and_Pricing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Price and Pricing</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Prime_Number_GCD</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">An integer p &gt; 1 is prime if and only if it is not the product of any two integers greater than 1, for example, the numbers 2, 13, 29, 61, etc. are prime numbers. Nonprime integers greater than 1 are called composite numbers. A composite number may be composed by multiplying two integers greater than 1. There are many interesting applications of prime numbers; among them are the publickey cryptography scheme, which involves the exchange of public keys containing the product p*q of two random large primes p and q (a private key) that must be kept secret by a given party.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Prime_Number_GCD</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Prime Number, GCD</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Prioritization</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Prioritization involves ranking alternatives based on common criteria to deliver the best possible value. In software engineering projects, software requirements are often prioritized in order to deliver the most value to the client within constraints of schedule, budget, resources, and technology, or to provide for building product increments, where the first increments provide the highest value to the customer.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Prioritization</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Prioritization</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Problem_Solving_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The concepts, notions, and terminology introduced here form an underlying basis for understanding the role and scope of problem solving techniques.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Problem_Solving_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Problem Solving Techniques</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Problem_Solving_Using_Programs</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The uniqueness of computer software gives problem solving a flavor that is distinct from general engineering problem solving. To solve a problem using computers, we must answer the following questions. How do we figure out what to tell the computer to do? How do we convert the problem statement into an algorithm? How do we convert the algorithm into machine instructions? The first task in solving a problem using a computer is to determine what to tell the computer to
do. There may be many ways to tell the story, but all should take the perspective of a computer such that the computer can eventually solve the problem. In general, a problem should be expressed in such a way as to facilitate the development of
algorithms and data structures for solving it. The result of the first task is a problem statement. The next step is to convert the problem statement into algorithms that solve the problem. Once an algorithm is found, the final step converts the algorithm into machine instructions that form the final solution: software that solves the problem. Abstractly speaking, problem solving using a computer can be considered as a process of problem transformation in other words, the step-bystep
transformation of a problem statement into a problem solution. To the discipline of software engineering, the ultimate objective of problem solving is to transform a problem expressed in natural language into electrons running around a circuit.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Problem_Solving_Using_Programs</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Problem Solving Using Programs</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Process_Actors</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">This topic introduces the roles of the people who participate in the requirements process. This process is fundamentally interdisciplinary, and the requirements specialist needs to mediate between the domain of the stakeholder and that of software engineering. There are often many people involved besides the requirements specialist, each of whom has a stake in the software. The stakeholders will vary across projects, but will always include users/operators and customers (who need not be the same). Typical examples of software stakeholders include (but are not restricted to) the following: Users, customers, market analysts, regulators, software engineers. It will not be possible to perfectly satisfy the requirements of every stakeholder, and it is the software engineer’s job to negotiate tradeoffs that are both acceptable to the principal stakeholders and within budgetary, technical, regulatory, and other constraints. A prerequisite for this is that all the stakeholders be identified, the nature of their “stake” analyzed, and their requirements elicited.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Process_Actors</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Process Actors</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Process_Models</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The objective of this topic is to provide an understanding that the requirements process: is not a discrete front-end activity of the software life cycle, but rather a process initiated at the beginning of a project that continues to be refined throughout the life cycle; identifies software requirements as configuration items and manages them using the same software configuration management practices as other products of the software life cycle processes; needs to be adapted to the organization and project context. In particular, the topic is concerned with how
the activities of elicitation, analysis, specification, and validation are configured for different types of projects and constraints. The topic also includes activities that provide input into the requirements process, such as marketing and feasibility
studies.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Process_Models</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Process Models</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Process_Planning</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software development life cycle (SDLC) models span a continuum from predictive to adaptive. Predictive SDLCs are characterized by development of detailed software requirements, detailed project planning, and minimal planning for iteration among development phases. Adaptive SDLCs are designed to accommodate emergent software requirements and iterative adjustment of plans. Adaptive SDLCs are characterized by iterative development cycles. SDLCs in the mid-range of the SDLC continuum produce increments of functionality on either a preplanned schedule (on the predictive side of the continuum) or as the products
of frequently updated development cycles (on the adaptive side of the continuum).
Well-known SDLCs include the waterfall, incremental, and spiral models plus various forms of agile software development. Relevant methods  and tools should be selected as part of planning. Automated tools that will be used throughout the project should also be planned for and acquired. Tools may include tools for project scheduling, software requirements, software design, software construction,
software maintenance, software configuration management, software engineering process, software quality, and others.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Process_Planning</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Process Planning</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Process_Quality_and_Improvement</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">This topic is concerned with the assessment of the quality and improvement of the requirements process. Its purpose is to emphasize the key role the requirements process plays in terms of the  cost and timeliness of a software product and of the customer’s satisfaction with it. It will help to orient the requirements process with quality standards and process improvement models for software and systems. Process quality and improvement is closely related to both the Software Quality KA and Software Engineering Process KA, comprising requirements process coverage by process improvement standards and models; requirements process measures and benchmarking; improvement planning and implementation; security/CIA improvement/planning and implementation.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Process_Quality_and_Improvement</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Process Quality and Improvement</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Process_Support_and_Management</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">This section introduces the project management resources required and consumed by the requirements process. It establishes the context for the first topic (Initiation and Scope Definition) of the Software Engineering Management KA. Its principal purpose is to make the link between the process activities and the issues of cost, human resources, training, and tools.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Process_Support_and_Management</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Process Support and Management</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Process_for_the_Review_and_Revision_of_Requirements</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Given the inevitability of change, stakeholders should agree on the means by which requirements and scope are to be reviewed and revised (for example, change management procedures, iterative cycle retrospectives). This clearly implies that scope and requirements will not be “set in stone” but can and should be revisited at predetermined points as the project unfolds (for example, at the time when backlog priorities are created or at milestone reviews). If changes are accepted, then some form of traceability analysis and risk analysis should be used to ascertain the impact
of those changes. A managed-change approach can also form the basis for evaluation of success during closure of an incremental cycle or an entire project, based on changes that have occurred along the way.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Process_for_the_Review_and_Revision_of_Requirements</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Process for the Review and Revision of Requirements</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Product</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A product is an economic good (or output) that is created in a process that transforms product factors (or inputs) to an output. When sold, a product is a deliverable that creates both a value and an experience for its users. A product can be a combination of systems, solutions, materials, and services delivered internally (e.g., in-house IT solution) or externally (e.g., software application), either as-is or as a component for another product (e.g., embedded software).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Product</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Product</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Product_Life_Cycle</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A software product life cycle (SPLC) includes all activities needed to define, build, operate, maintain, and retire a software product or service and its variants. The SPLC activities of “operate,” “maintain,” and “retire” typically occur in a much longer time frame than initial software development. Also the operate-maintain-retire activities of an SPLC typically consume more total effort and other resources than the SDLC activities. The value contributed by a software product or associated services can be objectively determined during the “operate and maintain” time frame. Software engineering economics should be concerned with all SPLC activities, including the activities after initial product release.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Product_Life_Cycle</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Product Life Cycle</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Product_and_Process_Requirements</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A product requirement is a need or constraint on the software to be developed (for example, “The software shall verify that a student meets all prerequisites before he or she registers for a course”). A process requirement is essentially a constraint
on the development of the software (for example, “The software shall be developed using a RUP process”). Some software requirements generate implicit process requirements. The choice of verification technique is one example. Another might be the use of particularly rigorous analysis techniques (such as formal specification methods) to reduce faults that can lead to inadequate reliability. Process requirements may also be imposed directly by the development organization, their customer, or a third party such as a safety regulator.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Product_and_Process_Requirements</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Product and Process Requirements</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Productivity</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Productivity is the ratio of output over input from an economic perspective. Output is the value delivered. Input covers all resources (e.g., effort) spent to generate the output. Productivity combines efficiency and effectiveness from a valueoriented
perspective: maximizing productivity is about generating highest value with lowest resource consumption.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Productivity</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Productivity</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Professional_Practice_Activities</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Participation in the Executive Board of the Junior Engineering Company (EJEL), participation in projects carried out by EJEL, extracurricular internships in the technical area, technological development projects in companies.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Professional_Practice_Activities</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Professional practice activities</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Professionalism</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A software engineer displays professionalism notably through adherence to codes of ethics and professional conduct and to standards and practices that are established by the engineer’s professional community. The professional community is often represented by one or more professional societies; those societies publish codes of ethics and professional conduct as well as criteria for admittance to the community. Those criteria form the basis for accreditation and licensing activities and may be used as a measure to determine engineering competence or negligence.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Professionalism</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Professionalism</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Profiling_Performance_Analysis_and_Slicing_Tools</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Performance analysis tools are usually used to support code tuning. The most common performance analysis tools are profiling tools. An execution profiling tool monitors the code while it runs and records how many times each statement
is executed or how much time the program spends on each statement or execution path. Profiling the code while it is running gives insight into how the program works, where the hot spots are, and where the developers should focus the
code tuning efforts. Program slicing involves computation of the set of program statements (i.e., the program slice) that may affect the values of specified variables
at some point of interest, which is referred to as a slicing criterion. Program slicing can be used for locating the source of errors, program understanding, and optimization analysis. Program slicing tools compute program slices for various programming languages using static or dynamic analysis methods.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Profiling_Performance_Analysis_and_Slicing_Tools</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Profiling, Performance Analysis, and Slicing Tools</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Program</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A program is “a group of related projects, subprograms, and program activities managed in a coordinated way to obtain benefits not available from managing them individually.” Programs are often used to identify and manage different
deliveries to a single customer or market over a time horizon of several years.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Program</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Program</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Program_Comprehension</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Programmers spend considerable time reading and understanding programs in order to implement changes. Code browsers are key tools for program comprehension and are used to organize and present source code. Clear and concise documentation can also aid in program comprehension.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Program_Comprehension</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Program Comprehension</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Programming_Fundamentals</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Programming is composed of the methodologies or activities for creating computer programs that perform a desired function. It is an indispensible part in software construction. In general, programming can be considered as the process of designing, writing, testing, debugging, and maintaining the source code. This source code is written in a programming language. The process of writing source code often requires expertise in many different subject areas including knowledge of the application domain, appropriate data structures, specialized algorithms, various language constructs, good programming techniques, and software
engineering.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Programming_Fundamentals</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Programming Fundamentals</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Programming_Language_Basics</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Using computers to solve problems involves programming which is writing and organizing  instructions telling the computer what to do at each step. Programs must be written in some programming language with which and through which we describe necessary computations. In other words, we use the facilities provided by a
programming language to describe problems, develop algorithms, and reason about problem solutions. To write any program, one must understand at least one programming language.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Programming_Language_Basics</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Programming Language Basics</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Programming_Language_Overview</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A programming language is designed to express computations that can be performed by a computer. In a practical sense, a programming language is a notation for writing programs and thus should be able to express most data structures and algorithms. Some, but not all, people restrict the term “programming language” to those languages that can express all possible algorithms. Not all languages have the same importance and popularity. The most popular ones are often defined by a specification document established by a well-known and respected organization. For example, the C programming language is specified by an ISO standard named ISO/IEC 9899. Other languages, such as Perl and Python, do not enjoy such treatment and often have a dominant
implementation that is used as a reference.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Programming_Language_Overview</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Programming Language Overview</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Programming_Paradigms</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Programming is highly creative and thus somewhat personal. Different people often write different programs for the same requirements. This diversity of programming causes much difficulty in the construction and maintenance of large complex software. Various programming paradigms have been developed over the years to put some standardization into this highly creative and personal activity. When one programs, he or she can use one of several programming paradigms to write the code.  Unstructured Programming: In unstructured programming, a programmer follows his/her hunch to write the code in whatever way he/she likes as long as the function is operational. Often, the practice is to write code to fulfill a specific utility without regard to anything else. Programs written this way exhibit no particular structure thus the name “unstructured programming.” Unstructured programming is also sometimes called ad hoc programming. Structured/Procedural/ Imperative Programming: A hallmark of structured programming is the use of well-defined control structures, including procedures (and/or functions) with each procedure (or function) performing a specific task.
Object-Oriented Programming: While procedural programming organizes programs around procedures, object-oriented programming (OOP) organize a program around objects, which are abstract data structures that combine both data
and methods used to access or manipulate the data.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Programming_Paradigms</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Programming Paradigms</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Project</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A project is “a temporary endeavor undertaken to create a unique product, service, or result”. In software engineering, different project types are distinguished (e.g., product development, outsourced services, software maintenance, service creation, and so on). During its life cycle, a software product may require many projects. For
example, during the product conception phase, a project might be conducted to determine the customer need and market requirements; during maintenance, a project might be conducted to produce a next version of a product.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Project</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Project</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Project_Life_Cycle</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Project life cycle activities typically involve five process groups—Initiating, Planning, Executing, Monitoring and Controlling, and Closing. The activities within a software project life cycle are often interleaved, overlapped, and iterated
in various ways. For instance, agile product development within an SPLC involves multiple iterations that produce increments of deliverable software. An SPLC should include risk management and synchronization with different suppliers (if any), while providing auditable decision-making information (e.g., complying with product liability needs or governance regulations). The software project life cycle and the software product life cycle are interrelated; an SPLC may include several SDLCs.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Project_Life_Cycle</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Project Life Cycle</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Proof_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A proof is an argument that rigorously establishes the truth of a statement. Proofs can themselves be represented formally as discrete structures. Statements used in a proof include axioms and postulates that are essentially the underlying assumptions about mathematical structures, the hypotheses of the theorem to be proved, and previously proved theorems. A theorem is a statement that can be shown to be true. A lemma is a simple theorem used in the proof of other theorems. A corollary is a proposition that can be established directly from a theorem that has been proved. A conjecture is a statement whose truth value is unknown. When a conjecture’s proof is found, the conjecture becomes a theorem. Many times conjectures are shown to be false and, hence, are not theorems.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Proof_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Proof Techniques</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Properties_and_Expression_of_Models</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Properties of models are those distinguishing features of a particular model used to characterize its completeness, consistency, and correctness within the chosen modeling notation and tooling used. Properties of models include the following: Completeness: the degree to which all requirements have been implemented and verified within the model; Consistency: the degree to which the model contains no conflicting requirements, assertions, constraints, functions, or component descriptions; Correctness: the degree to which the model satisfies its requirements and design specifications and is free of defects. Models are constructed to represent real-world objects and their behaviors to answer specific questions about how the software is expected to operate. Interrogating the models either through exploration, simulation, or review may expose areas of uncertainty within the model and the software to which the model refers. The primary expression element of a model is an entity. An entity may represent concrete artifacts (for example, processors, sensors, or robots) or abstract artifacts (for example, software modules
or communication protocols). Model entities are connected to other entities using relations (in other words, lines or textual operators on target entities). Expression of model entities may be accomplished using textual or graphical modeling languages; both modeling language types connect model entities through specific language constructs. The meaning of an entity may be represented by its shape, textual attributes, or both. Generally, textual information adheres to language-specific syntactic structure.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Properties_and_Expression_of_Models</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Properties and Expression of Models</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Properties_of_Set</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Some of the important properties and laws of sets are mentioned below: Associative Laws; Commutative Laws; Distributive Laws; Identity Laws; Complement Laws; Idempotent Laws; Bound Laws; Absorption Laws; De Morgan’s Laws.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Properties_of_Set</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Properties of Set</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Proposals</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Making a business decision begins with the notion of a proposal. Proposals relate to reaching a business objective at the project, product, or portfolio level. A proposal is a single, separate option that is being considered, like carrying out
a particular software development project or not. Another proposal could be to enhance an existing software component, and still another might be to redevelop that same software from scratch. Each proposal represents a unit of choice either
you can choose to carry out that proposal or you can choose not to. The whole purpose of business decision-making is to figure out, given the current business circumstances, which proposals should be carried out and which shouldn’t.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Proposals</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Proposals</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Propositional_Logic</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A proposition is a statement that is either true or false, but not both. Let’s consider declarative sentences for which it is meaningful to assign either of the two status values: true or false.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Propositional_Logic</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Propositional Logic</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Prototyping</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Prototyping is commonly a means for validating the software engineer’s interpretation of the software requirements, as well as for eliciting new requirements. As with elicitation, there is a range of prototyping techniques and a number of points in the process where prototype validation may be appropriate. The advantage of prototypes is that they can make it easier to interpret the software engineer’s assumptions and, where needed, give useful feedback on why they are wrong. For example, the dynamic behavior of a user interface can be better understood through an animated prototype than through textual description or graphical models. The volatility of a requirement that is defined after prototyping has been done is extremely low because there is agreement between the stakeholder and the software engineer therefore, for safety-critical and crucial features prototyping would really help. There are also disadvantages, however. These include the danger of users’ attention being distracted from the core underlying functionality by cosmetic issues or quality problems with the prototype. For this reason, some advocate prototypes that avoid software, such as flip-chart-based mockups. Prototypes may be costly to develop. However, if they avoid the wastage of resources caused by trying to satisfy erroneous requirements, their cost can be more easily justified. Early prototypes may contain aspects of the final solution. Prototypes may be evolutionary as opposed to throwaway.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Prototyping</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Prototyping</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Prototyping_Engineering</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Constructing a prototype of a system is another abstraction process. In this case, an initial version of the system is constructed, often while the system is being designed. This helps the designers determine the feasibility of their design. There are many uses for a prototype, including the elicitation of requirements, the design and refinement of a user interface to the system, validation of functional requirements, and so on. The objectives and purposes for building the prototype
will determine its construction and the level of abstraction used. The role of prototyping is somewhat different between physical systems and software. With
physical systems, the prototype may actually be the first fully functional version of a system or it may be a model of the system. In software engineering, prototypes are also an abstract model of part of the software but are usually not constructed with all of the architectural, performance, and other quality characteristics expected
in the finished product. In either case, prototype construction must have a clear purpose and be planned, monitored, and controlled it is a technique to study a specific problem within a limited context.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Prototyping_Engineering</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Prototyping</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Prototyping_Methods</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software prototyping is an activity that generally creates incomplete or minimally functional versions of a software application, usually for trying out specific new features, soliciting feedback on software requirements or user interfaces, further exploring software requirements, software design, or implementation options, and/or gaining some other useful insight into the software. The software engineer selects a prototyping method to understand the least understood aspects or components of the software first; this approach is in contrast with other software engineering methods that usually begin development with the most understood portions first. This section discusses prototyping styles, targets, and evaluation techniques in brief. Prototyping Style: This addresses the various approaches to developing prototypes. Prototypes can be developed as throwaway code or paper products, as an evolution of a working design, or as an executable specification. Different prototyping life cycle processes are typically used for each style. Prototyping Target: The target of the prototype activity is the specific product being served by the prototyping effort. Examples of prototyping targets include a requirements specification, an architectural design element or component, an algorithm, or a humanmachine user interface. Prototyping Evaluation Techniques: A prototype may be used or evaluated in a number of ways by the software engineer or other project stakeholders, driven primarily by the underlying reasons that led to prototype development in the first place.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Prototyping_Methods</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Prototyping Methods</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Quality_Analysis_and_Evaluation_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Various tools and techniques can help in analyzing and evaluating software design quality. Software design reviews: informal and formalized techniques to determine the quality of design artifacts (for example, architecture reviews, design reviews, and inspections; scenario-based techniques; requirements tracing). Software design reviews can also evaluate security. Aids for installation, operation, and usage (for example, manuals and help files) can be reviewed; Static analysis: formal or semiformal static (nonexecutable) analysis that can be used to evaluate a design (for example, fault-tree analysis or automated cross-checking). Design vulnerability analysis (for example, static analysis for security weaknesses) can be performed if security is a concern. Formal design analysis uses mathematical models that allow designers to predicate the behavior and validate the performance of the software
instead of having to rely entirely on testing. Formal design analysis can be used to detect residual specification and design errors (perhaps caused by imprecision, ambiguity, and sometimes other kinds of mistakes); Simulation and prototyping: dynamic techniques to evaluate a design (for example, performance simulation or feasibility prototypes).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Quality_Analysis_and_Evaluation_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Quality Analysis and Evaluation Techniques</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Quality_Attributes</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Various attributes contribute to the quality of a software design, including various “-ilities” (maintainability, portability, testability, usability) and “-nesses” (correctness, robustness). There is an interesting distinction between quality attributes discernible at runtime (for example, performance, security, availability, functionality, usability), those not discernible at runtime (for example, modifiability, portability, reusability, testability), and those related to the architecture’s intrinsic qualities (for example, conceptual integrity, correctness, completeness).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Quality_Attributes</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Quality Attributes</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Quality_Management</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software quality requirements should be identified, perhaps in both quantitative and qualitative terms, for a software project and the associated work products. Thresholds for acceptable quality measurements should be set for each software
quality requirement based on stakeholder needs and expectations. Procedures concerned with ongoing Software Quality Assurance (SQA) and quality improvement throughout the development process, and for verification and validation of the deliverable software product, should also be specified during quality planning.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Quality_Management</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Quality Management</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Quality_of_Measurement_Results</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The quality of process and product measurement results is primarily determined by the reliability and validity of the measured results. Measurements that do not satisfy these quality criteria can result in incorrect interpretations and faulty software process improvement initiatives. Other desirable properties of software measurements include ease of collection, analysis, and presentation plus a strong correlation between cause and effect. The Software Engineering Measurement topic in the Software Engineering Management KA describes a process for implementing a software measurement program.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Quality_of_Measurement_Results</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Quality of Measurement Results</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Quantifiable_Requirements</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software requirements should be stated as clearly and as unambiguously as possible, and, where appropriate, quantitatively. It is important to avoid vague and unverifiable requirements that depend for their interpretation on subjective judgment (“the software shall be reliable”; “the software shall be user-friendly”). This is particularly important for nonfunctional requirements. Two examples of quantified requirements are the following: a call center’s software must increase the center’s throughput by 20%; and a system shall have a probability of generating a
fatal error during any hour of operation of less than 1 * 10−8. The throughput requirement is at a very high level and will need to be used to derive a number of detailed requirements. The reliability requirement will tightly constrain the system
architecture.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Quantifiable_Requirements</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Quantifiable Requirements</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Reading_Understanding_and_Summarizing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software engineers are able to read and understand technical material. Technical material includes reference books, manuals, research papers, and program source code. Reading is not only a primary way of improving skills, but also a way of gathering information necessary for the completion of engineering goals. A software engineer sifts through accumulated information, filtering out the pieces that will be most helpful. Customers may request that a software engineer summarize the results of such information gathering for them, simplifying
or explaining it so that they may make the final choice between competing solutions. Reading and comprehending source code is also a component of information gathering and problem solving. When modifying, extending, or rewriting software, it is critical to understand both its implementation directly derived from the presented code and its design, which must often be inferred.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Reading_Understanding_and_Summarizing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Reading, Understanding, and Summarizing</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Reengineering</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Reengineering is defined as the examination and alteration of software to reconstitute it in a new form, and includes the subsequent implementation of the new form. It is often not undertaken to improve maintainability but to replace aging legacy software. Refactoring is a reengineering technique that aims at reorganizing a program without changing its behavior. It seeks to improve a program structure and its maintainability. Refactoring techniques can be used during minor changes.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Reengineering</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Reengineering</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Relation_and_Function</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A relation is an association between two sets of information. For example, let’s consider a set of residents of a city and their phone numbers. The pairing of names with corresponding phone numbers is a relation. This pairing is ordered for the entire relation. In the example being considered, for each pair, either the name comes first followed by the phone number or the reverse. The set from which the first element is drawn is called the domain set and the other set is called the range set. The domain is what you start with and the range is what you end up with. A function is a well-behaved relation. A relation R(X, Y) is well behaved if the function maps every element of the domain set X to a single element of the range set Y. Let’s consider domain set X as a set of persons and let range set Y store their phone numbers. Assuming that a person may have more than one phone number, the relation being considered is not a function. However, if we draw a relation between names of residents and their date of births with the name set as domain, then this becomes a well-behaved relation and hence a function. This means that, while all functions are relations, not all relations are functions. In case of a function given an x, one gets one and exactly one y for each ordered pair (x, y).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Relation_and_Function</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Relation and Function</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Relationship_of_Testing_to_Other_Activities</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software testing is related to, but different from, static software quality management techniques, proofs of correctness, debugging, and program construction. However, it is informative to consider testing from the point of view of software quality analysts and of certifiers. Testing vs. Static Software Quality Management Techniques; Testing vs. Correctness Proofs and Formal Verification; Testing vs. Debugging; Testing vs. Program Construction.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Relationship_of_Testing_to_Other_Activities</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Relationship of Testing to Other Activities</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Reliability_and_Validity</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A basic question to be asked for any measurement method is whether the proposed measurement method is truly measuring the concept with good quality. Reliability and validity are the two most important criteria to address this question.
The reliability of a measurement method is the extent to which the application of the measurement method yields consistent measurement results. Essentially, reliability refers to the consistency of the values obtained when the same item is measured a number of times. When the results agree with each other, the measurement method is said to be reliable. Reliability usually depends on the operational definition. It can be quantified by using the index of variation, which is computed as the ratio between the standard deviation and the mean. The smaller the index, the more reliable the measurement results. Validity refers to whether the measurement method really measures what we intend to measure. Validity of a measurement method may be looked at from three different perspectives: namely, construct validity, criteria validity, and content validity.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Reliability_and_Validity</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Reliability and Validity</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Replacement_and_Retirement_Decisions</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A replacement decision is made when an organization already has a particular asset and they are considering replacing it with something else; for example, deciding between maintaining and supporting a legacy software product or redeveloping
it from the ground up. Replacement decisions use the same business decision process as described above, but there are additional challenges: sunk cost and salvage value. Retirement decisions are also about getting out of an activity altogether, such as when a software company considers not selling a software product anymore or a hardware manufacturer considers not building and selling a
particular model of computer any longer. Retirement decision can be influenced by lock-in factors such as technology dependency and high exit costs.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Replacement_and_Retirement_Decisions</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Replacement and Retirement Decisions</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Reporting</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">At specified and agreed-upon times, progress to date should be reported both within the organization (for example, to a project steering committee) and to external stakeholders (for example, clients or users). Reports should focus on
the information needs of the target audience as opposed to the detailed status reporting within the project team.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Reporting</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Reporting</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Requesting_Evaluating_and_Approving_Software_Changes</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The first step in managing changes to controlled items is determining what changes to make. The software change request process provides formal procedures for submitting and recording change requests, evaluating the potential cost and impact of a proposed change, and accepting, modifying, deferring, or rejecting the proposed change. A change request (CR) is a request to expand or reduce the project scope; modify policies, processes, plans, or procedures; modify costs or budgets; or revise schedules. Software Configuration Control Board: The authority for accepting or rejecting proposed changes rests with an entity typically known as a Configuration Control Board (CCB). In smaller projects, this authority may actually reside with the leader or an assigned individual rather than a multiperson board. There can be multiple levels of change authority depending on a variety of criteria such as the criticality of the item involved, the nature of the change (for example, impact on budget and schedule), or the project’s current point in the life cycle. Software Change Request Process: An effective software change request (SCR) process requires the use of supporting tools and procedures for originating change requests, enforcing the flow of the change process, capturing CCB decisions, and reporting change process information. A link between this tool capability and the problem-reporting system can facilitate the tracking of solutions for reported problems.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Requesting_Evaluating_and_Approving_Software_Changes</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Requesting, Evaluating, and Approving Software Changes</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Requirements_Analysis</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">This topic is concerned with the process of analyzing requirements to detect and resolve conflicts between requirements; discover the bounds of the software and how it must interact with its organizational and operational environment; elaborate system requirements to derive software requirements. The traditional view of requirements analysis has been that it be reduced to conceptual modeling using one of a number of analysis methods, such as the structured analysis method. While conceptual modeling is important, we include the classification of requirements to help inform tradeoffs between requirements (requirements classification) and the process of establishing these tradeoffs (requirements negotiation). Care must be taken to describe requirements precisely enough to enable the requirements to be validated, their implementation to be verified, and their costs to be estimated.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Requirements_Analysis</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Requirements Analysis</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Requirements_Attributes</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Requirements should consist not only of a specification of what is required, but also of ancillary information, which helps manage and interpret the requirements. Requirements attributes must be defined, recorded, and updated as the software
under development or maintenance evolves. This should include the various classification dimensions of the requirement and the verification method or relevant acceptance test plan section. It may also include additional information, such as a summary rationale for each requirement, the source of each requirement, and a change history. The most important requirements attribute, however, is an identifier that allows the requirements to be uniquely and unambiguously identified.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Requirements_Attributes</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Requirements Attributes</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Requirements_Classification</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Requirements can be classified on a number of dimensions. Examples include the following: The requirement is functional or nonfunctional, the requirement is derived from one or more high-level requirements or an emergent property, or is being imposed directly on the software by a stakeholder or some other source, the requirement is on the product or the process. Requirements on the process can constrain the choice of contractor, the software engineering process to be adopted, or the standards to be adhered to, the requirement priority, the scope of the requirement, volatility/stability. Some requirements will change during the life cycle of the software and even during the development process itself. It is useful if some estimate of the likelihood that a requirement will change can be made. For example, in a banking application, requirements for functions to calculate and credit interest to customers’ accounts are likely to be more stable than a requirement to support a particular kind of tax-free account. The former reflects a fundamental feature of the banking domain (that accounts can earn interest), while the latter may be rendered obsolete by a change to government legislation. Flagging potentially volatile requirements can help the software engineer establish a design that is more tolerant of change. Other classifications may be appropriate,
depending upon the organization’s normal practice and the application itself. There is a strong overlap between requirements classification and requirements attributes.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Requirements_Classification</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Requirements Classification</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Requirements_Elicitation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Requirements elicitation is concerned with the origins of software requirements and how the software engineer can collect them. It is the first stage in building an understanding of the problem the software is required to solve. It is fundamentally a human activity and is where the stakeholders are identified and relationships established between the development team and the customer. It is variously termed “requirements capture,” “requirements discovery,” and “requirements
acquisition.” One of the fundamental principles of a good requirements elicitation process is that of effective communication between the various stakeholders. This communication continues through the entire Software Development Life Cycle
(SDLC) process with different stakeholders at different points in time. Before development begins, requirements specialists may form the conduit for this communication. They must mediate between the domain of the software users (and other stakeholders) and the technical world of the software engineer. A set of internally consistent models at different levels of abstraction facilitate communications between software users/stakeholders and software engineers.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Requirements_Elicitation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Requirements Elicitation</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Requirements_Negotiation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Another term commonly used for this subtopic is “conflict resolution.” This concerns resolving problems with requirements where conflicts occur between two stakeholders requiring mutually incompatible features, between requirements and resources, or between functional and nonfunctional requirements, for example. In most cases, it is unwise for the software engineer to make a unilateral decision, so it becomes necessary to consult with the stakeholder(s) to reach a consensus on an appropriate tradeoff. It is often important, for contractual reasons, that such decisions be traceable back to the customer. We have classified this as a software requirements analysis topic because problems emerge as the result of analysis. However, a strong case can also be made for considering it a requirements validation topic. Requirements prioritization is necessary, not only as a means to filter important requirements, but also in order to resolve conflicts and plan for
staged deliveries, which means making complex decisions that require detailed domain knowledge and good estimation skills. However, it is often difficult to get real information that can act as a basis for such decisions. In addition, requirements
often depend on each other, and priorities are relative. In practice, software engineers perform requirements prioritization frequently without knowing about all the requirements.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Requirements_Negotiation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Requirements Negotiation</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Requirements_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">This section introduces the software requirements process, orienting the remaining five topics and showing how the requirements process dovetails with the overall software engineering process.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Requirements_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Requirements Process</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Requirements_Reviews</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Perhaps the most common means of validation is by inspection or reviews of the requirements document(s). A group of reviewers is assigned a brief to look for errors, mistaken assumptions, lack of clarity, and deviation from standard practice.
The composition of the group that conducts the review is important (at least one representative of the customer should be included for a customer-driven project, for example), and it may help to provide guidance on what to look for in the form of checklists. Reviews may be constituted on completion of the system definition document, the system specification document, the software requirements specification document, the baseline specification for a new release, or at any other step in the process.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Requirements_Reviews</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Requirements Reviews</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Requirements_Sources</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Requirements have many sources in typical software, and it is essential that all potential sources be identified and evaluated. This topic is designed to promote awareness of the various sources of software requirements and of the frameworks for managing them. The main points covered are as follows: Goals, domain knowledge, stakeholders, business rules, the operational environment, the organizational environment.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Requirements_Sources</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Requirements Sources</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Requirements_Specification</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">For most engineering professions, the term “specification” refers to the assignment of numerical values or limits to a product’s design goals. In software engineering, “software requirements specification” typically refers to the production of a document that can be systematically reviewed, evaluated, and approved. For complex systems, particularly those involving substantial nonsoftware components, as many as three different types of documents are produced: system definition, system requirements, and software requirements. For simple software products, only the third of these is required. All three documents are described here, with the understanding that they may be combined as appropriate.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Requirements_Specification</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Requirements Specification</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Requirements_Tracing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Requirements tracing is concerned with recovering the source of requirements and predicting the effects of requirements. Tracing is fundamental to performing impact analysis when requirements change. A requirement should be traceable backward to the requirements and stakeholders that motivated it (from a software requirement back to the system requirement(s) that it helps satisfy, for example). Conversely, a requirement should be traceable forward into the requirements and design entities that satisfy it (for example, from a system requirement into the software requirements that have been elaborated from it, and on into the code modules that implement it, or the test cases related to that code and even a given section on the user manual which describes the actual functionality) and into the test case that verifies it. The requirements tracing for a typical project will form a complex directed acyclic graph (DAG). Maintaining an up-todate graph or traceability matrix is an activity that must be considered during the whole life cycle of a product. If the traceability information is not updated as changes in the requirements continue to happen, the traceability information becomes unreliable for impact analysis.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Requirements_Tracing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Requirements Tracing</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Requirements_Validation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The requirements documents may be subject to validation and verification procedures. The requirements may be validated to ensure that the software engineer has understood the requirements; it is also important to verify that a requirements document conforms to company standards and that it is understandable, consistent, and complete. In cases where documented company standards or terminology are inconsistent with widely accepted standards, a mapping between the two should be agreed on and appended to the document.
Formal notations offer the important advantage of permitting the last two properties to be proven (in a restricted sense, at least). Different stakeholders,
including representatives of the customer and developer, should review the document(s). Requirements documents are subject to the same configuration management practices as the other deliverables of the software life cycle processes.
When practical, the individual requirements are also subject to configuration management, generally using a requirements management tool. It is normal to explicitly schedule one or more points in the requirements process where the
requirements are validated. The aim is to pick up any problems before resources are committed to addressing the requirements. Requirements validation is concerned with the process of examining the requirements document to ensure that it defines the right software (that is, the software that the users expect).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Requirements_Validation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Requirements Validation</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Research_Activities</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Participation in research centers or projects of scientific initiation Institutional Program of Scientific Initiation Grants (PIBIC), publication of works, participation in seminars and scientific initiation events related to graduation;</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Research_Activities</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Research activities</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Resource_Allocation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Equipment, facilities, and people should be allocated to the identified tasks, including the allocation of responsibilities for completion of various elements of a project and the overall project. A matrix that shows who is responsible for, accountable for, consulted about, and informed about each of the tasks can be used. Resource allocation is based on, and constrained by, the availability of resources and their optimal use, as well as by issues relating to personnel (for example, productivity of individuals and teams, team dynamics, and team structures).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Resource_Allocation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Resource Allocation</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Retirement</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Once software has reached the end of its useful life, it must be retired. An analysis should be performed to assist in making the retirement decision. This analysis should be included in the retirement plan, which covers retirement requirements,
impact, replacement, schedule, and effort. Accessibility of archive copies of data may also be included. Retiring software entails a number of activities similar to migration.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Retirement</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Retirement</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Retrospective_Study</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A retrospective study involves the analysis of historical data. Retrospective studies are also known as historical studies. This type of study uses data (regarding some phenomenon) that has been archived over time. This archived data is then analyzed
in an attempt to find a relationship between variables, to predict future events, or to identify trends. The quality of the analysis results will depend on the quality of the information contained in the archived data. Historical data may be incomplete,
inconsistently measured, or incorrect.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Retrospective_Study</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Retrospective Study</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Return_on_Capital_Employed</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The return on capital employed (ROCE) is a measure of the profitability of a company or business unit. It is defined as the ratio of a gross profit before taxes and interest (EBIT) to the total assets minus current liabilities. It describes the return on
the used capital.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Return_on_Capital_Employed</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Return on Capital Employed</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Return_on_Investment</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Return on investment (ROI) is a measure of the profitability of a company or business unit. It is defined as the ratio of money gained or lost (whether realized or unrealized) on an investment relative to the amount of money invested. The purpose of ROI varies and includes, for instance, providing a rationale for future investments and acquisition decisions.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Return_on_Investment</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Return on Investment</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Reuse</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Reuse refers to using existing assets in solving different problems. In software construction, typical assets that are reused include libraries, modules, components, source code, and commercial off-the-shelf (COTS) assets. Reuse is best practiced
systematically, according to a well-defined, repeatable process. Systematic reuse can enable significant software productivity, quality, and cost improvements. Reuse has two closely related facets: “construction  for reuse” and “construction with reuse.” The former means to create reusable software assets, while the latter means to reuse software assets in the construction of a new solution. Reuse often transcends the boundary of projects, which means reused assets can be constructed in other projects or organizations.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Reuse</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Reuse</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Reverse_Engineering</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Reverse engineering is the process of analyzing software to identify the software’s components and their inter-relationships and to create representations of the software in another form or at higher levels of abstraction. Reverse engineering
is passive; it does not change the software or result in new software. Reverse engineering efforts produce call graphs and control flow graphs from source code. One type of reverse engineering is redocumentation. Another type is design recovery. Finally, data reverse engineering, where logical schemas are recovered from physical databases, has grown in importance over the last few years. Tools are key for reverse engineering and related tasks such as redocumentation and design recovery.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Reverse_Engineering</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Reverse Engineering</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Review_and_Evaluation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">At prespecified times and as needed, overall progress towards achievement of the stated objectives and satisfaction of stakeholder (user and customer) requirements should be evaluated. Similarly, assessments of the effectiveness of the software process, the personnel involved, and the tools and methods employed should also be undertaken regularly and as determined by circumstances.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Review_and_Evaluation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Review and Evaluation</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Reviewing_and_Evaluating_Performance</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Periodic performance reviews for project personnel can provide insights as to the likelihood of adherence to plans and processes as well as possible areas of difficulty (for example, team member conflicts). The various methods, tools, and techniques employed should be evaluated for their effectiveness and appropriateness, and the process being used by the project should also be systematically and periodically assessed for relevance, utility, and efficacy in the project context. Where appropriate, changes should be made and managed.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Reviewing_and_Evaluating_Performance</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Reviewing and Evaluating Performance</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Reviews_and_Audits</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Reviews and audit processes are broadly defined as static meaning that no software programs or models are executed examination of software engineering artifacts with respect to standards that have been established by the organization or project for those artifacts. Different types of reviews and audits are distinguished by their purpose, levels of independence, tools and techniques, roles, and by the subject of the activity. Product assurance and process assurance audits are typically
conducted by software quality assurance (SQA) personnel who are independent of development teams. Management reviews are conducted by organizational or project management. The engineering staff conducts technical reviews. Management reviews evaluate actual project results with respect to plans; Technical reviews (including inspections, walkthrough, and desk checking) examine engineering work-products; Process assurance audits. SQA process
assurance activities make certain that the processes used to develop, install, operate, and maintain software conform to contracts, comply with any imposed laws, rules, and regulations and are adequate, efficient and effective for their intended purpose; Product assurance audits. SQA product assurance activities make certain to provide evidence that software products and related documentation are identified in and comply with contracts; and ensure that nonconformances are identified and addressed.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Reviews_and_Audits</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Reviews and Audits</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Rings</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">If we take an Abelian group and define a second operation on it, a new structure is found that is different from just a group. If this second operation is associative and is distributive over the first, then we have a ring.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Rings</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Rings</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Risk_Management</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Risk and uncertainty are related but distinct concepts. Uncertainty results from lack of information. Risk is characterized by the probability of an event that will result in a negative impact plus a characterization of the negative impact on a project. Risk is often the result of uncertainty. The converse of risk is opportunity, which is characterized by the probability that an event having a positive outcome might occur. Risk management entails identification of risk factors and analysis of the probability and potential impact of each risk factor, prioritization of risk factors, and development of risk mitigation strategies to reduce the probability and minimize
the negative impact if a risk factor becomes a problem. Risk assessment methods (for example, expert judgment, historical data, decision trees, and process simulations) can sometimes be used in order to identify and evaluate risk factors.
Project abandonment conditions can also be determined at this point in discussion with all relevant stakeholders. Software-unique aspects of risk, such as software engineers’ tendency to add unneeded features, or the risks related to software’s
intangible nature, can influence risk management of a software project. Particular attention should be paid to the management of risks related to software quality requirements such as safety or security. Risk management should be done not only at the beginning of a project, but also at periodic intervals throughout the project life cycle.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Risk_Management</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Risk Management</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Risk_and_Uncertainty</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Risk and Uncertainty</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Root_Cause_Analysis</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Root cause analysis (RCA) is a process designed to investigate and identify why and how an undesirable event has happened. Root causes are underlying causes. The investigator should attempt to identify specific underlying causes of the event that has occurred. The primary objective of RCA is to prevent recurrence of the undesirable event. Thus, the more specific the investigator can be about why an event occurred, the easier it will be to prevent recurrence. A common way to identify specific underlying cause(s) is to ask a series of why questions.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Root_Cause_Analysis</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Root Cause Analysis</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Runtime_Configuration_and_Internationalization</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">To achieve more flexibility, a program is often constructed to support late binding time of its variables. Runtime configuration is a technique that binds variable values and program settings when the program is running, usually by updating and reading configuration files in a just-in-time mode. Internationalization is the technical activity of preparing a program, usually interactive software, to support multiple locales. The corresponding activity, localization, is the activity of
modifying a program to support a specific local language. Interactive software may contain dozens or hundreds of prompts, status displays, help messages, error messages, and so on. The design and construction processes should accommodate
string and character-set issues including which character set is to be used, what kinds of strings are used, how to maintain the strings without changing the code, and translating the strings into different languages with minimal impact on the
processing code and the user interface.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Runtime_Configuration_and_Internationalization</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Runtime Configuration and Internationalization</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/SCM_Plan</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The results of SCM planning for a given project are recorded in a software configuration management plan (SCMP), a “living document” which serves as a reference for the SCM process. It is maintained (that is, updated and approved) as necessary during the software life cycle. In implementing the SCMP, it is typically necessary to develop a number of more detailed, subordinate procedures defining how specific requirements will be carried out during day-to-day activities for example, which branching strategies will be used and how frequently builds occur and automated tests of all kinds are run. Guidance on the creation and maintenance of an SCMP, based on the information produced by the planning activity, is available from a number of sources, such as. This reference provides
requirements for the information to be contained in an SCMP; it also defines and describes six categories of SCM information to be included in an SCMP: Introduction (purpose, scope, terms used); SCM Management (organization, responsibilities, authorities, applicable policies, directives, and procedures); SCM Activities (configuration identification, configuration control, and so on); SCM Schedules (coordination with other project activities); SCM Resources (tools, physical resources, and human resources); SCMP Maintenance.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/SCM_Plan</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">SCM Plan</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Secure_Software_Development_and_Maintenance</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Due to increasing malicious activities targeted at computer systems, security has become a significant issue in the development of software. In addition to the usual correctness and reliability, software developers must also pay attention to the security of the software they develop. Secure software development builds security in software by following a set of established and/or recommended rules and practices in software development. Secure software maintenance complements
secure software development by ensuring the no security problems are introduced during software maintenance. A generally accepted view concerning software
security is that it is much better to design security into software than to patch it in after software is developed. To design security into software, one must take into consideration every stage of the software development lifecycle. In particular, secure software development involves software requirements security, software design security, software construction security, and software testing security. In addition, security must also be taken into consideration when performing software maintenance as security faults and loopholes can be and often are introduced during maintenance.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Secure_Software_Development_and_Maintenance</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Secure Software Development and Maintenance</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Security</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Design for security is concerned with how to prevent unauthorized disclosure, creation, change, deletion, or denial of access to information and other resources. It is also concerned with how to tolerate security-related attacks or violations by
limiting damage, continuing service, speeding repair and recovery, and failing and recovering securely. Access control is a fundamental concept of security, and one should also ensure the proper use of cryptology.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Security</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Security</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Selecting_and_Combining_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Model-based and code-based test techniques are often contrasted as functional vs. structural testing. These two approaches to test selection are not to be seen as alternatives but rather as complements; in fact, they use different sources of information and have been shown to highlight different kinds of problems. They could be used in combination, depending on budgetary considerations. Test cases can be selected in a deterministic way, according to one of many techniques, or randomly drawn from some distribution of inputs, such as is usually done in reliability testing. Several analytical and empirical comparisons have been conducted to analyze the conditions that make one approach more effective than the other.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Selecting_and_Combining_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Selecting and Combining Techniques</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Set_Operations</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Intersection: The intersection of two sets X and Y, denoted by X ∩ Y, is the set of common elements in both X and Y. Union: The union of two sets X and Y, denoted by X ∪ Y, is the set of all elements either in X, or in Y, or in both. Complement: The set of elements in the universal set that do not belong to a given set X is called its complement set X&apos;. Set Difference or Relative Complement: The set of elements that belong to set X but not to set Y builds the set difference of Y from X. This is represented by X − Y. Cartesian Product: An ordinary pair {p, q} is a set with two elements. In a set, the order of the elements is irrelevant, so {p, q} = {q, p}.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Set_Operations</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Set Operations</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Set_Relations_Functions</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Set. A set is a collection of objects, called elements of the set. A set can be represented by listing its elements between braces, e.g., S = {1, 2, 3}. Finite and Infinite Set. A set with a finite number of elements is called a finite set. Conversely,
any set that does not have a finite number of elements in it is an infinite set. The set of all natural numbers, for example, is an infinite set.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Set_Relations_Functions</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Set, Relations, Functions</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Simulation_Engineering</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">All simulation models are a specification of reality. A central issue in simulation is to abstract and specify an appropriate simplification of reality. Developing this abstraction is of vital importance, as misspecification of the abstraction would invalidate the results of the simulation exercise. Simulation can be used for a variety of testing purposes. Simulation is classified based on the type of system under study. Thus, simulation can be either continuous or discrete. In the context of software engineering, the emphasis will be primarily on discrete simulation. Discrete simulations may model event scheduling or process interaction. The main components in such a model include entities, activities and events, resources, the state of the system, a simulation clock, and a random number generator. Output is generated by the simulation and must be analyzed. An important problem in the development of a discrete simulation is that of initialization. Before a simulation can be run, the initial values of all the state variables must be provided. As the simulation designer may not know what initial values are appropriate for the state variables, these values might be chosen somewhat arbitrarily. For instance, it might be decided that a queue should be initialized as empty and idle. Such a choice of
initial condition can have a significant but unrecognized impact on the outcome of the simulation.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Simulation_Engineering</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Simulation</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Acquisition_and_Supplier_Contract_Management</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software acquisition and supplier contract management is concerned with issues involved in contracting with customers of the software development organization who acquire the deliverable work products and with suppliers who supply
products or services to the software engineering organization. This may involve selection of appropriate kinds of contracts, such as fixed price, time and materials, cost plus fixed fee, or cost plus incentive fee. Agreements with customers and suppliers typically specify the scope of work and the deliverables and include clauses such as penalties for late delivery or nondelivery and intellectual property
agreements that specify what the supplier or suppliers are providing and what the acquirer is paying for, plus what will be delivered to and owned by the acquirer. For software being developed by suppliers (both internal to or external to the software
development organization), agreements commonly indicate software quality requirements for acceptance of the delivered software. After the agreement has been put in place, execution of the project in compliance with the terms of the agreement should be managed.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Acquisition_and_Supplier_Contract_Management</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Acquisition and Supplier Contract Management</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Building</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software building is the activity of combining the correct versions of software configuration items, using the appropriate configuration data, into an executable program for delivery to a customer or other recipient, such as the testing activity. For systems with hardware or firmware, the executable program is delivered to the system-building activity. Build instructions ensure that the proper build steps are taken in the correct sequence. In addition to building software for new releases, it is usually also necessary for SCM to have the capability to reproduce previous releases for recovery, testing, maintenance, or additional release purposes. Software is built using particular versions of supporting tools, such as compilers. It might be necessary to rebuild an exact copy of a previously built software configuration item. In this case, supporting tools and associated build instructions need to be under SCM control to ensure availability of the correct versions of the tools. A tool capability is useful for selecting the correct versions of software items for a given target environment and for automating the process of building the software from the selected versions and appropriate configuration data. For projects with parallel or distributed development environments, this tool capability is necessary. Most
software engineering environments provide this capability.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Building</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Building</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Configuration_Auditing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A software audit is an independent examination of a work product or set of work products to assess compliance with specifications, standards, contractual agreements, or other criteria. Audits are conducted according to a well-defined
process consisting of various auditor roles and responsibilities. Consequently, each audit must be carefully planned. An audit can require a number of individuals to perform a variety of tasks over a fairly short period of time. Tools to supportthe planning and conduct of an audit can greatly facilitate the process. Software configuration auditing determines the extent to which an item satisfies the required
functional and physical characteristics. Informal audits of this type can be conducted at key points in the life cycle. Two types of formal audits might be required by the governing contract (for example, in contracts covering critical software): the Functional Configuration Audit (FCA) and the Physical Configuration Audit (PCA). Successful completion of these audits can be a prerequisite for the establishment of the product baseline.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Configuration_Auditing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Configuration Auditing</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Configuration_Control</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software configuration control is concerned with managing changes during the software life cycle. It covers the process for determining what changes to make, the authority for approving certain changes, support for the implementation of those changes, and the concept of formal deviations from project requirements as well as
waivers of them. Information derived from these activities is useful in measuring change traffic and breakage as well as aspects of rework.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Configuration_Control</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Configuration Control</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Configuration_Identification</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software configuration identification identifies items to be controlled, establishes identification schemes for the items and their versions, and establishes the tools and techniques to be used in acquiring and managing controlled items. These
activities provide the basis for the other SCM activities.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Configuration_Identification</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Configuration Identification</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Configuration_Management</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A system can be defined as the combination of interacting elements organized to achieve one or more stated purposes. The configuration of a system is the functional and physical characteristics of hardware or software as set forth in technical documentation or achieved in a product; it can also be thought of as a collection of specific versions of hardware, firmware, or software items combined according to specific build procedures to serve a particular purpose. Configuration management (CM), then, is the discipline of identifying the configuration of a system at distinct points in time for the purpose of systematically controlling changes to the configuration and maintaining the integrity and traceability of the configuration throughout the system life cycle. It is formally defined as A discipline applying technical and administrative direction and surveillance to: identify and document the functional and physical characteristics of a configuration item,
control changes to those characteristics, record and report change processing and
implementation status, and verify compliance with specified requirements. Software configuration management (SCM) is a supporting-software life cycle process that benefits project management, development and maintenance activities, quality assurance activities, as well as the customers and users of the end
product.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Configuration_Management</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Configuration Management</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Configuration_Management_Tools</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">When discussing software configuration management tools, it is helpful to classify them. SCM tools can be divided into three classes in terms of the scope at which they provide support: individual support, project-related support, and companywide-process support. Individual support tools are appropriate and typically sufficient for small organizations or development groups without variants of their software products or other complex SCM requirements. They include: Version control tools: track, document, and store individual configuration items such as source code and external documentation; Build handling tools: in their simplest form, such tools compile and link an executable version of the software; Change control tools: mainly support the control of change requests and events notification (for example, change request status changes, milestones reached).
Project-related support tools mainly support workspace management for development teams and integrators; they are typically able to support distributed development environments.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Configuration_Management_Tools</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Configuration Management Tools</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Configuration_Status_Accounting</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software configuration status accounting (SCSA) is an element of configuration management consisting of the recording and reporting of information needed to manage a configuration effectively.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Configuration_Status_Accounting</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Configuration Status Accounting</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Configuration_Status_Information</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The SCSA activity designs and operates a system for the capture and reporting of necessary information as the life cycle proceeds. As in any information system, the configuration status information to be managed for the evolving configurations
must be identified, collected, and maintained. Various information and measurements are needed to support the SCM process and to meet the configuration status reporting needs of management, software engineering, and other related activities. The types of information available include the approved configuration identification as well as the identification and current implementation status of changes, deviations, and waivers. Some form of automated tool support is necessary to accomplish the SCSA data collection and
reporting tasks; this could be a database capability, a stand-alone tool, or a capability of a larger, integrated tool environment.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Configuration_Status_Information</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Configuration Status Information</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Configuration_Status_Reporting</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Reported information can be used by various organizational and project elements including the development team, the maintenance team, project management, and software quality activities. Reporting can take the form of ad hoc queries
to answer specific questions or the periodic production of predesigned reports. Some information produced by the status accounting activity during the course of the life cycle might become quality assurance records. In addition to reporting the current status of the configuration, the information obtained by the SCSA can serve as a basis of various measurements. Examples include the number of change requests per SCI and the average time needed to implement a change request.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Configuration_Status_Reporting</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Configuration Status Reporting</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Construction</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The term software construction refers to the detailed creation of working software through a combination of coding, verification, unit testing, integration testing, and debugging. The Software Construction knowledge area (KA) is linked to all the other KAs, but it is most strongly linked to Software Design and Software Testing because the software construction process involves significant software design and testing. The process uses the design output and provides an input to testing (“design” and “testing” in this case referring to the activities, not the KAs). Boundaries between design, construction, and testing (if any) will vary depending on the software life cycle processes that are used in a project. Although some detailed design may be performed prior to construction, much design work
is performed during the construction activity. Thus, the Software Construction KA is closely linked to the Software Design KA. Throughout construction, software engineers both unit test and integration test their work.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Construction</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Construction</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Construction_Fundamentals</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software construction fundamentals include minimizing complexity, anticipating change, constructing for verification, reuse, standards in construction. The first four concepts apply to design as well as to construction.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Construction_Fundamentals</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Construction Fundamentals</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Construction_Security</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software construction security concerns the question of how to write actual programming code for specific situations such that security considerations are taken care of. The term “Software Construction Security” could mean different things for different people. It can mean the way a specific function is coded, such that the coding itself is secure, or it can mean the coding of security into software.
Most people entangle the two together without distinction. One reason for such entanglement is that it is not clear how one can make sure that a specific coding is secure. For example, in C programming language, the expression of i&lt;&lt;1 (shift
the binary representation of i’s value to the left by one bit) and 2*i (multiply the value of variable i by constant 2) mean the same thing semantically, but do they have the same security ramification? The answer could be different for different combinations of ISAs and compilers.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Construction_Security</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Construction Security</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Construction_Tools</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Construction Tools</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Design</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Design is defined as both “the process of defining the architecture, components, interfaces, and other characteristics of a system or component” and “the result of [that] process”. Viewed as a process, software design is the software engineering life cycle activity in which software requirements are analyzed in order to produce a description of the software’s internal structure that will serve as the basis for its construction. A software design (the result) describes the software architecture that
is, how software is decomposed and organized into components and the interfaces
between those components. It should also describe the components at a level of detail that enables their construction. Software design plays an important role in
developing software: during software design, software engineers produce various models that form a kind of blueprint of the solution to be implemented. We can analyze and evaluate these models to determine whether or not they will allow us to fulfill the various requirements. We can also examine and evaluate alternative
solutions and tradeoffs. Finally, we can use the resulting models to plan subsequent development activities, such as system verification and validation, in addition to using them as inputs and as the starting point of construction and testing.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Design</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Design</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Design_Fundamentals</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The concepts, notions, and terminology introduced here form an underlying basis for understanding the role and scope of software design.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Design_Fundamentals</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Design Fundamentals</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Design_Notations</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Many notations exist to represent software design artifacts. Some are used to describe the structural organization of a design, others to represent software behavior. Certain notations are used mostly during architectural design and others mainly during detailed design, although some notations can be used for both purposes. In addition, some notations are used mostly in the context of specific design methods. Please note that software design is often accomplished using multiple notations. Here, they are categorized into notations for describing the structural (static) view vs. the behavioral (dynamic) view.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Design_Notations</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Design Notations</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Design_Principles</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A principle is “a comprehensive and fundamental law, doctrine, or assumption”. Software design principles are key notions that provide the basis for many different software design approaches and concepts. Software design principles include abstraction; coupling and cohesion; decomposition and modularization; encapsulation/information hiding; separation of interface and implementation; sufficiency, completeness, and primitiveness; and separation of concerns. Abstraction: In the context of software design, two key abstraction mechanisms are parameterization and specification. Abstraction by parameterization abstracts from the details of data representations by representing the data as named parameters. Abstraction by specification leads to three major kinds of abstraction: procedural abstraction, data abstraction, and control (iteration) abstraction; Coupling and Cohesion. Coupling is defined as “a measure of the interdependence among modules in a computer program,” whereas cohesion is defined as “a measure of the strength of association of the elements within a module”; Decomposition and modularization. Decomposing and modularizing means that large software is divided into a number of smaller named components having well-defined interfaces that describe component interactions; Encapsulation and information hiding means grouping and packaging the internal details of an abstraction and making those details
inaccessible to external entities; Separation of interface and implementation.
Separating interface and implementation involves defining a component by specifying a public interface (known to the clients) that is separate from the details of how the component is realized; Sufficiency, completeness, and primitiveness. Achieving sufficiency and completeness means ensuring that a software component captures all the important characteristics of an abstraction and nothing more. Primitiveness means the design should be based on patterns that are easy to implement; Separation of concerns. A concern is an “area of interest with respect to a software design”. A design concern is an area of design that is relevant to one or more of its stakeholders. Each architecture view frames
one or more concerns. Separating concerns by views allows interested stakeholders to focus on a few things at a time and offers a means of managing complexity.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Design_Principles</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Design Principles</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Design_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software design is generally considered a twostep process: Architectural design (also referred to as highlevel design and top-level design) describes how software is organized into components; Detailed design describes the desired behavior of these components. The output of these two processes is a set of models and artifacts that record the major decisions that have been taken, along with an explanation of the rationale for each nontrivial decision. By recording the rationale, long-term maintainability of the software product is enhanced.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Design_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Design Process</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Design_Quality_Analysis_and_Evaluation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">This section includes a number of quality analysis and evaluation topics that are specifically related to software design.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Design_Quality_Analysis_and_Evaluation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Design Quality Analysis and Evaluation</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Design_Security</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Design security deals with the design of software modules that fit together to meet the security objectives specified in the security requirements. This step clarifies the details of security considerations and develops the specific steps for implementation. Factors considered may include frameworks and access modes that set up the overall security monitoring/enforcement strategies, as well as the individual policy enforcement mechanisms.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Design_Security</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Design Security</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Design_Strategies_and_Methods</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">There exist various general strategies to help guide the design process. In contrast with general strategies, methods are more specific in that they generally provide a set of notations to be used with the method, a description of the process to be used when following the method, and a set of guidelines for using the method. Such methods are useful as a common framework for teams of software engineers.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Design_Strategies_and_Methods</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Design Strategies and Methods</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Design_Tools</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software design tools can be used to support the creation of the software design artifacts during the software development process. They can support part or whole of the following activities: to translate the requirements model into a design representation; to provide support for representing functional components and their interface(s); to implement heuristics refinement and partitioning; to provide guidelines for quality assessment.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Design_Tools</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Design Tools</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Engineering</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Engineering is an area of computing focused on the specification, development, maintenance and creation of software systems, applying technologies and practices of project management and other disciplines, aiming at organization, productivity and quality. Currently, these technologies and practices encompass programming languages, database, tools, platforms, libraries, standards, processes and the quality of software issue.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Engineering</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Engineering</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Engineering_Culture_and_Ethics</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software engineers are expected to share a commitment to software quality as part of their culture. A healthy software engineering culture includes many characteristics, including the understanding that tradeoffs among cost, schedule, and quality are a basic tenant of the engineering of any product. A strong software engineering ethic assumes that engineers accurately report information, conditions, and outcomes related to quality. Ethics also play a significant role in software quality, the culture, and the attitudes of software engineers. The IEEE Computer Society and the ACM have developed a code of ethics and professional
practice.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Engineering_Culture_and_Ethics</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Engineering Culture and Ethics</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Engineering_Economics</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software engineering economics is about making decisions related to software engineering in a business context. The success of a software product, service, and solution depends on good business management. Yet, in many companies and
organizations, software business relationships to software development and engineering remain vague. This knowledge area (KA) provides an overview on software engineering economics. Economics is the study of value, costs, resources, and their relationship in a given context or situation. In the discipline of software engineering, activities have costs, but the resulting software itself has economic attributes as well. Software engineering economics provides a way to study the attributes of software and software processes in a systematic way that relates them to economic measures. These economic measures can be weighed and analyzed when making decisions that are within the scope of a software organization and those within the integrated scope of an entire producing or acquiring business.
Software engineering economics is concerned with aligning software technical decisions with the business goals of the organization.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Engineering_Economics</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Engineering Economics</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Engineering_Economics_Fundamentals</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Engineering Economics Fundamentals</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Engineering_Management</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software engineering management can be defined as the application of management activities planning, coordinating, measuring, monitoring, controlling,
and reporting to ensure that software products and software engineering services are delivered efficiently, effectively, and to the benefit of stakeholders. The related discipline of management is an important element of all the knowledge areas (KAs), but it is of course more relevant to this KA than to other KAs. Measurement is also an important aspect of all KAs; the topic of measurement programs is presented in this KA. In one sense, it should be possible to manage a software engineering project in the same way other complex endeavors are managed. However, there are aspects specific to software projects and software life cycle processes that complicate effective management.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Engineering_Management</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Engineering Management</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Engineering_Management_Tools</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software engineering management tools are often used to provide visibility and control of software engineering management processes. Some tools are automated while others are manually implemented. There has been a recent trend towards the use of integrated suites of software engineering tools that are used throughout a project to plan, collect and record, monitor and control, and report project and product information. Tools can be divided into the following categories: Project Planning and Tracking Tools. Project planning and tracking tools can be used to estimate project effort and cost and to prepare project schedules. Some projects use automated estimation tools that accept as input the estimated size and other characteristics of a software product and produce estimates of the required total effort, schedule, and cost. Planning tools also include automated scheduling tools that analyze the tasks within a work breakdown structure, their estimated durations, their precedence relationships, and the resources assigned to each task to produce a schedule in the form of a Gantt chart. Tracking tools can be used to track project milestones, regularly scheduled project status meetings, scheduled iteration cycles, product demonstrations, and/or action items. Risk Management Tools. These tools include the use of approaches such as simulation or decision trees to analyze the effect of costs versus payoffs and subjective estimates of the probabilities of
risk events. Monte Carlo simulation tools can be used to produce probability distributions of effort, schedule, and risk by combining multiple input probability distributions in an algorithmic manner. Communications Tools. Communication tools can assist in providing timely and consistent information to relevant stakeholders involved in a project. These tools can include things like email notifications and broadcasts to team members and stakeholders. They also include communication of minutes from regularly scheduled project meetings, daily stand-up meetings, plus charts showing progress, backlogs, and maintenance
request resolutions.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Engineering_Management_Tools</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Engineering Management Tools</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Engineering_Measurement</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The importance of measurement and its role in better management and engineering practices is widely acknowledged. Effective measurement has become one of the cornerstones of organizational maturity. Measurement can be
applied to organizations, projects, processes, and work products. In this section the focus is on the application of measurement at the levels of projects, processes, and work products. This section follows the IEEE 15939:2008 standard, which describes a process to define the activities and tasks necessary to implement a software measurement process. The standard also includes a measurement information model.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Engineering_Measurement</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Engineering Measurement</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Engineering_Methods</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software engineering methods provide an organized and systematic approach to developing software for a target computer. There are numerous methods from which to choose, and it is important for the software engineer to choose an appropriate method or methods for the software development task at hand; this choice can have a dramatic effect on the success of the software project. Use of these software engineering methods coupled with people of the right skill set and tools enable the software engineers to visualize the details of the software and ultimately transform the representation into a working set of code and data.
Selected software engineering methods are discussed below. The topic areas are organized into discussions of Heuristic Methods, Formal Methods, Prototyping Methods, and Agile Methods.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Engineering_Methods</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Engineering Methods</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Engineering_Models_and_Methods</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software engineering models and methods impose structure on software engineering with the goal of making that activity systematic, repeatable, and ultimately more success-oriented. Using models provides an approach to problem
solving, a notation, and procedures for model construction and analysis. Methods provide an approach to the systematic specification, design, construction, test, and verification of the end-item software and associated work products. Software engineering models and methods vary widely in scope from addressing a single
software life cycle phase to covering the complete software life cycle. The emphasis in this knowledge area (KA) is on software engineering models and methods that encompass multiple software life cycle phases, since methods specific for single life cycle phases are covered by other KAs.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Engineering_Models_and_Methods</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Engineering Models and Methods</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Engineering_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">An engineering process consists of a set of interrelated activities that transform one or more inputs into outputs while consuming resources to accomplish the transformation. Many of the processes of traditional engineering disciplines (e.g., electrical, mechanical, civil, chemical) are concerned with transforming energy and physical entities from one form into another, as in a hydroelectric dam that transforms potential energy into electrical energy or a petroleum refinery that uses chemical processes to transform crude oil into gasoline. In this knowledge area (KA), software engineering processes are concerned with work activities accomplished by software engineers to develop, maintain, and operate software, such as requirements, design, construction, testing, configuration management, and other software engineering processes. For readability, “software engineering
process” will be referred to as “software process” in this KA. In addition, please note that “software process” denotes work activities not the execution process for implemented software. Software processes are specified for a number of reasons: to facilitate human understanding, communication, and coordination; to aid management of software projects; to measure and improve the quality of software products in an efficient manner; to support process improvement; and to provide a basis for automated support of process execution.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Engineering_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Engineering Process</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Engineering_Process_Tools</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software process tools support many of the notations used to define, implement, and manage individual software processes and software life cycle models. They include editors for notations such as data-flow diagrams, state charts, BPMN, IDEF0 diagrams, Petri nets, and UML activity diagrams. In some cases, software process tools allow different types of analyses and simulations (for example, discrete event simulation). In addition, general purpose business tools, such as a spreadsheet, may be useful. Computer-Assisted Software Engineering (CASE) tools can reinforce the use of integrated processes, support the execution of process definitions, and provide guidance to humans in performing well-defined processes. Simple tools
such as word processors and spreadsheets can be used to prepare textual descriptions of processes, activities, and tasks; these tools also support traceability among the inputs and outputs of multiple software processes (such as stakeholder
needs analysis, software requirements specification, software architecture, and software detailed design) as well as the results of software processes such as documentation, software components, test cases, and problem reports.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Engineering_Process_Tools</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Engineering Process Tools</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Engineering_Professional_Practice</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The Software Engineering Professional Practice knowledge area (KA) is concerned with the knowledge, skills, and attitudes that software engineers must possess to practice software engineering in a professional, responsible, and ethical manner. Because of the widespread applications of software products in social and personal
life, the quality of software products can have profound impact on our personal well-being and societal harmony. Software engineers must handle unique engineering problems, producing software with known characteristics and reliability. This requirement calls for software engineers who possess a proper set of knowledge, skills, training, and experience in professional practice. The term “professional practice” refers to a way of conducting services so as to achieve certain standards or criteria in both the process of performing a service and the end product resulting from the service. These standards and criteria can include both technical and nontechnical aspects. The concept of professional practice can be viewed as being more applicable within those professions that have a generally accepted body of knowledge; codes of ethics and professional conduct with penalties for violations; accepted processes for accreditation, certification, and
licensing; and professional societies to provide and administer all of these. Admission to these professional societies is often predicated on a prescribed combination of education and experience.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Engineering_Professional_Practice</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Engineering Professional Practice</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Functional_Configuration_Audit</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The purpose of the software FCA is to ensure that the audited software item is consistent with its governing specifications. The output of the software verification and validation activities is a key input to this audit.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Functional_Configuration_Audit</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Functional Configuration Audit</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Information_Models</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software information models allow modeling, analysis, and prediction of software process and software product attributes to provide answers to relevant questions and achieve process and product improvement goals. Needed data can be collected and retained in a repository; the data can be analyzed and models can be constructed. Validation and refinement of software information models occur during software projects and after projects are completed to ensure that the level of accuracy is sufficient and that their limitations are known and understood. Software information models may also be developed for contexts other than software projects; for example, a software information model might be developed for processes that apply across an organization, such as software configuration management or software quality assurance processes at the organizational level. Analysis-driven software information model building involves the development, calibration, and evaluation of a model. A software information model is developed by establishing a hypothesized transformation of input variables into desired outputs; for example, product size and complexity might be transformed into estimated effort needed to develop a software product using a regression equation developed from observed data from past projects. A model is calibrated by adjusting parameters in the model to match observed results from past projects; for
example, the exponent in a nonlinear regression model might be changed by applying the regression equation to a different set of past projects other than the projects used to develop the model. A model is evaluated by comparing computed
results to actual outcomes for a different set of similar data.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Information_Models</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Information Models</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Library</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A software library is a controlled collection of software and related documentation designed to aid in software development, use, or maintenance. It is also instrumental in software release management and delivery activities. Several types of libraries might be used, each corresponding to the software item’s particular level of maturity. For example, a working library could support coding and a project support library could support testing, while a master library could be used for finished products. An appropriate level of SCM control (associated baseline and level of authority for change) is associated with each library. Security, in terms of access control and the backup facilities, is a key aspect of library management.
The tool(s) used for each library must support the SCM control needs for that library both in terms of controlling SCIs and controlling access to the library. At the working library level, this is a code management capability serving developers,
maintainers, and SCM. It is focused on managing the versions of software items while supporting the activities of multiple developers. At higher levels of control, access is more restricted and SCM is the primary user. These libraries are also an important source of information for measurements of work and progress.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Library</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Library</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Life_Cycle_Models</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The intangible and malleable nature of software permits a wide variety of software development life cycle models, ranging from linear models in which the phases of software development are accomplished sequentially with feedback and iteration as needed followed by integration, testing, and delivery of a single product; to iterative models in which software is developed in increments of increasing functionality on iterative cycles; to agile models that typically involve frequent demonstrations of working software to a customer or user representative who directs development of the software in short iterative cycles that produce small increments of working, deliverable software. Incremental, iterative, and agile models can deliver early subsets of working software into the user environment, if desired. Linear SDLC models are sometimes referred to as predictive software development life cycle models, while iterative and agile SDLCs are referred to as adaptive software development life cycle models. The software requirements are then rigorously controlled. Changes to the software requirements are based on change requests that are processed by a change control board. An incremental
model produces successive increments of working, deliverable software based on partitioning of the software requirements to be implemented in each of the increments. The software requirements may be rigorously controlled, as in a linear
model, or there may be some flexibility in revising the software requirements as the software product evolves. Agile models may define product scope and high-level features initially; however, agile models are designed to facilitate evolution of the
software requirements during the project.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Life_Cycle_Models</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Life Cycle Models</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Life_Cycles</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">This topic addresses categories of software processes, software life cycle models, software process adaptation, and practical considerations. A software development life cycle (SDLC) includes the software processes used to specify and transform software requirements into a deliverable software product. A software product life cycle (SPLC) includes a software development life cycle plus additional software processes that provide for deployment, maintenance, support, evolution, retirement, and all other inceptionto-retirement processes for a software product, including the software configuration management and software quality assurance processes that are applied throughout a software product life cycle. A software product life cycle may include multiple software development life cycles for evolving and enhancing the software. Individual software processes have no temporal ordering among them. The temporal relationships among software processes are provided by a software life cycle model: either an SDLC or SPLC. Life cycle models typically emphasize the key software processes within the model and their temporal and logical interdependencies and relationships. Detailed definitions of the software processes in a life cycle model may be provided directly or by reference to other documents.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Life_Cycles</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Life Cycles</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Maintenance</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software development efforts result in the delivery of a software product that satisfies user requirements. Accordingly, the software product must change or evolve. Once in operation, defects are uncovered, operating environments change, and new user requirements surface. The maintenance phase of the life cycle begins following a warranty period or postimplementation support delivery, but maintenance activities occur much earlier. Software maintenance is an integral part of a software life cycle. However, it has not received the same degree of attention that the other phases have. Historically, software development has had a much higher profile than software maintenance in most organizations. This is now changing, as organizations strive to squeeze the most out of their software development investment by keeping software operating as long as possible. The
open source paradigm has brought further attention to the issue of maintaining software artifacts developed by others. Activities are performed during the predelivery stage as well as during the postdelivery stage. Predelivery activities
include planning for postdelivery operations, maintainability, and logistics determination for transition activities. Postdelivery activities include software modification, training, and operating or interfacing to a help desk. The Software Maintenance knowledge area (KA) is related to all other aspects of software
engineering.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Maintenance</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Maintenance</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Maintenance_Fundamentals</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">This first section introduces the concepts and terminology that form an underlying basis to understanding the role and scope of software maintenance. The topics provide definitions and emphasize why there is a need for maintenance. Categories of software maintenance are critical to understanding its underlying meaning.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Maintenance_Fundamentals</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Maintenance Fundamentals</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Maintenance_Measurement</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Entities related to software maintenance, whose attributes can be subjected to measurement, include process, resource, and product. There are several software measures that can be derived from the attributes of the software, the maintenance process, and personnel, including size, complexity, quality, understandability, maintainability, and effort. Complexity measures of software can also be obtained using available commercial tools. These measures constitute a good starting point for the maintainer’s measurement program. Specific Measures. The maintainer must determine which measures are appropriate for a specific organization based on that organization’s own context. The software quality model suggests measures that are specific for software maintenance. Measures for subcharacteristics of maintainability include the following: Analyzability: measures of the maintainer’s effort or resources expended in trying either to diagnose deficiencies or causes of failure or to identify parts to be modified; Changeability: measures of the maintainer’s effort associated with implementing a specified modification; Stability: measures of the unexpected behavior of software, including that encountered
during testing; Testability: measures of the maintainer’s and users’ effort in trying to test the modified software; Other measures that maintainers use include; size of the software; complexity of the software; understandability, and, maintainability.
Providing software maintenance effort, by categories, for different applications provides business information to users and their organizations. It can also enable the comparison of software maintenance profiles internally within an organization.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Maintenance_Measurement</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Maintenance Measurement</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Maintenance_Tools</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">This topic encompasses tools that are particularly important in software maintenance where existing software is being modified. Examples regarding program comprehension include: program slicers, which select only parts of a program affected by a change; static analyzers, which allow general viewing and summaries of a program content; dynamic analyzers, which allow the maintainer to trace the execution path of a program; data flow analyzers, which allow the maintainer to track all possible data flows of a program; cross-referencers, which generate indices of program components; and, dependency analyzers, which help maintainers analyze and understand the interrelationships between components of a program. Reverse engineering tools assist the process by working backwards from an existing product to create artifacts such as specification and design descriptions, which can then be transformed to generate a new product from an old one. Maintainers also use software test, software configuration management, software documentation, and software measurement tools.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Maintenance_Tools</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Maintenance Tools</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Measurement</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">This topic addresses software process and product measurement, quality of measurement results, software information models, and software process measurement techniques. Before a new process is implemented or a current
process is modified, measurement results for the current situation should be obtained to provide a baseline for comparison between the current situation and the new situation. For example, before introducing the software inspection
process, effort required to fix defects discovered by testing should be measured. Following an initial start-up period after the inspection process is introduced, the combined effort of inspection plus testing can be compared to the previous amount of effort required for testing alone. Similar considerations apply if a process is changed.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Measurement</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Measurement</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Physical_Configuration_Audit</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The purpose of the software physical configuration audit (PCA) is to ensure that the design and reference documentation is consistent with the as-built software product.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Physical_Configuration_Audit</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Physical Configuration Audit</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Process_Adaptation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Predefined SDLCs, SPLCs, and individual software processes often need to be adapted (or “tailored”) to better serve local needs. Organizational context, innovations in technology, project size, product criticality, regulatory requirements,
industry practices, and corporate culture may determine needed adaptations. Adaptation of individual software processes and software life cycle models (development and product) may consist of adding more details to software processes, activities, tasks, and procedures to address critical concerns. It may consist of using an alternate set of activities that achieves the purpose and
outcomes of the software process. Adaptation may also include omitting software processes or activities from a development or product life cycle model that are clearly inapplicable to the scope of work to be accomplished.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Process_Adaptation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Process Adaptation</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Process_Assessment_Methods</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A software process assessment method can be qualitative or quantitative. Qualitative assessments rely on the judgment of experts; quantitative assessments assign numerical scores to software processes based on analysis of objective evidence that indicates attainment of the goals and outcomes of a defined software process. For example, a quantitative assessment of the software inspection process might be performed by examining the procedural steps followed and results obtained plus data concerning defects found and time required to find and fix the defects as compared to software testing. A typical method of software process assessment includes planning, fact-finding (by collecting evidence through questionnaires, interviews, and observation of work practices), collection and validation of process data, and analysis and reporting. Process assessments may rely on the subjective, qualitative judgment of the assessor, or on the objective presence or absence of defined artifacts, records, and other evidence. The activities performed during a software process assessment and the distribution of effort for
assessment activities are different depending on the purpose of the software process assessment. Software process assessments may be undertaken to develop capability ratings used to make recommendations for process improvements or may be undertaken to obtain a process maturity rating in order to qualify for a contract or award. The quality of assessment results depends on the software process assessment method, the integrity and quality of the obtained data, the
assessment team’s capability and objectivity, and the evidence examined during the assessment.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Process_Assessment_Methods</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Process Assessment Methods</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Process_Assessment_Models</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software process assessment models typically include assessment criteria for software processes that are regarded as constituting good practices. These practices may address software development processes only, or they may also include topics such as software maintenance, software project management, systems engineering, or human resources management.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Process_Assessment_Models</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Process Assessment Models</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Process_Assessment_and_Improvement</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">This topic addresses software process assessment models, software process assessment methods, software process improvement models, and continuous and staged process ratings. Software process assessments are used to evaluate the form and content of a software process, which may be specified by a standardized set of criteria. In some instances, the terms “process appraisal” and “capability evaluation” are used instead of process assessment. Capability evaluations are typically performed by an acquirer (or potential acquirer) or by an external agent on behalf of an acquirer (or potential acquirer). The results are used as an indicator of whether the software processes used by a supplier (or potential supplier) are acceptable to the acquirer. Process assessments are performed at the levels of entire organizations, organizational units within organizations, and individual projects. Assessment may involve issues such as assessing whether software process entry and exit criteria are being met, to review risk factors and risk management, or to identify lessons learned. Process assessment is carried out using both an assessment model and an assessment method. The model can provide a norm for a benchmarking comparison among projects within an organization and among organizations.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Process_Assessment_and_Improvement</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Process Assessment and Improvement</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Process_Definition</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">This topic is concerned with a definition of software process, software process management, and software process infrastructure. As stated above, a software process is a set of interrelated activities and tasks that transform input work products into output work products. At minimum, the description of a software process includes required inputs, transforming work activities, and outputs generated. A software process may also include its entry and exit criteria and decomposition of the work activities into tasks, which are the smallest units of work subject to management accountability. A process input may be a triggering event or the output of another process. Entry criteria should be satisfied before a process can commence. All specified conditions should be satisfied before a process can be successfully concluded, including the acceptance criteria for the output work product or work products. A software process may include subprocesses. For example, software requirements validation is a process used to determine whether the requirements will provide an adequate basis for software development; it is a subprocess of the software requirements process. Inputs for requirements validation are typically a software requirements specification and the resources needed to perform validation (personnel, validation tools, sufficient time). The tasks of the requirements validation activity might include requirements reviews, prototyping, and model validation. These tasks involve work assignments for individuals and teams.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Process_Definition</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Process Definition</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Process_Improvement_Models</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software process improvement models emphasize iterative cycles of continuous improvement. A software process improvement cycle typically involves the subprocesses of measuring, analyzing, and changing. The Plan-Do-Check-Act
model is a well-known iterative approach to software process improvement. Improvement activities include identifying and prioritizing desired improvements (planning); introducing an improvement, including change management and training (doing); evaluating the improvement as compared to previous or exemplary process results and costs (checking); and making further modifications (acting). The Plan-Do-Check-Act process improvement model can be applied, for
example, to improve software processes that enhance defect prevention.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Process_Improvement_Models</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Process Improvement Models</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Process_Infrastructure</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Establishing, implementing, and managing software processes and software life cycle models often occurs at the level of individual software projects. However, systematic application of software processes and software life cycle models across an organization can provide benefits to all software work within the organization, although it requires commitment at the organizational level. A software process infrastructure can provide process definitions, policies for interpreting and applying the processes, and descriptions of the procedures to be used to implement the processes. Additionally, a software process infrastructure may provide funding, tools, training, and staff members who have been assigned responsibilities for establishing and maintaining the software process infrastructure. Software process infrastructure varies, depending on the size and complexity of the organization
and the projects undertaken within the organization. Small, simple organizations and projects have small, simple infrastructure needs. Large, complex organizations and projects, by necessity, have larger and more complex software process infrastructures. In the latter case, various organizational units may be established (such as a software engineering process group or a steering committee) to oversee implementation and improvement of the software processes.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Process_Infrastructure</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Process Infrastructure</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Process_Management</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Two objectives of software process management are to realize the efficiency and effectiveness that result from a systematic approach to accomplishing software processes and producing work products be it at the individual, project, or organizational level and to introduce new or improved processes. Processes are changed with the expectation that a new or modified process will improve the efficiency and/or effectiveness of the process and the quality of the resulting work products. Changing to a new process, improving an existing process, organizational change, and infrastructure change (technology insertion or changes in tools) are
closely related, as all are usually initiated with the goal of improving the cost, development schedule, or quality of the software products. Process change has impacts not only for the software product; they often lead to organizational change. Changing a process or introducing a new process can have ripple effects throughout an organization. For example, changes in IT infrastructure tools and technology often require process changes. Existing processes may be modified when other new processes are deployed for the first time. These situations can also be termed “process evolution.” If the modifications are extensive, then changes in the organizational culture and business model will likely be necessary to accommodate the process changes.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Process_Management</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Process Management</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Process_Measurement_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software process measurement techniques are used to collect process data and work product data, transform the data into useful information, and analyze the information to identify process activities that are candidates for improvement.
In some cases, new software processes may be needed. Process measurement techniques also provide the information needed to measure the effects of process improvement initiatives. Process measurement techniques can be used to collect both quantitative and qualitative data. Quantitative Process Measurement Techniques: The purpose of quantitative process measurement techniques is to collect, transform, and analyze quantitative process and work product data that can be used to indicate where process improvements are needed and to assess the results of process improvement initiatives. Quantitative process measurement techniques are used to collect and analyze data in numerical form to which
mathematical and statistical techniques can be applied. Each category to the software process or software processes where a group of defects originated.
Qualitative Process Measurement Techniques: Qualitative process measurement techniques including interviews, questionnaires, and expert judgment can be used to augment quantitative process measurement techniques. Group consensus
techniques, including the Delphi technique, can be used to obtain consensus among groups of stakeholders.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Process_Measurement_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Process Measurement Techniques</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Process_and_Product_Measurement</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software process and product measurement are concerned with determining the efficiency and effectiveness of a software process, activity, or task. Effort (or equivalent cost) is the primary measure of resources for most software processes, activities, and tasks; it is measured in units such as person-hours, person-days, staffweeks, or staff-months of effort or in equivalent monetary units such as euros or dollars. Effectiveness is the ratio of actual output to expected output produced by a software process, activity, or task; for example, actual number of defects detected and corrected during software testing to expected number of defects to be detected and corrected perhaps based on historical data for similar projects. One must take care when measuring product attributes for the purpose of determining process effectiveness. Product measures that may be important in determining the effectiveness of software processes include product complexity, total defects, defect density, and the quality of requirements, design documentation, and other related work products. An efficient process can be ineffective in accomplishing the desired transformation of input work products into output work products; for example, failure to find and correct a sufficient number of software defects during the testing process. Causes of low efficiency and/or low effectiveness in the way a software process, activity, or task is executed might include one or more of the following problems: deficient input work products, inexperienced personnel, lack of adequate tools and infrastructure, learning a new process, a complex product, or an unfamiliar product domain.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Process_and_Product_Measurement</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Process and Product Measurement</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Project_Enactment</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">During software project enactment (also known as project execution) plans are implemented and the processes embodied in the plans are enacted. Throughout, there should be a focus on adherence to the selected SDLC processes, with an
overriding expectation that adherence will lead to the successful satisfaction of stakeholder requirements and achievement of the project’s objectives. Fundamental to enactment are the ongoing management activities of monitoring, controlling, and reporting.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Project_Enactment</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Project Enactment</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Project_Planning</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The first step in software project planning should be selection of an appropriate software development life cycle model and perhaps tailoring it based on project scope, software requirements, and a risk assessment. Other factors to be considered
include the nature of the application domain, functional and technical complexity, and software quality requirements. In all SDLCs, risk assessment should be an element of initial project planning, and the “risk profile” of the project should be discussed and accepted by all relevant stakeholders. Software quality management processes should be determined as part of the planning process and result in procedures and responsibilities for software quality assurance, verification and validation, reviews, and audits. Processes and responsibilities for ongoing review and revision of the project plan and related plans should also be clearly stated and agreed upon.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Project_Planning</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Project Planning</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Quality</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The term software quality is overloaded. Software quality may refer: to desirable
characteristics of software products, to the extent to which a particular software product possess those characteristics, and to processes, tools, and techniques used to achieve those characteristics. Over the years, authors and organizations have defined the term quality differently. To Phil Crosby, it was “conformance to requirements”. Watts Humphrey refers to it as “achieving excellent levels of “fitness for use”. Meanwhile, IBM coined the phrase “market-driven quality,” where the “customer is the final arbiter”. More recently, software quality is defined as the
“capability of software product to satisfy stated and implied needs under specified conditions” and as “the degree to which a software product meets established requirements; however, quality depends upon the degree to which those established requirements accurately represent stakeholder needs, wants, and expectations”. Both definitions embrace the premise of conformance to requirements. Neither refers to types of requirements (e.g., functional, reliability, performance, dependability, or any other characteristic). Significantly, however, these definitions emphasize that quality is dependent upon requirements.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Quality</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Quality</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Quality_Assurance</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">To quell a widespread misunderstanding, software quality assurance is not testing. software quality assurance (SQA) is a set of activities that define and assess the adequacy of software processes to provide evidence that establishes confidence that the software processes are appropriate and produce software products of suitable quality for their intended purposes. A key attribute of SQA is the objectivity of the SQA function with respect to the project. The SQA function may also be organizationally independent of the project; that is, free from technical, managerial, and financial pressures from the project. The software quality plan (in some industry sectors it is termed the software quality assurance plan) defines the activities and tasks employed to ensure that software developed for a specific
product satisfies the project’s established requirements and user needs within project cost and schedule constraints and is commensurate with project risks. The SQAP first ensures that quality targets are clearly defined and understood.
The SQA plan’s quality activities and tasks are specified with their costs, resource requirements, objectives, and schedule in relation to related objectives in the software engineering management, software development, and software maintenance plans. The SQA plan should be consistent with the software configuration management plan. The SQA plan identifies documents, standards, practices, and conventions governing the project and how these items are checked and monitored to ensure adequacy and compliance.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Quality_Assurance</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Quality Assurance</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Quality_Fundamentals</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Reaching agreement on what constitutes quality for all stakeholders and clearly communicating that agreement to software engineers require that the many aspects of quality be formally defined and discussed. A software engineer should understand quality concepts, characteristics, values, and their application to the software under development or maintenance. The important concept is that the software requirements define the required quality attributes of the software. Software requirements influence the measurement methods and acceptance
criteria for assessing the degree to which the software and related documentation achieve the desired quality levels.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Quality_Fundamentals</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Quality Fundamentals</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Quality_Improvement</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The quality of software products can be improved through preventative processes or an iterative process of continual improvement, which requires management control, coordination, and feedback from many concurrent processes: the software life cycle processes, the process of fault/defect detection, removal, and prevention, and the quality improvement process. The theory and concepts behind quality improvement such as building in quality through the prevention and early detection of defects, continual improvement, and stakeholder focus are pertinent to software engineering. These concepts are based on the work of experts in quality who have stated that the quality of a product is directly linked to the quality of the
process used to create it. Approaches such as the Deming improvement cycle of Plan-Do-CheckAct (PDCA), evolutionary delivery, kaizen, and quality function deployment (QFD) offer techniques to specify quality objectives and determine
whether they are met. The Software Engineering Institute’s IDEAL is another method. Quality management is now recognized by the SWEBOK Guide as an important discipline. Management sponsorship supports process and product evaluations and the resulting findings. Then an improvement program is developed
identifying detailed actions and improvement projects to be addressed in a feasible time frame.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Quality_Improvement</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Quality Improvement</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Quality_Management_Processes</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software quality management is the collection of all processes that ensure that software products, services, and life cycle process implementations meet organizational software quality objectives and achieve stakeholder satisfaction.
SQM defines processes, process owners, requirements for the processes, measurements of the processes and their outputs, and feedback channels throughout the whole software life cycle. SQM comprises four subcategories: software quality planning, software quality assurance (SQA), software quality control (SQC), and software process improvement (SPI).  SQA activities define and assess the adequacy of software processes to provide evidence that establishes
confidence that the software processes are appropriate for and produce software products of suitable quality for their intended purposes. SQC evaluates intermediate products as well as the final products. The fourth SQM category dealing with improvement has various names within the software industry, including SPI, software quality improvement, and software corrective and preventive action. The activities in this category seek to improve process
effectiveness, efficiency, and other characteristics with the ultimate goal of improving software quality. Although SPI could be included in any of the first three categories, an increasing number of organizations organize SPI into a separate category that may span across many projects.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Quality_Management_Processes</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Quality Management Processes</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Quality_Management_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software quality control techniques can be categorized in many ways, but a straightforward approach uses just two categories: static and dynamic. Dynamic techniques involve executing the software; static techniques involve analyzing
documents and source code but not executing the software. Static Techniques Static techniques examine software documentation (including requirements, interface specifications, designs, and models) and software source code without executing the code. There are many tools and techniques for statically examining software work-products. Dynamic techniques involve executing the software code. Different kinds of dynamic techniques are performed throughout the development and maintenance of software. Generally, these are testing techniques, but techniques such as simulation and model analysis may be considered dynamic. Code reading is considered a static technique, but experienced software engineers may execute the code as they read through it. Testing: Two types of testing may fall under V&amp;V because of their responsibility for the quality of the materials used in the project: Evaluation and tests of tools to be used on the project; Conformance tests (or review of conformance tests) of components and COTS products to be used in the product. Sometimes an independent (third-party or IV&amp;V) organization may be tasked to perform testing or to monitor the test process V&amp;V may be called upon to evaluate the testing itself: adequacy of plans, processes, and procedures, and adequacy and accuracy of results.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Quality_Management_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Quality Management Techniques</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Quality_Measurement</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software quality measurements are used to support decision-making. With the increasing sophistication of software, questions of quality go beyond whether or not the software works to how well it achieves measurable quality goals. Decisions supported by software quality measurement include determining levels of software quality (notably because models of software product quality include measures to determine the degree to which the software product achieves quality goals); managerial questions about effort, cost, and schedule; determining when to stop testing and release a product; and determining the efficacy of process improvement efforts. The cost of SQM processes is an issue frequently raised in deciding how a project or a software development and maintenance group should be organized. Software quality measurement data collected internally may give a better picture of cost within this project or organization. While the software quality measurement data may be useful in itself (e.g., the number of defective requirements or the proportion of defective requirements), mathematical and graphical techniques can be applied to aid in the interpretation of the measures. These techniques include descriptive statistics based (e.g., Pareto analysis, run charts, scatter plots, normal distribution); statistical tests (e.g., the binomial test, chisquared test); trend analysis; prediction (e.g., reliability models). Descriptive statistics-based techniques and tests often provide a snapshot of the more
troublesome areas of the software product under examination. The resulting charts and graphs are visualization aids, which the decision makers can use to focus resources and conduct process improvements where they appear to be most
needed.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Quality_Measurement</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Quality Measurement</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Quality_Requirements</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Various factors influence planning, management, and selection of SQM activities and techniques, including the domain of the system in which the software resides; the system functions could be safety-critical, mission-critical, businesscritical, security-critical; the physical environment in which the software system resides; system and software functional (what the system does) and quality (how well the system performs its functions) requirements; the commercial (external) or standard (internal) components to be used in the system; the specific software engineering standards applicable; the methods and software tools to be used for development and maintenance and for quality evaluation and improvement; the budget, staff, project organization, plans, and scheduling of all processes; the intended users and use of the system; the integrity level of the system. Information on these factors influences how the SQM processes are organized and documented, how specific SQM activities are selected, what resources are needed, and which of those resources impose bounds on the efforts. Dependability: In cases where system failure may have extremely severe consequences, overall dependability (hardware, software, and human or operational) is the main quality requirement over and above basic functionality. This is the case for the following reasons: system failures affect a large number of people; users often reject systems that are unreliable, unsafe, or insecure; system failure costs may be enormous; and undependable systems may cause information loss. Integrity Levels of Software Defining: integrity levels is a method of risk management. Software integrity levels are a range of values that represent software complexity, criticality, risk, safety level, security level, desired performance, reliability, or other project-unique characteristics that define the importance of the software to the user and acquirer.  The assigned software integrity levels may change as the software evolves. Design, coding, procedural, and technology features implemented in the system or software can raise or lower the assigned software integrity levels.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Quality_Requirements</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Quality Requirements</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Quality_Tools</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software quality tools include static and dynamic analysis tools. Static analysis tools input source code, perform syntactical and semantic analysis without executing the code, and present results to users. There is a large variety in the depth, thoroughness, and scope of static analysis tools that can be applied to artifacts including models, in addition to source code. Categories of static analysis tools include the following: Tools that facilitate and partially automate reviews and inspections of documents and code. These tools can route work to different participants in order to partially automate and control a review process. They allow users to enter defects found during inspections and reviews for later removal. Some tools help organizations perform software safety hazard analysis. These tools
provide, e.g., automated support for failure mode and effects analysis (FMEA) and fault tree analysis (FTA). Tools that support tracking of software problems provide for entry of anomalies discovered during software testing and subsequent analysis, disposition, and resolution. Some tools include support for workflow and for
tracking the status of problem resolution. Tools that analyze data captured from software engineering environments and software test environments and produce visual displays of quantified data in the form of graphs, charts, and tables. These tools sometimes include the functionality to perform statistical analysis on data sets (for the purpose of discerning trends and making forecasts).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Quality_Tools</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Quality Tools</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Release_Management</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software release management encompasses the identification, packaging, and delivery of the elements of a product for example, an executable program, documentation, release notes, and configuration data. Given that product changes can occur on a continuing basis, one concern for release management is determining when to issue a release. The severity of the problems addressed by the release and measurements of the fault densities of prior releases affect this decision. The packaging task must identify which product items are to be delivered and then select the correct variants of those items, given the intended application of the product. The information documenting the physical contents of a release is known as a version description document. The release notes typically describe new capabilities, known problems, and platform requirements necessary for proper product operation. The package to be released also contains installation or upgrading instructions. The latter can be complicated by the fact that some current users might have versions that are several releases old. In some cases, release management might be required in order to track distribution of the product to various customers or target systems for example, in a case where the supplier was required to notify a customer of newly reported problems. Finally, a mechanism
to ensure the integrity of the released item can be implemented for example by releasing a digital signature with it.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Release_Management</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Release Management</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Release_Management_and_Delivery</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">In this context, release refers to the distribution of a software configuration item outside the development activity; this includes internal releases as well as distribution to customers. When different versions of a software item are available
for delivery (such as versions for different platforms or versions with varying capabilities), it is frequently necessary to recreate specific versions and package the correct materials for delivery of the version. The software library is a key element
in accomplishing release and delivery tasks.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Release_Management_and_Delivery</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Release Management and Delivery</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Requirements</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The Software Requirements knowledge area (KA) is concerned with the elicitation, analysis, specification, and validation of software requirements as well as the management of requirements during the whole life cycle of the software product.
It is widely acknowledged amongst researchers and industry practitioners that software projects are critically vulnerable when the requirementsrelated activities are poorly performed. Software requirements express the needs and constraints placed on a software product that contribute to the solution of some real-world
problem. The term “requirements engineering” is widely used in the field to denote the systematic handling of requirements. For reasons of consistency, the term “engineering” will not be used in this KA other than for software engineering per se.
For the same reason, “requirements engineer,” a term which appears in some of the literature, will not be used either. Instead, the term “software engineer” or, in some specific cases, “requirements specialist” will be used, the latter where the role in question is usually performed by an individual other than a software engineer. This
does not imply, however, that a software engineer could not perform the function.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Requirements</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Requirements</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Requirements_Fundamentals</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Requirements Fundamentals</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Requirements_Security</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software requirements security deals with the clarification and specification of security policy and objectives into software requirements, which lays the foundation for security considerations in the software development. Factors to consider in this phase include software requirements and threats/risks. The former refers to the specific functions that are required for the sake of security; the latter refers to the possible ways that the security of software is threatened.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Requirements_Security</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Requirements Security</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Requirements_Specification</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Developers of systems with substantial software and nonsoftware components a modern airliner, for example, often separate the description of system requirements from the description of software requirements. In this view, system requirements are specified, the software requirements are derived from the system requirements, and then the requirements for the software components are specified. Strictly speaking, system requirements specification is a systems engineering activity.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Requirements_Specification</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Requirements Specification</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Requirements_Tools</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Tools for dealing with software requirements fall broadly into two categories: tools for modeling and tools for managing requirements. Requirements management tools typically support a range of activities including documentation, tracing, and change management and have had a significant impact on practice. Indeed, tracing and change management are really only practicable if supported by a tool. Since requirements management is fundamental to good requirements practice, many organizations have invested in requirements management tools, although many more manage their requirements in more ad hoc and generally less satisfactory ways (e.g., using spreadsheets).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Requirements_Tools</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Requirements Tools</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Robustness</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software robustness refers to the ability of software to tolerate erroneous inputs. Software is said to be robust if it continues to function even when erroneous inputs are given. Thus, it is unacceptable for software to simply crash when encountering
an input problem as this may cause unexpected consequences, such as the loss of valuable data. Software that exhibits such behavior is considered to lack robustness. Nielsen gives a simpler description of software robustness: “The software should have a low error rate, so that users make few errors during the use of the system and so that if they do make errors they can easily recover from them. Further,
catastrophic errors must not occur”. There are many ways to evaluate the robustness of software and just as many ways to make software more robust. For example, to improve robustness, one should always check the validity of the inputs and return values before progressing further; one should always throw an exception
when something unexpected occurs, and one should never quit a program without first giving users/applications a chance to correct the condition.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Robustness</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Robustness</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Safety</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Safety-critical systems are those in which a system failure could harm human life, other living things, physical structures, or the environment. The software in these systems is safety-critical. There are increasing numbers of applications of safety-critical software in a growing number of industries. Examples of systems with safetycritical software include mass transit systems, chemical manufacturing plants, and medical devices. The failure of software in these systems could have catastrophic effects. There are industry standards, such as DO-178C [11], and emerging processes, tools, and techniques for developing safetycritical software. The intent of these standards, tools, and techniques is to reduce the risk of injecting faults into the software and thus improve software reliability.  Direct is that software embedded in a safety-critical system, such as the flight control computer of an aircraft. Indirect includes software applications used to develop safetycritical
software. Indirect software is included in software engineering environments and software test environments. These techniques impact software functional requirements, software performance requirements, and development processes. Increasing levels of risk imply increasing levels of software quality assurance
and control techniques such as inspections. Higher risk levels may necessitate more thorough inspections of requirements, design, and code or the use of more formal analytical techniques. Another technique for managing and controlling software risk is building assurance cases. An assurance case is a reasoned, auditable artifact
created to support the contention that its claim or claims are satisfied.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Safety</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Safety</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Security_Guidelines</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Although there are no bulletproof ways for secure software development, some general guidelines do exist that can be used to aid such effort. These guidelines span every phase of the software development lifecycle. Some reputable guidelines
are published by the Computer Emergency Response Team (CERT) and below are its top 10 software security practices: 1. Validate input. 2. Heed compiler warnings. 3. Architect and design for security policies. 4. Keep it simple. 5. Default deny. 6. Adhere to the principle of least privilege. 7. Sanitize data sent to other software. 8. Practice defense in depth. 9. Use effective quality assurance techniques. 10. Adopt a software construction security standard.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Security_Guidelines</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Security Guidelines</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Structure_and_Architecture</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">In its strict sense, a software architecture is “the set of structures needed to reason about the system, which comprise software elements, relations among them, and properties of both”. During the mid-1990s, however, software architecture started to emerge as a broader discipline that involved the study of software structures and architectures in a more generic way. This gave rise to a number of interesting concepts about software design at different levels of abstraction. Some of these concepts can be useful during the architectural design (for example, architectural styles) as well as during the detailed design (for example, design patterns). These design concepts can also be used to design families of programs (also known as
product lines). Interestingly, most of these concepts can be seen as attempts to describe, and thus reuse, design knowledge.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Structure_and_Architecture</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Structure and Architecture</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Testing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software testing consists of the dynamic verification that a program provides expected behaviors on a finite set of test cases, suitably selected from the usually infinite execution domain. In the above definition, italicized words correspond to key issues in describing the Software Testing knowledge area (KA): Dynamic; Finite; Selected; Expected.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Testing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Testing</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Testing_Fundamentals</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Testing Fundamentals</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Software_Testing_Security</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software testing security determines that software protects data and maintains security specification as given.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Testing_Security</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Testing Security</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Software_Testing_Tools</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software Testing Tools</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Standards</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Moore states that a standard can be; (a) an object or measure of comparison that defines or represents the magnitude of a unit; (b) a characterization that establishes allowable tolerances for categories of items; and (c) a degree or level of required excellence or attainment. Standards are definitional in nature, established either to further understanding and interaction or to acknowledge observed (or desired) norms of exhibited characteristics or behavior. Standards provide requirements, specifications, guidelines, or characteristics that must be observed by engineers so that the products, processes, and materials have acceptable levels of quality. The qualities that various standards provide may be those of safety, reliability, or other
product characteristics. Standards are considered critical to engineers and engineers are expected to be familiar with and to use the appropriate standards
in their discipline. Compliance or conformance to a standard lets an organization say to the public that they (or their products) meet the requirements stated in
that standard. Thus, standards divide organizations or their products into those that conform to the standard and those that do not. For a standard to be useful, conformance with the standard must add value real or perceived to the product,
process, or effort.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Standards</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Standards</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Standards_in_Construction</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Applying external or internal development standards during construction helps achieve a project’s objectives for efficiency, quality, and cost. Specifically, the choices of allowable programming language subsets and usage standards are
important aids in achieving higher security. Standards that directly affect construction issues include communication methods (for example, standards for document formats and contents); programming languages (for example, language standards for languages like Java and C++); coding standards (for example, standards for naming conventions, layout, and indentation); platforms (for example, interface standards for operating system calls) ; tools (for example, diagrammatic standards for notations like UML (Unified Modeling Language)).
Use of external standards. Construction depends on the use of external standards for construction languages, construction tools, technical interfaces, and interactions between the Software Construction KA and other KAs. Standards come
from numerous sources, including hardware and software interface specifications (such as the Object Management Group (OMG)) and international organizations (such as the IEEE or ISO). Use of internal standards. Standards may also be created on an organizational basis at the corporate level or for use on specific projects. These standards support coordination of group activities, minimizing complexity, anticipating change, and constructing for verification.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Standards_in_Construction</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Standards in Construction</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/State_Based_and_Table_Driven_Construction_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">State-based programming, or automata-based programming, is a programming technology using finite state machines to describe program behaviours. The transition graphs of a state machine are used in all stages of software development
(specification, implementation, debugging, and documentation). The main idea is to construct computer programs the same way the automation of technological processes is done. State-based programming is usually combined with object-oriented programming, forming a new composite approach called state-based, object-oriented programming. A table-driven method is a schema that uses tables to look up information rather than using logic statements (such as if and case). Used in appropriate circumstances, table-driven code is simpler than complicated logic and easier to modify. When using table-driven methods, the
programmer addresses two issues: what information to store in the table or tables, and how to efficiently access information in the table.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/State_Based_and_Table_Driven_Construction_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">State-Based and Table-Driven Construction Techniques</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Statistical_Analysis</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">In order to carry out their responsibilities, engineers must understand how different product and process characteristics vary. Engineers often come across situations where the relationship between different variables needs to be studied. An important point to note is that most of the studies are carried out on the basis of samples and so the observed results need to be understood with respect to the full population. Engineers must, therefore, develop an adequate understanding of statistical techniques for collecting reliable data in terms of sampling and analysis to arrive at results that can be generalized. These techniques are discussed below.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Statistical_Analysis</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Statistical Analysis</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Steps_Involved_in_Engineering_Design</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Engineering problem solving begins when a need is recognized and no existing solution will meet that need. As part of this problem solving, the design goals to be achieved by the solution should be identified. Additionally, a set of acceptance criteria must be defined and used to determine how well a proposed solution will satisfy the need. Once a need for a solution to a problem has been identified, the process of engineering design has the following generic steps: define the problem, gather pertinent information, generate multiple solutions, analyze and select a solution, implement the solution. All of the engineering design steps are iterative,
and knowledge gained at any step in the process may be used to inform earlier tasks and trigger an iteration in the process. These steps are expanded in the subsequent sections.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Steps_Involved_in_Engineering_Design</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Steps Involved in Engineering Design</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Structural_Descriptions_Static_View</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The following notations, mostly but not always graphical, describe and represent the structural aspects of a software design that is, they are used to describe the major components and how they are interconnected (static view): Architecture description languages (ADLs): textual, often formal, languages used to describe software architecture in terms of components and connectors; Class and object diagrams: used to represent a set of classes (and objects) and their interrelationships; Component diagrams: used to represent a set of components (“physical and replaceable part[s] of a system that [conform] to and [provide] the realization of a set of interfaces”) and their interrelationships; Class responsibility collaborator cards (CRCs): used to denote the names of components (class), their responsibilities, and their collaborating components’ names; Deployment diagrams: used to represent a set of (physical) nodes and their interrelationships,
and, thus, to model the physical aspects of software; Entity-relationship diagrams (ERDs): used to represent conceptual models of data stored in information repositories; Interface description languages (IDLs): programming-like languages used to define the interfaces (names and types of exported operations) of software components; Structure charts: used to describe the calling structure of programs (which modules call, and are called by, which other modules).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Structural_Descriptions_Static_View</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Structural Descriptions (Static View)</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Structure</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Well-structured programs are easier to understand and modify. If a program is poorly structured, then no amount of explanation or comments is sufficient to make it understandable. The ways to organize a program are numerous and range from the proper use of white space, indentation, and parentheses to nice arrangements of groupings, blank lines, and braces. Whatever style one chooses, it should be consistent across the entire program.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Structure</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Structure</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Structure_Modeling</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Structure models illustrate the physical or logical composition of software from its various component parts. Structure modeling establishes the defined boundary between the software being implemented or modeled and the environment in which it is to operate. Some common structural constructs used in structure modeling are composition, decomposition, generalization, and specialization of entities; identification of relevant relations and cardinality between entities; and the definition of process or functional interfaces. Structure diagrams provided by the UML for structure modeling include class, component, object, deployment, and packaging diagrams.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Structure_Modeling</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Structure Modeling</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Supervised_internship</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Mandatory Supervised Internship in Companies or External Entities

Supervised Internship is a compulsory activity in the course. In order to achieve its purpose, by associating the educational process with learning, the stage must be planned, executed, monitored and evaluated within specific and well-defined procedures norms and also be in accordance with the assumptions that guide the pedagogical project of the course.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Supervised_internship</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Supervised internship</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Surveillance_of_Software_Configuration_Management</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">After the SCM process has been implemented, some degree of surveillance may be necessary to ensure that the provisions of the SCMP are properly carried out. There are likely to be specific SQA requirements for ensuring compliance with specified SCM processes and procedures. The person responsible for SCM ensures that those with the assigned responsibility perform the defined SCM tasks correctly. The software quality assurance authority, as part of a compliance auditing activity, might also perform this surveillance. Surveillance requirements and the level of flexibility to be provided to the software engineer are important considerations in tool selection. SCM measures can be designed to provide specific information on the evolving product or to provide insight into the functioning of the SCM process. A related goal of monitoring the SCM process is to discover opportunities for process improvement. Analysis of the measurements may produce insights leading to process changes and corresponding updates to the SCMP. Software libraries and the various SCM tool capabilities provide sources for extracting information about the characteristics of the SCM process (as well as providing project and management information). In-Process Audits of SCM: Audits can be carried out during the software engineering process to investigate the current status of specific elements of the configuration or to assess the implementation of the SCM process.
In-process auditing of SCM provides a more formal mechanism for monitoring selected aspects of the process and may be coordinated with the SQA function.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Surveillance_of_Software_Configuration_Management</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Surveillance of Software Configuration Management</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Syntax_Semantics_and_Pragmatics</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Models can be surprisingly deceptive. The fact that a model is an abstraction with missing information can lead one into a false sense of completely understanding the software from a single model. A complete model (“complete” being relative to the modeling effort) may be a union of multiple submodels and any special function models. Examination and decision-making relative to a single model within this collection of submodels may be problematic. Understanding the precise meanings of modeling constructs can also be difficult. Modeling languages are defined by syntactic and semantic rules. For textual languages, syntax is defined using a notation grammar that defines valid language constructs (for example, Backus-Naur Form (BNF)). For graphical languages, syntax is defined using graphical models called metamodels. Semantics for modeling languages specify the meaning attached to the entities and relations captured within the model. For example, a simple diagram of two boxes connected by a line is open to a variety of interpretations. Knowing that the diagram on which the boxes are placed and connected is an object diagram or an activity diagram can assist in the interpretation of this model. As a practical matter, there is usually a good understanding of the semantics of a specific software model due to the modeling language selected, how that modeling language is used to express entities and relations within that model, the experience base of the modeler(s), and the
context within which the modeling has been undertaken and so represented. Meaning is communicated through the model even in the presence of incomplete information through abstraction; pragmatics explains how meaning is embodied
in the model and its context and communicated effectively to other software engineers. There are still instances, however, where caution is needed regarding modeling and semantics.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Syntax_Semantics_and_Pragmatics</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Syntax, Semantics, and Pragmatics</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Syntax_and_Semantics_of_Programming_Languages</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Just like natural languages, many programming languages have some form of written specification of their syntax (form) and semantics (meaning). Such specifications include, for example, specific requirements for the definition of variables and constants (in other words, declaration and types) and format requirements for the instructions themselves. In general, a programming language supports such constructs as variables, data types, constants, literals, assignment statements, control statements, procedures, functions, and comments. The syntax and semantics of each construct must be clearly specified.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Syntax_and_Semantics_of_Programming_Languages</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Syntax and Semantics of Programming Languages</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/System_Definition_Document</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">This document (sometimes known as the user requirements document or concept of operations document) records the system requirements. It defines the high-level system requirements from the domain perspective. Its readership includes representatives of the system users/customers (marketing may play these roles for market-driven software), so its content must be couched in terms of the domain. The document lists the system requirements along with background information about the overall objectives for the system, its target environment, and a statement of the constraints, assumptions, and nonfunctional requirements. It may include conceptual models designed to illustrate the system context, usage scenarios, and the principal domain entities, as well as workflows.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/System_Definition_Document</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">System Definition Document</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/System_Requirements_Specification</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software requirements specification establishes the basis for agreement between customers and contractors or suppliers (in market-driven projects, these roles may be played by the marketing and development divisions) on what the software product is to do as well as what it is not expected to do. Software requirements specification permits a rigorous assessment of requirements before design can begin and reduces later redesign. It should also provide a realistic basis for estimating product costs, risks, and schedules. Organizations can also use a software requirements specification document as the basis for developing effective verification and validation plans. Software requirements specification provides an informed basis for transferring a software product to new users or software platforms. Finally, it can provide a basis for software enhancement.
Software requirements are often written in natural language, but, in software requirements specification, this may be supplemented by formal or semiformal descriptions. Selection of appropriate notations permits particular requirements
and aspects of the software architecture to be described more precisely and concisely than natural language. The general rule is that notations should be used that allow the requirements to be described as precisely as possible. This is particularly crucial for safety-critical, regulatory, and certain other types of dependable software. However, the choice of notation is often constrained by the training, skills, and preferences of the document’s authors and readers.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/System_Requirements_Specification</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">System Requirements Specification</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/System_Requirements_and_Software_Requirements</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">In this topic, “system” means an interacting combination of elements to accomplish a defined objective. These include hardware, software, firmware, people, information, techniques, facilities, services, and other support elements,
as defined by the International Council on Software and Systems Engineering (INCOSE). System requirements are the requirements for the system as a whole. In a system containing software components, software requirements are derived from system requirements. This KA defines “user requirements” in a restricted way, as the requirements of the system’s customers or end users. System requirements, by contrast, encompass user requirements, requirements of other stakeholders (such as regulatory authorities), and requirements without an identifiable human source.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/System_Requirements_and_Software_Requirements</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">System Requirements and Software Requirements</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Systems_Engineering</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">“Systems engineering is the interdisciplinary approach governing the total technical and managerial effort required to transform a set of customer needs, expectations, and constraints into a solution and to support that solution throughout its life.”. The life cycle stages of systems engineering vary depending on the system being
built but, in general, include system requirements definition, system design, sub-system development, system integration, system testing, system installation, system evolution, and system decommissioning. Many practical guidelines have been produced in the past to aid people in performing the activities of each phase. For example, system design can be broken into smaller tasks of identification of subsystems, assignment of system requirements to subsystems, specification of subsystem functionality, definition of sub-system interfaces, and so forth.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Systems_Engineering</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Systems Engineering</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Tasks_of_DBMS_Packages</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A DBMS system provides the following capabilities: Database development is used to define and organize the content, relationships, and structure of the data needed to build a database; Database interrogation is used for accessing the data in a database for information retrieval and report generation. End users can selectively
retrieve and display information and produce printed reports. This is the operation
that most users know about databases; Database Maintenance is used to add, delete, update, and correct the data in a database; Application Development is used to develop prototypes of data entry screens, queries, forms, reports, tables, and labels for a prototyped application. It also refers to the use of 4th Generation Language or application generators to develop or generate program code.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Tasks_of_DBMS_Packages</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Tasks of DBMS Packages</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Tasks_of_an_Operating_System</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The tasks of an operating system differ significantly depending on the machine and time of its invention. However, modern operating systems have come to agreement as to the tasks that must be performed by an OS. These tasks include CPU management, memory management, disk management (file system), I/O device management, and security and protection. Each OS task manages one type of physical resource. Specifically, CPU management deals with the allocation and releases of the CPU among competing programs (called processes/threads in OS
jargon), including the operating system itself. The main abstraction provided by CPU management is the process/thread model. Memory management deals with the allocation and release of memory space among competing processes, and the main abstraction provided by memory management is virtual memory. Disk management deals with the sharing of magnetic or optical or solid state disks among multiple programs/users and its main abstraction is the file system. I/O device management deals with the allocation and releases of various I/O devices among competing processes.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Tasks_of_an_Operating_System</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Tasks of an Operating System</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Taxation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Governments charge taxes in order to finance expenses that society needs but that no single organization would invest in. Companies have to pay income taxes, which can take a substantial portion of a corporation’s gross profit. A decision analysis that does not account for taxation can lead to the wrong choice. A proposal with a high pretax profit won’t look nearly as profitable in posttax terms. Not accounting for taxation can also lead to unrealistically high expectations about how profitable a
proposed product might be.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Taxation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Taxation</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Teaching_Activities</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Monitoring of course subjects, technical course teacher, etc.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Teaching_Activities</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Teaching activities</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Team_and_Group_Communication</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Effective communication among team and group members is essential to a collaborative software engineering effort. Stakeholders must be consulted, decisions must be made, and plans must be generated. The greater the number of team and group members, the greater the need to communicate. The number of communication paths, however, grows quadratically with the addition of each team member. Further, team members are unlikely to communicate with anyone perceived to be removed from them by more than two degrees (levels). This problem can be more serious when software engineering endeavors or organizations are spread across national and continental borders. Some communication can be accomplished in writing. Software documentation is a common substitute for direct interaction. Email is another but, although it is useful, it is not always enough; also, if one sends too many messages, it becomes difficult to identify the important information. Increasingly, organizations are using enterprise collaboration tools to share information. In addition, the use of electronic information stores, accessible to all team members, for organizational
policies, standards, common engineering procedures, and project-specific information, can be most beneficial. Some software engineering teams focus on
face-to-face interaction and promote such interaction by office space arrangement. Although private offices improve individual productivity, colocating team members in physical or virtual forms and providing communal work areas is
important to collaborative efforts.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Team_and_Group_Communication</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Team and Group Communication</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Technical_Issues</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Limited understanding refers to how quickly a software engineer can understand where to make a change or correction in software that he or she did not develop. Research indicates that about half of the total maintenance effort is devoted to understanding the software to be modified. Testing: The cost of repeating full testing on a major piece of software is significant in terms of time and money. In order to ensure that the requested problem reports are valid, the maintainer should replicate or verify problems by running the appropriate tests. Regression testing (the selective retesting of software or a component to verify that the modifications have not caused unintended effects) is an important testing concept in maintenance. Additionally, finding time to test is often difficult. Coordinating tests when different members of the maintenance team are working on different problems at the same time remains a challenge. Impact Analysis: Impact analysis describes how to conduct, costeffectively, a complete analysis of the impact of a change in existing software. Maintainers must possess an intimate knowledge of the software’s structure and content. They use that knowledge to perform impact analysis, which identifies all systems and software products affected by a software change request and develops an estimate of the resources needed to accomplish the change. Additionally, the risk of making the change is determined. Impact analysis is performed after a change request enters the software configuration management process. The severity of a problem is often used to decide how and when it will be fixed. Maintainability: defines maintainability as the capability of the software product to be modified. Modifications may include corrections, improvements, or adaptation of the software to changes in environment as well as changes in requirements and functional specifications. As a primary software quality characteristic, maintainability should be specified, reviewed, and
controlled during software development activities in order to reduce maintenance costs. When done successfully, the software’s maintainability will improve.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Technical_Issues</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Technical Issues</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Techniques_Based_on_the_Nature_of_the_Application</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The above techniques apply to all kinds of software. Additional techniques for test derivation and execution are based on the nature of the software being tested; for example, object-oriented software, component-based software, web-based software, concurrent programs, protocol-based software, real-time systems, safety-critical systems, service-oriented software, open-source software, embedded software.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Techniques_Based_on_the_Nature_of_the_Application</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Techniques Based on the Nature of the Application</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Techniques_for_Conducting_Root_Cause_Analysis</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">There are many approaches used for both quality control and root cause analysis. The first step in any root cause analysis effort is to identify the real problem. Techniques such as statement-restatement, why-why diagrams, the revision method, present state and desired state diagrams, and the fresh-eye approach are used to identify and refine the real problem that needs to be addressed. Once the real problem has been identified, then work can begin to determine the cause of the problem. Ishikawa is known for the seven tools for quality control that he promoted. Some of those tools are helpful in identifying the causes for a given problem. Those tools are check sheets or checklists, Pareto diagrams, histograms, run charts, scatter diagrams, control charts, and fishbone or cause-and-effect diagrams. More recently, other approaches for quality improvement and root cause analysis have emerged. Some examples of these newer methods are affinity diagrams, relations diagrams, tree diagrams, matrix charts, matrix data analysis charts, process decision program charts, and arrow diagrams. A few of these techniques are briefly described below. A fishbone or cause-and-effect diagram is a way to visualize the various factors that affect some characteristic. The main line in the diagram represents the problem and the connecting lines represent the factors that led to or influenced the problem. Those factors are broken down into subfactors and sub-subfactors until root causes can be identified. A very simple approach that is useful in quality control is the use of a checklist. Checklists are a list of key points in a process with tasks that must be completed. As each task is completed, it is checked off the list. If a problem occurs, then sometimes the checklist can quickly identify tasks that may have been skipped or only partially
completed.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Techniques_for_Conducting_Root_Cause_Analysis</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Techniques for Conducting Root Cause Analysis</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Techniques_for_Maintenance</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">This topic introduces some of the generally accepted techniques used in software maintenance.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Techniques_for_Maintenance</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Techniques for Maintenance</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Termination_Decisions</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Termination means to end a project or product. Termination can be preplanned for the end of a long product lifetime (e.g., when foreseeing that a product will reach its lifetime) or can come rather spontaneously during product development (e.g., when project performance targets are not achieved). In both cases, the decision should be carefully prepared, considering always the alternatives of continuing versus terminating. Costs of different alternatives must be estimated covering
topics such as replacement, information collection, suppliers, alternatives, assets, and utilizing resources for other opportunities. Sunk costs should not be considered in such decision making because they have been spent and will not reappear as a value.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Termination_Decisions</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Termination Decisions</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Test_Activities</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">As shown in the following description, successful management of test activities strongly depends on the software configuration management process. Like all other aspects of project management, testing activities must be planned. Key aspects of test planning include coordination of personnel, availability of test facilities and equipment, creation and maintenance of all test-related documentation, and planning for possible undesirable outcomes. If more than one baseline of the software is being maintained, then a major planning consideration is the time and effort needed to ensure that the test environment is set to the proper configuration. Generation of test cases is based on the level of testing to be performed and the particular testing techniques. Test cases should be under the control of software configuration management and include the expected results for each test. The environment used for testing should be compatible with the other adopted software engineering tools. It should facilitate development and control of test cases, as well as logging and recovery of expected results, scripts, and other testing materials. Execution of tests should embody a basic principle of scientific experimentation: everything done during testing should be performed and documented clearly enough that another person could replicate the results. Hence, testing should be performed in accordance with documented procedures using a clearly defined version of the software under test. The results of testing should be evaluated to determine whether or not the testing has been successful. In most cases, “successful” means that the software performed as expected and did
not have any major unexpected outcomes. Not all unexpected outcomes are necessarily faults but are sometime determined to be simply noise. Before a fault can be removed, an analysis and debugging effort is needed to isolate, identify,
and describe it. When test results are particularly important, a formal review board may be convened to evaluate them.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Test_Activities</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Test Activities</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Test_First_Programming</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Test-first programming (also known as TestDriven Development-TDD) is a popular development style in which test cases are written prior to writing any code. Test-first programming can usually detect defects earlier and correct them
more easily than traditional programming styles. Furthermore, writing test cases first forces programmers to think about requirements and design before coding, thus exposing requirements and design problems sooner.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Test_First_Programming</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Test-First Programming</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Test_Levels</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software testing is usually performed at different levels throughout the development and maintenance processes. Levels can be distinguished based on the object of testing, which is called the target, or on the purpose, which is called the
objective (of the test level).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Test_Levels</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Test Levels</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Test_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Testing concepts, strategies, techniques, and measures need to be integrated into a defined and controlled process. The test process supports testing activities and provides guidance to testers and testing teams, from test planning to test output
evaluation, in such a way as to provide assurance that the test objectives will be met in a cost-effective way.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Test_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Test Process</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Test_Related_Measures</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Sometimes testing techniques are confused with testing objectives. Testing techniques can be viewed as aids that help to ensure the achievement of test objectives. For instance, branch coverage is a popular testing technique. Achieving a specified branch coverage measure (e.g., 95% branch coverage) should not be the objective of testing per se: it is a way of improving the chances of finding failures by attempting to systematically exercise every program branch at every decision point. To avoid such misunderstandings, a clear distinction should be made between test-related measures that provide an evaluation of the program under test, based on the observed test outputs, and the measures that evaluate the thoroughness of the test set.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Test_Related_Measures</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Test-Related Measures</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Test_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">One of the aims of testing is to detect as many failures as possible. Many techniques have been developed to do this. These techniques attempt to “break” a program by being as systematic as possible in identifying inputs that will produce representative program behaviors; for instance, by considering subclasses of the input domain, scenarios, states, and data flows. The classification of testing techniques presented here is based on how tests are generated: from the software engineer’s intuition and experience, the specifications, the code structure, the real or imagined faults to be discovered, predicted usage, models, or the nature of the application. One category deals with the combined use of two or more techniques.
Sometimes these techniques are classified as white-box (also called glass-box), if the tests are based on information about how the software has been designed or coded, or as black-box if the test cases rely only on the input/output behavior of the software. The following list includes those testing techniques that are commonly used, but some practitioners rely on some of the techniques more than others.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Test_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Test Techniques</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Testing_Related_Terminology</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Definitions of testing and testing-related terminology are provided in the cited references and summarized as follows. Many terms are used in the software engineering literature to describe a malfunction: notably fault, failure, and error, among others. It is essential to clearly distinguish between the cause of a malfunction (for which the term fault will be used here) and an undesired effect observed in the system’s delivered service (which will be called a failure). Indeed there may well be faults in the software that never manifest themselves as failures. Thus testing can reveal failures, but it is the faults that can and must be removed. The more generic term defect can be used to refer to either a fault or a failure, when the distinction is not important. However, it should be recognized that the cause of a failure cannot always be unequivocally identified. No theoretical criteria exist to definitively determine, in general, the fault that caused an observed failure. It might be said that it was the fault that had to be modified to remove the failure,
but other modifications might have worked just as well. To avoid ambiguity, one could refer to failure-causing inputs instead of faults that is, those sets of inputs that cause a failure to appear.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Testing_Related_Terminology</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Testing-Related Terminology</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Testing_Tool_Support</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Testing requires many labor-intensive tasks, running numerous program executions, and handling a great amount of information. Appropriate tools can alleviate the burden of clerical, tedious operations and make them less error-prone. Sophisticated tools can support test design and test case generation, making it more effective. Guidance to managers and testers on how to select testing tools that will be most useful to their organization and processes is a very important topic, as tool selection greatly affects testing efficiency and effectiveness. Tool selection depends on diverse evidence, such as development choices, evaluation objectives, execution facilities, and so on. In general, there may not be a unique tool that will satisfy particular needs, so a suite of tools could be an appropriate choice.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Testing_Tool_Support</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Testing Tool Support</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/The_Central_Processing_Unit</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The central processing unit is the place where instructions (or programs) are actually executed. The execution usually takes several steps, including fetching the program instruction, decoding the instruction, fetching operands, performing
arithmetic and logical operations on the operands, and storing the result. The main components of a CPU consist of registers where instructions and data are often read from and written to, the arithmetic and logic unit (ALU) that performs the actual arithmetic (such as addition, subtraction, multiplication, and division) and logic (such as AND, OR, shift, and so forth) operations, the control unit that is responsible for producing proper signals to control the operations, and various (data, address, and control) buses that link the components together and transport data to and from these components.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/The_Central_Processing_Unit</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The Central Processing Unit (CPU)</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/The_Compilation_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Compilation is a complex task. Most compilers divide the compilation process into many phases. A typical breakdown is as follows: Lexical Analysis; Syntax Analysis or Parsing; Semantic Analysis; Code Generation Lexical analysis partitions the input text (the source code), which is a sequence of characters, into separate comments, which are to be ignored in subsequent actions, and basic symbols, which have lexical meanings. These basic symbols must correspond to some terminal symbols of the grammar of the particular programming language. Here terminal symbols refer to the elementary symbols (or tokens) in the grammar that cannot be changed. Syntax analysis is based on the results of the lexical analysis and discovers the structure in the program and determines whether or not a text conforms to an expected format. Is this a textually correct C++ program? or Is this entry textually
correct? are typical questions that can be answered by syntax analysis. Syntax analysis determines if the source code of a program is correct and converts it into a more structured representation (parse tree) for semantic analysis or transformation.
Semantic analysis adds semantic information to the parse tree built during the syntax analysis and builds the symbol table. It performs various semantic checks that include type checking, object binding (associating variable and function
references with their definitions), and definite assignment (requiring all local variables to be initialized before use). If mistakes are found, the semantically incorrect program statements are rejected and flagged as errors.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/The_Compilation_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The Compilation Process</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/The_Design_of_Information_Presentation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Information presentation may be textual or graphical in nature. A good design keeps the information presentation separate from the information itself. The MVC (Model-View-Controller) approach is an effective way to keep information presentation separating from the information being presented. Software engineers also consider software response time and feedback in the design of information presentation. Response time is generally measured from the point at which a user executes a certain control action until the software responds with a response. An indication of progress is desirable while the software is preparing the response. Feedback can be provided by restating the user’s input while processing is being completed. Abstract visualizations can be used when large amounts of information are to be presented. According to the style of information presentation, designers can also use color to enhance the interface. There are several important guidelines: Limit the number of colors used; Use color change to show the change of software
status; Use color-coding to support the user’s task; Use color-coding in a thoughtful and consistent way; Use colors to facilitate access for people with color blindness or color deficiency (e.g., use the change of color saturation and color brightness, try to avoid blue and red combinations); Don’t depend on color alone to convey important information to users with different capabilities (blindness, poor eyesight, colorblindness, etc.).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/The_Design_of_Information_Presentation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The Design of Information Presentation</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/The_Design_of_User_Interaction_Modalities</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">User interaction involves issuing commands and providing associated data to the software. User interaction styles can be classified into the following primary styles: Question-answer. The interaction is essentially restricted to a single question-answer exchange between the user and the software. The user issues a question to the software, and the software returns the answer to the question; Direct manipulation. Users interact with objects on the computer screen. Direct
manipulation often includes a pointing device (such as a mouse, trackball, or a finger on touch screens) that manipulates an object and invokes actions that specify what is to be done with that object; Menu selection. The user selects a command from a menu list of commands; Form fill-in. The user fills in the fields of a form. Sometimes fields include menus, in which case the form has action buttons for the user to initiate action; Command language. The user issues a command and provides related parameters to direct the software what to do; Natural language. The user issues a command in natural language. That is, the natural language is a front end to a command language and is parsed and translated into software commands.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/The_Design_of_User_Interaction_Modalities</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The Design of User Interaction Modalities</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/The_Good_Enough_Principle</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Often software engineering projects and products are not precise about the targets that should be achieved. Software requirements are stated, but the marginal value of adding a bit more functionality cannot be measured. The result could be late delivery or too-high cost. The “good enough” principle relates marginal value to marginal cost and provides guidance to determine criteria when a deliverable is “good enough” to be delivered. These criteria depend on business objectives and
on prioritization of different alternatives, such as ranking software requirements, measurable quality attributes, or relating schedule to product content
and cost. The RACE principle (reduce accidents and control essence) is a popular rule towards good enough software. Accidents imply unnecessary overheads such as gold-plating and rework due to late defect removal or too many requirements
changes. Essence is what customers pay for. Software engineering economics provides the mechanisms to define criteria that determine when a deliverable is “good enough” to be delivered. It also highlights that both words are relevant:
“good” and “enough.” Insufficient quality or insufficient quantity is not good enough. Agile methods are examples of “good enough” that try to optimize value by reducing the overhead of delayed rework and the gold plating that results from adding features that have low marginal value for the users. In agile methods, detailed planning and lengthy development phases are replaced by incremental planning and frequent delivery of small increments of a deliverable product that is tested and evaluated by user representatives.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/The_Good_Enough_Principle</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The “Good Enough” Principle</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/The_Internet</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The Internet is a global system of interconnected governmental, academic, corporate, public, and private computer networks. In the public domain access to the internet is through organizations known as internet service providers (ISP). The
ISP maintains one or more switching centers called a point of presence, which actually connects the users to the Internet.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/The_Internet</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The Internet</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/The_Programming_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Programming involves design, writing, testing, debugging, and maintenance. Design is the conception or invention of a scheme for turning a customer requirement for computer software into operational software. It is the activity that links application requirements to coding and debugging. Writing is the actual coding of the design in an appropriate programming language. Testing is the activity to verify that the code one writes actually does what it is supposed to do. Debugging is the activity to find and fix bugs (faults) in the source code (or design). Maintenance is the activity to update, correct, and enhance existing programs.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/The_Programming_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The Programming Process</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/The_Target_of_the_Test</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The target of the test can vary: a single module, a group of such modules (related by purpose, use, behavior, or structure), or an entire system. Three test stages can be distinguished: unit, integration, and system. These three test stages do not imply any process model, nor is any one of them assumed to be more important than the other two. Unit testing verifies the functioning in isolation of software elements that are separately testable. Depending on the context, these could be the individual subprograms or a larger component
made of highly cohesive units. Typically, unit testing occurs with access to the code being tested and with the support of debugging tools. The programmers
who wrote the code typically, but not always, conduct unit testing. Integration testing is the process of verifying the interactions among software components. Classical integration testing strategies, such as topdown and bottom-up, are often used with hierarchically structured software. Modern, systematic integration strategies are typically architecture-driven, which involves incrementally integrating the software components or subsystems based on identified functional threads. Integration testing is often an ongoing activity at each stage of development during which software engineers abstract away lower-level perspectives and concentrate on the perspectives of the level at which they are integrating. For other than small, simple software, incremental integration testing strategies are usually preferred to putting all of the components together at once which is often called “big bang” testing. System testing is concerned with testing the behavior of an entire system. Effective unit and integration testing will have identified many of the software defects. System testing is usually considered appropriate for assessing the nonfunctional system requirements such as security, speed, accuracy, and reliability. External interfaces to other applications, utilities, hardware devices, or the operating environments are also usually evaluated at this level.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/The_Target_of_the_Test</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The Target of the Test</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Time_Value_of_Money</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">One of the most fundamental concepts in finance and therefore, in business decisions  is that money has time-value: its value changes over time. A specific amount of money right now almost always has a different value than the same
amount of money at some other time. This concept has been around since the earliest recorded human history and is commonly known as timevalue. In order to compare proposals or portfolio elements, they should be normalized in cost,
value, and risk to the net present value. Currency exchange variations over time need to be taken into account based on historical data. This is particularly
important in cross-border developments of all kinds.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Time_Value_of_Money</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Time-Value of Money</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Traceability</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Developing software typically involves the use, creation, and modification of many work products such as planning documents, process specifications, software requirements, diagrams, designs and pseudo-code, handwritten and tool-generated code, manual and automated test cases and reports, and files and data. These work products may be related through various dependency relationships (for example, uses, implements, and tests). As software is being developed, managed, maintained, or extended, there is a need to map and control these traceability relationships to demonstrate software requirements consistency with the software model and the many work products. Use of traceability typically improves the management of software work products and software process quality; it also provides assurances to stakeholders that all requirements have been satisfied.
Traceability enables change analysis once the software is developed and released, since relationships to software work products can easily be traversed to assess change impact. Modeling tools typically provide some automated or manual means to specify and manage traceability links between requirements, design, code, and/or test entities as may be represented in the models and other software work products.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Traceability</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Traceability</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Tradeoff_Analysis</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Within the practice of software engineering, a software engineer often has to choose between alternative problem solutions. The outcome of these choices is determined by the software engineer’s professional evaluation of the risks, costs,
and benefits of alternatives, in cooperation with stakeholders. The software engineer’s evaluation is called “tradeoff analysis.” Tradeoff analysis notably enables the identification of competing and complementary software requirements in order to prioritize the final set of requirements defining the software to be constructed. In the case of an ongoing software development project that is late or over budget, tradeoff analysis is often conducted to decide which software requirements can be relaxed or dropped given the effects thereof. A first step in a tradeoff analysis is establishing design goals and setting the relative importance of those goals. This permits identification of the solution that most nearly meets those goals; this means that the way the goals are stated is critically important. Design goals may include minimization of monetary cost and maximization of reliability, performance, or some other criteria on a wide range of dimensions.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Tradeoff_Analysis</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Tradeoff Analysis</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Trees</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The subtree at node X is the subgraph of the tree consisting of node X and its descendants and all edges incident to those descendants. As an alternate to this recursive definition, a tree may be defined as a connected undirected graph with
no simple circuits. However, one should remember that a tree is strictly hierarchical in nature as compared to a graph, which is flat. In case of a tree, an ordered pair is built between two nodes as parent and child. Each child node in a tree is associated
with only one parent node, whereas this restriction becomes meaningless for a graph where no parent-child association exists. A tree is called an ordered tree if the relative position of occurrences of children nodes is significant. For example, a family tree is an ordered tree if, as a rule, the name of an elder sibling appears
always before (i.e., on the left of) the younger sibling. In an unordered tree, the relative position of occurrences between the siblings does not bear any significance and may be altered arbitrarily. A binary tree is formed with zero or more nodes
where there is a root node R and all the remaining nodes form a pair of ordered subtrees under the root node. In a binary tree, no internal node can have more than two children. However, one must consider that besides this criterion in terms of the degree of internal nodes, a binary tree is always ordered. If the positions of the left and right subtrees for any node in the tree are swapped, then a new tree is derived.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Trees</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Trees</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Types_of_Data_Structure</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">As mentioned above, different perspectives can be used to classify data structures. However, the predominant perspective used in classification centers on physical and logical ordering between data items. This classification divides data structures into linear and nonlinear structures. Linear structures organize data items in a single dimension in which each data entry has one (physical or logical) predecessor and one successor with the exception of the first and last entry. The first entry has no predecessor and the last entry has no successor. Nonlinear structures organize data
items in two or more dimensions, in which case one entry can have multiple predecessors and successors. Examples of linear structures include lists, stacks, and queues. Examples of nonlinear structures include heaps, hash tables, and trees (such as binary trees, balance trees, B-trees, and so forth). Another type of data structure that is often encountered in programming is the compound structure. A compound data structure builds on top of other (more primitive) data structures and, in some way, can be viewed as the same structure as the underlying structure. Examples of compound structures include sets, graphs, and partitions. For example, a partition can be viewed as a set of sets.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Types_of_Data_Structure</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Types of Data Structure</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Types_of_Errors</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">When a program does not work, it is often because the program contains bugs or errors that can be either syntactic errors, logical errors, or data errors. Logical errors and data errors are also known as two categories of “faults” in software engineering terminology. Syntax errors are simply any error that prevents the translator (compiler/interpreter) from successfully parsing the statement. Every statement in a program must be parse-able before its meaning can be understood and interpreted (and, therefore, executed). In high-level programming languages, syntax errors are caught during the compilation or translation from the high-level language into machine code. For example, in the C/C++ programming language, the statement
“123=constant;” contains a syntax error that will be caught by the compiler during compilation. Logic errors are semantic errors that result in incorrect computations or program behaviors. Your program is legal, but wrong! So the results do not match the problem statement or user expectations. For example, in the C/C++ programming language, the inline function “int f(int x) {return f(x-1);}” for computing factorial x! is legal but logically incorrect. This type of error cannot be
caught by a compiler during compilation and is often discovered through tracing the execution of the program.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Types_of_Errors</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Types of Errors</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Types_of_Models</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A typical model consists of an aggregation of submodels. Each submodel is a partial description and is created for a specific purpose; it may be comprised of one or more diagrams. The collection of submodels may employ multiple modeling languages or a single modeling language. The Unified Modeling Language (UML) recognizes a rich collection of modeling diagrams. Use of these diagrams, along with the modeling language constructs, brings about three broad model types commonly used: information models, behavioral models, and structure models.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Types_of_Models</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Types of Models</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Types_of_Network</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Computer networks are not all the same and may be classified according to a wide variety of characteristics, including the network’s connection method, wired technologies, wireless technologies, scale, network topology, functions, and speed. But the classification that is familiar to most is based on the scale of networking.
Personal Area Network/Home Network is a computer network used for communication among computer(s) and different information technological devices close to one person. The devices connected to such a network may include PCs, faxes, PDAs, and TVs. This is the base on which the Internet of Things is built.
 Local Area Network (LAN) connects computers and devices in a limited geographical area, such as a school campus, computer laboratory, office building, or closely positioned group of buildings. Campus Network is a computer network made up of an interconnection of local area networks (LANs) within a limited geographical area. Wide area network (WAN) is a computer network that covers a large geographic area, such as a city or country or even across intercontinental
distances. A WAN limited to a city is sometimes called a Metropolitan Area
Network. Internet is the global network that connects computers located in many (perhaps all) countries.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Types_of_Network</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Types of Network</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Unit_Testing_Tools</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Unit testing verifies the functioning of software modules in isolation from other software elements that are separately testable (for example, classes, routines, components). Unit testing is often automated. Developers can use unit testing tools and frameworks to extend and create automated testing environment. With unit testing tools and frameworks, the developer can code criteria into the test to verify the unit’s correctness under various data sets. Each individual test is implemented
as an object, and a test runner runs all of the tests. During the test execution, those failed test cases will be automatically flagged and reported.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Unit_Testing_Tools</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Unit Testing Tools</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Unit_of_Analysis_Population_and_Sample</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Unit of analysis. While carrying out any empirical study, observations need to be made on chosen units called the units of analysis or sampling units. The unit of analysis must be identified and must be appropriate for the analysis. For example, when a software product company wants to find the perceived usability of a software product, the user or the software function may be the unit of analysis. Population. The set of all respondents or items (possible sampling units) to be studied forms the population. As an example, consider the case of studying the perceived usability of a software product. In this case, the set of all possible users
forms the population. While defining the population, care must be exercised to understand the study and target population. There are cases when the population
studied and the population for which the results are being generalized may be different. For example, when the study population consists of only past observations and generalizations are required for the future, the study population and the target population may not be the same. Sample. A sample is a subset of the population. The most crucial issue towards the selection of a sample is its representativeness, including size. The samples must be drawn in a manner so as
to ensure that the draws are independent, and the rules of drawing the samples must be predefined so that the probability of selecting a particular sampling unit is known beforehand. This method of selecting samples is called probability sampling.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Unit_of_Analysis_Population_and_Sample</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Unit of Analysis (Sampling Units), Population, and Sample</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Usage_Based_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">In testing for reliability evaluation (also called operational testing), the test environment reproduces the operational environment of the software, or the operational profile, as closely as possible. The goal is to infer from the observed test results the future reliability of the software when in actual use. To do this, inputs are assigned probabilities, or profiles, according to their frequency of occurrence in actual operation. Operational profiles can be used during system testing to guide derivation of test cases that will assess the achievement of reliability objectives and exercise relative usage and criticality of different functions similar to what will be encountered in the operational environment. Usability principles can provide guidelines for discovering problems in the design of the user interface. Specialized heuristics, also called usability inspection methods, are applied for the systematic observation of system usage under controlled conditions in order to determine how well people can use the system and its interfaces. Usability heuristics include cognitive walkthroughs, claims analysis, field observations, thinking aloud, and even indirect approaches such as user questionnaires and interviews.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Usage_Based_Techniques</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Usage-Based Techniques</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/User_Input_and_Output</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Input and output are the interfaces between users and software. Software is useless without input and output. Humans design software to process some input and produce desirable output. All software engineers must consider input and output as an integral part of the software product they engineer or develop. Issues considered for input include (but are not limited to): What input is required? How is the input passed from users to computers? What is the most convenient way for users to
enter input? What format does the computer require of the input data? The designer should request the minimum data from human input, only when the data is not already stored in the system. The designer should format and edit the data at the time of entry to reduce errors arising from incorrect or malicious data entry. For output, we need to consider what the users wish to see: In what format would users like to see output? What is the most pleasing way to display output? If the party interacting with the software isn’t human but another software or computer or control system, then we need to consider the input/output type and format that the software should produce to ensure proper data exchange between systems. There are many rules of thumb for developers to follow to produce good input/output for a software.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/User_Input_and_Output</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Input and Output</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/User_Interface_Design</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">User interface design is an essential part of the software design process. User interface design should ensure that interaction between the human and the machine provides for effective operation and control of the machine. For software to achieve its full potential, the user interface should be designed to match the skills, experience, and expectations of its anticipated users.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/User_Interface_Design</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">User Interface Design</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/User_Interface_Design_Issues</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">User interface design should solve two key issues: How should the user interact with the software? How should information from the software be presented to the user? User interface design must integrate user interaction and information presentation. User interface design should consider a compromise between the most appropriate styles of interactionand presentation for the software, the background and experience of the software users, and the available devices.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/User_Interface_Design_Issues</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">User Interface Design Issues</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/User_Interface_Design_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">User interface design is an iterative process; interface prototypes are often used to determine the features, organization, and look of the software user interface. This process includes three core activities: User analysis. In this phase, the designer analyzes the users’ tasks, the working environment, other software, and how users interact with other people; Software prototyping. Developing prototype software help users to guide the evolution of the interface; Interface evaluation. Designers can observe users’ experiences with the evolving interface.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/User_Interface_Design_Process</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">User Interface Design Process</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Valuation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">In an abstract sense, the decision-making process be it financial decision making or other is about maximizing value. The alternative that maximizes total value should always be chosen. A financial basis for value-based comparison is comparing two or more cash flows. Several bases of comparison are available, including present worth, future worth, annual equivalent, internal rate of return, (discounted) payback period. Based on the time-value of money, two or more cash flows are equivalent only when they equal the same amount of money at a common point in time. Comparing cash flows only makes sense when they are expressed in the same time frame. Note that value can’t always be expressed in terms of money. For example, whether an item is a brand name or not can significantly affect its perceived value. Relevant values that can’t be expressed in terms of money still need to be expressed in similar terms so that they can be evaluated objectively.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Valuation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Valuation</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Value_and_Costs_of_Quality</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Defining and then achieving software quality is not simple. Quality characteristics may or may not be required, or they may be required to a greater or lesser degree, and tradeoffs may be made among them. To help determine the level of software quality, i.e., achieving stakeholder value, this section presents cost of software quality (CoSQ): a set of measurements derived from the economic assessment of software quality development and maintenance processes.  The premise underlying the CoSQ is that the level of quality in a software product can be inferred from the cost of activities related to dealing with the consequences of poor quality. Poor
quality means that the software product does not fully “satisfy stated and implied needs” or “established requirements.” There are four cost of quality categories: prevention, appraisal, internal failure, and external failure. Prevention costs include investments in software process improvement efforts, quality infrastructure, quality tools, training, audits, and management reviews. These costs are usually not specific to a project; they span the organization. Appraisal costs arise from project activities that find defects. These appraisal activities can be categorized into costs of reviews (design, peer) and costs of testing (software unit testing, software integration, system level testing, acceptance testing); appraisal costs would be extended to subcontracted software suppliers. Costs of internal failures are those that are incurred to fix defects found during appraisal activities and discovered prior to delivery of the software product to the customer.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Value_and_Costs_of_Quality</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Value and Costs of Quality</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Verification_e_Validation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">The purpose of V&amp;V is to help the development organization build quality into the system during the life cycle. V&amp;V processes provide an objective assessment of products and processes throughout the life cycle. This assessment demonstrates whether the requirements are correct, complete, accurate, consistent, and testable. The V&amp;V processes determine whether the development products of a given activity conform to the requirements of that activity and whether the product satisfies its intended use and user needs. Verification is an attempt to ensure that the product is built correctly, in the sense that the output products of an activity meet the specifications imposed on them in previous activities. Validation is an attempt to ensure that the right product is built that is, the product fulfills its
specific intended purpose. Both the verification process and the validation process begin early in the development or maintenance phase. They provide an examination of key product features in relation to both the product’s immediate predecessor and the specifications to be met. The purpose of planning V&amp;V is to ensure that each resource, role, and responsibility is clearly assigned. The resulting V&amp;V plan documents describe the various resources and their roles and activities, as well as the techniques and tools to be used. An understanding of the different purposes of each V&amp;V activity helps in the careful planning of the techniques and resources needed to fulfill their purposes.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Verification_e_Validation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Verification &amp; Validation</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Virtual_Private_Network</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">A virtual private network is a preplanned virtual connection between nodes in a LAN/WAN or on the internet. It allows the network administrator to separate network traffic into user groups that have a common affinity for each other such as
all users in the same organization, or workgroup. This circuit type may improve performance and security between nodes and allows for easier maintenance of circuits when troubleshooting.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Virtual_Private_Network</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Virtual Private Network (VPN)</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:description"/>
        <IRI>/Writing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Software engineers are able to produce written products as required by customer requests or generally accepted practice. These written products may include source code, software project plans, software requirement documents, risk analyses,
software design documents, software test plans, user manuals, technical reports and evaluations, justifications, diagrams and charts, and so forth. Writing clearly and concisely is very important because often it is the primary method of communication among relevant parties. In all cases, written software engineering products must be written so that they are accessible, understandable and relevant for their intended audience(s).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/Writing</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Writing</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/goals</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Goals</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/habilitation</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Habilitation</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/performance</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Performance</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="dc:title"/>
        <IRI>/professional_profile</IRI>
        <Literal xml:lang="en" datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">Professional Profile</Literal>
    </AnnotationAssertion>
</Ontology>



<!-- Generated by the OWL API (version 4.2.8.20170104-2310) https://github.com/owlcs/owlapi -->

